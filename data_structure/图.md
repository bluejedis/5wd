# 第6章图  

# 【考纲内容】  

图的基本概念  

（二）图的存储及基本操作邻接矩阵：邻接表：邻接多重表；十字链表  

（四）图的基本应用最小（代价）生成树：最短路径；拓扑排序：关键路径  

# 【知识框架】  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1736cc1858562584a3b9c75bce02bd73a9deed0a76bcc241d437fa01e41ebb56.jpg)  

【复习提示】  

图算法的难度较大，主要掌握深度优先搜索与广度优先搜索。掌握图的基木概念及基本性质、图的存储结构（邻接矩阵、邻接表、邻接多重表和十字链表）及特性、存储结构之间的转化、基于存储结构上的各种遍历操作和各种应用（拓扑排序、最小生成树、最短路径和关键路径）等。图的相关算法较多，通常只需掌握其基本思想和实现步骤，而实现代码不是重点。  

# 6.1图的基本概念  

6.1.1图的定义  

图 $G$ 由顶点集 $V$ 和边集 $E$ 组成，记为 $G=(V,\,E)$ ，其中 $V(G)$ 表示图 $G$ 中顶点的有限非空集； $E(G)$ 表示图 $G$ 中顶点之间的关系（边）集合。若 $V=\{v_{1},\,v_{2},\cdots,\,v_{n}\}$ ，则用IV表示图 $G$ 中顶点的个数， $E=\{(u,v)\mid u{\in}V,v{\in}V\}$ ，用 $|E|$ 表示图 $G$ 中边的条数。  
# 注意  

线性表可以是空表，树可以是空树，但图不可以是空图。也就是说，图中不能一个顶点也没有，图的顶点集 $V$ 一定非空，但边集 $E$ 可以为空，此时图中只有顶点而没有边。  

下面是图的一些基本概念及术语。  

1.有向图  

若 $E$ 是有向边（也称弧）的有限集合，则图 $G$ 为有向图。弧是顶点的有序对，记为y， $w^{>}$ 其中 $v,w$ 是顶点， $v$ 称为弧尾， $w$ 称为弧头，<v,W>称为从v到 $w$ 的弧，也称v邻接到 $w$ 。  

图6.1（a）所示的有向图 $G_{1}$ 可表示为  

$$
G_{1}\!=\!(V_{1},E_{1})
$$  

$$
E_{1}=\{<\!1,2\!>,<\!2,1\!>,<\!2,3\!>\}
$$  

2.无向图  

若 $E$ 是无向边（简称边）的有限集合，则图 $G$ 为无向图。边是顶点的无序对，记为 $(v,\,w)$ 或 $(w,v)$  。可以说  $w$  和  $\nu$  互为邻接点。边  $(v,w)$  依附于  $w$  和  $v$  ，或称边  $(v,w)$  和  $v,w$  相关联。  

图6.1（b）所示的无向图 $G_{2}$ 可表示为  

$$
\begin{array}{c}{G_{2}=\left(V_{2},E_{2}\right)}\\ {V_{2}=\left\{1,2,3,4\right\}}\end{array}
$$  

$$
E_{2}=\{(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)\}
$$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5151560dfc0c00af5239183bc6f467e3c9e73df7d8ee3886d9de445058a96358.jpg)  
图6.1图的示例  

3.简单图、多重图  

一个图 $G$ 若满足： $\textcircled{\scriptsize{1}}$ 不存在重复边； $\circledcirc$ 不存在顶点到自身的边，则称图 $G$ 为简单图。图6.1中 $G_{1}$ 和 $G_{2}$ 均为简单图。若图 $G$ 中某两个顶点之间的边数大于1条，又充许顶点通过一条边和自身关联，则称图 $G$ 为多重图。多重图和简单图的定义是相对的。本书中仅讨论简单图。  

# 4.完全图（也称简单完全图）  

对于无向图， $|E|$ 的取值范围为0到 $n(n-1)/2$ ，有 $n(n-1)/2$ 条边的无向图称为完全图，在完全图中任意两个顶点之间都存在边。对于有向图， $|E|$ 的取值范围为0到 $n(n-1)$ ，有 $n(n-1)$ 条弧的有向图称为有向完全图，在有向完全图中任意两个顶点之间都存在方向相反的两条弧。图6.1中 $G_{2}$ 为无向完全图，而 $G_{3}$ 为有向完全图。  

5.子图  

设有两个图 $G=(V,E)$ 和 $G^{\prime}=(V,E^{\prime})$ ，若 $V$ 是 $V$ 的子集，且 $E^{\prime}$ 是 $E$ 的子集，则称 $G^{\prime}$ 是 $G$ 的子图。若有满足 $V(G^{\prime})=V(G)$ 的子图 $G^{\prime}$ ，则称其为 $G$ 的生成子图。图6.1中 $G_{3}$ 为 $G_{1}$ 的子图。  
# 注意  

并非 $V$ 和 $E$ 的任何子集都能构成 $G$ 的子图，因为这样的子集可能不是图，即 $E$ 的子集中的某些边关联的顶点可能不在这个 $V$ 的子集中。  

6.连通、连通图和连通分量  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/69224036bff123d02b308266e0d7f55e821273fdb4588553d671e49cea7a8c2f.jpg)  

图的连通性与边和顶点的关系（2010、2022）  

在无向图中，若从顶点 $\nu$ 到顶点 $w$ 有路径存在，则称 $v$ 和 $w$ 是连通的。若图 $G$ 中任意两个顶点都是连通的，则称图 $G$ 为连通图，否则称为非连通图。无向图中的极大连通子图称为连通分量，在图6.2（a)中，图 $G_{4}$ 有3个连通分量如图6.2（b）所示。假设一个图有 $n$ 个顶点，若边数小于 $_{n-1}$ ，则此图必是非连通图；思考，若图是非连通图，则最多可以有多少条边？  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8d9d6a37be3c6ce09a5a0aa15355ead14bf7a5a3e352c73cf8d0cb852ebd9b30.jpg)  
图6.2无向图及其连通分量  

# 7.强连通图、强连通分量  

在有向图中，若有一对顶点 $v$ 和 $w$ ，从 $v$ 到 $w$ 和从 $w$ 到 $v$ 之间都有路径，则称这两个顶点是强连通的。若图中任意一对顶点都是强连通的，则称此图为强连通图。有向图中的极大强连通子图称为有向图的强连通分量，图 $G_{1}$ 的强连通分量如图6.3所示。思考，假设一个有向图有 $n$ 个顶点，若是强连通图，则最少需要有多少条边？?  

# 注意  

在无向图中讨论连通性，在有向图中讨论强连通性。  

8.生成树、生成森林  

连通图的生成树是包含图中全部顶点的一个极小连通子图。若图中顶点数为 $n$ ，则它的生成树含有 $n\!-\!1$ 条边。包含图中全部顶点的极小连通子图，只有生成树满足这个极小条件，对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。在非连通图中，连通分量的生成树构成了非连通图的生成森林。图 $G_{2}$ 的一个生成树如图6.4所示。  
# 01e 3  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bfa9e01aeec1a2c5a3b7b4d36a675036ff24683fc2cf93f63569eaa97879224d.jpg)  
图6.4图 $G_{2}$ 的一个生成树  

# 注意  

区分极大连通子图和极小连通子图。极大连通子图要求子图必须连通，而且包含尽可能多的顶点和边；极小连通子图是既要保持子图连通又要使得边数最少的子图。  

# 9.顶点的度、入度和出度  

无向图中顶点和边的关系（2009、2017）  

在无向图中，顶点 $v$ 的度是指依附于顶点 $v$ 的边的条数，记为 $\operatorname{TD}(\nu)$ 。在图6.1(b中，每个顶点的度均为3。无向图的全部顶点的度之和等于边数的2倍，因为每条边和两个顶点相关联。  

在有向图中，顶点 $v$ 的度分为入度和出度，入度是以顶点 $v$ 为终点的有向边的数目，记为ID(v)：而出度是以顶点 $v$ 为起点的有向边的数目，记为 $\mathrm{{OD}}(v)$ 。在图6.1（a中，顶点2的出度为2、入度为1。顶点 $v$ 的度等于其入度与出度之和，即 $\mathrm{TD}(\nu)=\mathrm{ID}(\nu)+\mathrm{OD}(\nu)$ 。有向图的全部顶点的入度之和与出度之和相等，并且等于边数，这是因为每条有向边都有一个起点和终点。  

# 10.边的权和网  

在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。这种边上带有权值的图称为带权图，也称网。  

# 11.稠密图、稀疏图  

边数很少的图称为稀疏图，反之称为稠密图。稀疏和稠密本身是模糊的概念，稀疏图和稠 密图常常是相对而言的。一般当图 $G$ 满足 $|E|<|V|\mathrm{log}|V|$ 时，可以将 $G$ 视为稀疏图。  

# 12.路径、路径长度和回路  

顶点 $\boldsymbol{v}_{p}$ 到顶点 $\nu_{q}$ 之间的一条路径是指顶点序列 $v_{p},v_{i_{1}},v_{i_{2}},\cdots,v_{i_{m}},v_{q}$ ，当然关联的边也可理解为路径的构成要素。路径上的边的数目称为路径长度。第一个顶点和最后一个顶点相同的路径称为回路或环。若一个图有 $n$ 个顶点，且有大于 $n\!-\!1$ 条边，则此图一定有环。  

# 13.简单路径、简单回路  

命题追踪路径、回路、简单路径、简单回路的定义（2011）  

在路径序列中，顶点不重复出现的路径称为简单路径。除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。  

14.距离  

从顶点 $u$ 出发到顶点 $v$ 的最短路径若存在，则此路径的长度称为从 $u$ 到 $v$ 的距离。若从 $u$ 到根本不存在路径，则记该距离为无穷（）。  

# 15.有向树  

一个顶点的入度为0、其余顶点的入度均为1的有向图，称为有向树。  


# 6.2图的存储及基本操作  

图的存储必须要完整、准确地反映顶点集和边集的信息。根据不同图的结构和算法，采用不同的存储方式将对程序的效率产生相当大的影响，因此所选的存储结构应适合于待求解的问题。  

# 6.2.1邻接矩阵法  

所谓邻接矩阵存储，是指用一个一维数组存储图中顶点的信息，用一个二维数组存储图中边的信息（即各顶点之间的邻接关系），存储顶点之间邻接关系的二维数组称为邻接矩阵。  

顶点数为 $n$ 的图 $G\!=\!(V,E)$ 的邻接矩阵 $_A$ 是 $_{n\times n}$ 的，将 $G$ 的顶点编号为 $v_{1},v_{2},\cdots,v_{n},$ 则  

>#### pro：图的邻接矩阵存储及相互转换（2011、2015、2018）  

对带权图而言，若顶点 $v_{i}$ 和 $\nu_{j}$ 之间有边相连，则邻接矩阵中对应项存放着该边对应的权值，若顶点 $V_{i}$ 和 $V_{j}$ 不相连，则通常用0或 $\infty$ 来代表这两个顶点之间不存在边：  

有向图、无向图和网对应的邻接矩阵示例如图6.5所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/452c3b970dbd32b4453acaa0973977edccafa0e6e194da0812a21b6fe6148c9b.jpg)  
图6.5有向图、无向图及网的邻接矩阵  

>#### pro：（算法题）邻接矩阵的遍历及顶点的度的计算（2021、2023）  

图的邻接矩阵存储结构定义如下：  

#define Max Vertex Num l00typedef char VertexType;  
typedef int EdgeType;//边对应的数据类型typedef struct{ Vertex Type vex[Max Vertex Num];/顶点表Edge Type edge[Max Vertex Num][Max Vertex Num]；//邻接矩阵，边表int vexnum,arcnum;/图的当前顶点数和边数)MGraph;  

# 注意  

$\textcircled{\scriptsize{1}}$ 在简单应用中，可直接用二维数组作为图的邻接矩阵（顶点信息等均可省略）。 $\circledcirc$ 当邻接矩阵的元素仅表示相应边是否存在时，EdgeType可用值为0和1的枚举类型。 $\textcircled{3}$ 无向图的邻接矩阵是对称矩阵，对规模特大的邻接矩阵可采用压缩存储。 $\textcircled{4}$ 邻接矩阵表示法的空间复杂度为 $O(n^{2})$ ，其中 $n$ 为图的顶点数VI  

>#### pro：邻接矩阵的遍历的时间复杂度（2021）  

图的邻接矩阵存储表示法具有以下特点：  

$\textcircled{\scriptsize{1}}$ 无向图的邻接矩阵一定是一个对称矩阵（并且唯一）。因此，在实际存储邻接矩阵时只需存储上（或下）三角矩阵的元素。  

>#### pro：基于邻接矩阵的顶点的度的计算（2013、2021、2023）  

$\textcircled{2}$ 对于无向图，邻接矩阵的第i行（或第 $i$ 列）非零元素（或非 $\infty$ 元素）的个数正好是顶点i的度 $\mathrm{TD}(\nu_{i})$  

$\textcircled{3}$ 对于有向图，邻接矩阵的第 $i$ 行非零元素（或非 $\infty$ 元素）的个数正好是顶点i的出度 $\mathrm{{OD}}(v_{i})$ ；第 $i$ 列非零元素（或非 $\infty$ 元素）的个数正好是顶点 $i$ 的入度 $\mathrm{ID}(v_{i})$  

$\textcircled{4}$ 用邻接矩阵存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。  

$\circledast$ 稠密图（即边数较多的图）适合采用邻接矩阵的存储表示。  

>#### pro：》计算 $A^{2}$ 并说明A"[][/]的含义（2015）  

$\circledcirc$ 设图 $G$ 的邻接矩阵为 $_A$ ， $A^{n}$ 的元素A"[等于由顶点 $i$ 到顶点 $j$ 的长度为 $n$ 的路径的数目。该结论了解即可，证明方法可参考离散数学教材。  

# 6.2.2邻接表法  

当一个图为稀疏图时，使用邻接矩阵法显然会浪费大量的存储空间，而图的邻接表法结合了顺序存储和链式存储方法，大大减少了这种不必要的浪费。  

所谓邻接表，是指对图 $G$ 中的每个顶点 $\nu_{i}$ 建立一个单链表，第i个单链表中的结点表示依附于顶点 $\nu_{i}$ 的边（对于有向图则是以顶点 $v_{i}$ 为尾的弧），这个单链表就称为顶点 $\nu_{i}$ 的边表（对于有向图则称为出边表）。边表的头指针和顶点的数据信息采用顺序存储，称为顶点表，所以在邻接表中存在两种结点：顶点表结点和边表结点，如图6.6所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2ad0c70c97181ad46888d00bf7d1e1937cfcb142dda79077f20ff660fa09fa94.jpg)  
图6.6顶点表和边表结点结构  
顶点表结点由两个域组成：顶点域（data）存储顶点 $v_{i}$ 的相关信息，边表头指针域（firstarc）指向第一条边的边表结点。边表结点至少由两个域组成：邻接点域（adjvex）存储与头结点顶点  $v_{i}$  邻接的顶点编号，指针域（nextarc）指向下一条边的边表结点。  

>#### pro：图的邻接表存储的应用（2014）  

无向图和有向图的邻接表的实例分别如图6.7和图6.8所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3503c0ddc86c46b037cc84f917b3f4f690516b2cbec074113c67d50a2be472cf.jpg)  
图6.7无向图邻接表表示法实例  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/99831cb9adda79d80ce0087a8c64203ed478c2696ff7c44eddc97b0e34c61786.jpg)  
图6.8有向图邻接表表示法实例  

图的邻接表存储结构定义如下：  

#define Max Vertex Num 100/图中顶点数目的最大值typedef struct ArcNode{/边表结点int adjvex;/该弧所指向的顶点的位置struct ArcNode \*nextarc;/指向下一条弧的指针l/InfoType info; //网的边权值  

)ArcNode;  

typedef struct VNode{//顶点表结点Vertex Type data;//顶点信息ArcNode \*firstarc;/指向第一条依附该顶点的弧的指针  

)VNode,AdjList[Max Vertex Num];  

AdiList vertices;川/邻接表int vexnum,arcnum;/图的顶点数和弧数)ALGraph;I/ALGraph是以邻接表存储的图类型  

图的邻接表存储方法具有以下特点：  

$\textcircled{\scriptsize{1}}$  若  $G$  为无向图，则所需的存储空间为  $O(|V|+2|E|)$  ；若  $G$  为有向图，则所需的存储空间为  $O(|V|+|E|)$ 。前者的倍数2是因为在无向图中，每条边在邻接表中出现了两次。  

>#### pro：邻接矩阵法和邻接表法的适用性差异（2011）  

$\circledcirc$ 对于稀疏图（即边数较少的图），采用邻接表表示将极大地节省存储空间。  
$\textcircled{3}$ 在邻接表中，给定一个顶点，能很容易地找出它的所有邻边，因为只需要读取它的邻接表。在邻接矩阵中，相同的操作则需要扫描一行，花费的时间为 $O(n)$ 。但是，若要确定给定的两个顶点间是否存在边，则在邻接矩阵中可以立刻查到，而在邻接表中则需要在相应结点对应的边表中查找另一结点，效率较低。  

$\textcircled{4}$ 在无向图的邻接表中，求某个顶点的度只需计算其邻接表中的边表结点个数。在有向图的邻接表中，求某个顶点的出度只需计算其邻接表中的边表结点个数；但求某个顶点 $x$ 的入度则需遍历全部的邻接表，统计邻接点（adjvex）域为 $x$ 的边表结点个数。  

$\circledast$ 图的邻接表表示并不唯一，因为在每个顶点对应的边表中，各边结点的链接次序可以是任意的，它取决于建立邻接表的算法及边的输入次序。  

# 6.2.3十字链表  

十字链表是有向图的一种链式存储结构。在十字链表中，有向图的每条弧用一个结点（弧结点）来表示，每个顶点也用一个结点（顶点结点）来表示。两种结点的结构如下所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/74266ee7e563c116de5fb9a491b7ab8fe3ff5c963390bb5cd61fc774107b00af.jpg)  

弧结点中有5个域：tailvex和headvex两个域分别指示弧尾和弧头这两个顶点的编号；头链域hlink指向弧头相同的下一个弧结点；尾链域tlink指向弧尾相同的下一个弧结点；info域存放该弧的相关信息。这样，弧头相同的弧在同一个链表上，弧尾相同的弧也在同一个链表上。  

顶点结点中有3个域：data域存放该顶点的数据信息，如顶点名称；firstin域指向以该顶点为弧头的第一个弧结点；firstout域指向以该顶点为弧尾的第一个弧结点。  

图6.9为有向图的十字链表表示法。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/22cd3b3c3edea93d459339c492f17aca8da4b3af583a22feddb788230535e18b.jpg)  
图6.9有向图的十字链表表示（弧结点省略info域）  

注意，顶点结点之间是顺序存储的，弧结点省略了info域。  

在十字链表中，既容易找到 $V_{i}$ 为尾的弧，也容易找到 $V_{i}$ 为头的弧，因而容易求得顶点的出度和入度。图的十字链表表示是不唯一的，但一个十字链表表示唯一确定一个图。  

# 6.2.4邻接多重表  

邻接多重表是无向图的一种链式存储结构。在邻接表中，容易求得顶点和边的各种信息，但在邻接表中求两个顶点之间是否存在边而对边执行删除等操作时，需要分别在两个顶点的边表中遍历，效率较低。与十字链表类似，在邻接多重表中，每条边用一个结点表示，其结构如下所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ca384d2315602e299aa8d39ceb099e8698afb0d7699ccc8d0753379c1c14fd9d.jpg)  

其中，ivex和jvex这两个域指示该边依附的两个顶点的编号；ilink域指向下一条依附于顶点ivex的边；jlink域指向下一条依附于顶点jvex的边，info域存放该边的相关信息。  

每个顶点也用一个结点表示，它由如下所示的两个域组成。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6d2235b1c5b4ab153bc8da98b8ef339ac5118bd7a377aa55aa99addf45c45911.jpg)  

其中，data 域存放该顶点的相关信息，firstedge 域指向第一条依附于该顶点的边。  

在邻接多重表中，所有依附于同一顶点的边串联在同一链表中，因为每条边依附于两个顶点，所以每个边结点同时链接在两个链表中。对无向图而言，其邻接多重表和邻接表的差别仅在于，同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。  

图6.10为无向图的邻接多重表表示法。邻接多重表的各种基本操作的实现和邻接表类似。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/00d0a1988e38e61fac9ff788e80b20481d9c5be4523450b723ae3a32fba6dab2.jpg)  
图6.10无向图的邻接多重表表示（边结点省略info域）  

图的四种存储方式的总结如表6.1所示。  

表6.1图的四种存储方式的总结
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4c4a4bbdb4cf810f3765a867f779a8771cbd4a4349fecb05e02ba697baa3b451.jpg)  

# 6.2.5图的基本操作  

图的基本操作是独立于图的存储结构的。而对于不同的存储方式，操作算法的具体实现会有着不同的性能。在设计具体算法的实现时，应考虑采用何种存储方式的算法效率会更高。  

图的基本操作主要包括（仅抽象地考虑，所以忽略各变量的类型）：  

Adjacent $(G,\mathrm{x},\mathrm{y})$ ：判断图G是否存在边 ${\tt<x}$ y>或 $({\tt x},{\tt y})$ 。·Neighbors $(G,\mathrm{x})$ ：列出图G中与结点 $_\mathrm{x}$ 邻接的边。Insert Vertex  $(G,\mathrm{x})$  ：在图G中插入顶点  $_\mathrm{x}$  。 Delete Vertex  $(G,\mathrm{x})$  ：从图G中删除顶点  $_\mathrm{x}$  

·AddEdge $(\mathtt{G},\mathtt{x},\mathtt{y})$ ：若无向边 $(\mathtt{x},\mathtt{y})$ 或有向边 ${\tt<x}$ ,y>不存在，则向图G中添加该边。  
·RemoveEdge $(\mathtt{G},\mathtt{x},\mathtt{y})$ ：若无向边 $(\mathtt{x},\mathtt{y})$ 或有向边 ${\tt<x}$  $_\mathrm{y}{>}$ 存在，则从图G中册除该边。First Neighbor $(G,\mathrm{x})$ ：求图G中顶点 $_\mathrm{x}$ 的第一个邻接点，若有则返回顶点号。若 $_\mathrm{x}$ 没有邻接点或图中不存在 $_\mathrm{x}$ ，则返回-1。Next Neighbor $(G,\tt x,\tt y)$ ：假设图G中顶点是顶点 $\mathbf{\Deltar}$ 的一个邻接点，返回除外顶点x的下一个邻接点的顶点号，若y是 $_\mathrm{x}$ 的最后一个邻接点，则返回-1。  

Get edge value（G，x，y）：获取图G中边 $(\mathsf{x},\mathsf{y})$ 或 $\ll$  $_\mathrm{y}{>}$ 对应的权值Set edge value（G，x，y，v）：设置图G中边 $({\mathsf{x}}\,,{\mathsf{y}})$ 或 ${\tt C x}$ ，V>对应的权值为V。  

此外，还有图的遍历算法：按照某种方式访问图中的每个顶点且仅访问一次。图的遍历算法包括深度优先遍历和广度优先遍历，具体见下一节的内容。  


# 6.3图的遍历  

图的遍历是指从图中的某一顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次，且仅访问一次。注意到树是一种特殊的图，所以树的遍历实际上也可视为一种特殊的图的遍历。图的遍历算法是求解图的连通性问题、拓扑排序和求关键路径等算法的基础。  

图的遍历比树的遍历要复杂得多，因为图的任意一个顶点都可能和其余的顶点相邻接，所以在访问某个顶点后，可能沿着某条路径搜索又回到该顶点。为避免同一顶点被访问多次，在遍历图的过程中，必须记下每个已访问过的顶点，为此可以设一个辅助数组visited[门]来标记顶点是否被访问过。图的遍历算法主要有两种：广度优先搜索和深度优先搜索。  

# 6.3.1 广度优先搜索  

广度优先搜索（Breadth-First-Search，BFS）类似于二叉树的层序遍历算法。基本思想是：首 先访问起始顶点 $v$ ，接着由 $\nu$ 出发，依次访问v的各个未访问过的邻接顶点 $w_{1},\,w_{2},\cdots,\,w_{i}$ ，然后依次访问  $w_{1},$   $w_{2},\cdots$   $w_{i}$  的所有未被访问过的邻接顶点；再从这些访问过的顶点出发，访问它们所 有未被访问过的邻接顶点，直至图中所有顶点都被访问过为止。若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作为始点，重复上述过程，直至图中所有顶点都被访问到为止。Dijkstra单源最短路径算法和 $\operatorname{Prim}$ 最小生成树算法也应用了类似的思想。  

换句话说，广度优先搜索遍历图的过程是以v为起始点，由近至远依次访问和 $\nu$ 有路径相通且路径长度为12，的顶点。广度优先搜索是一种分层的查找过程，每向前走一步可能访问一批顶点，不像深度优先搜索那样有往回退的情况，因此它不是一个递归的算法。为了实现逐层的访问，算法必须借助一个辅助队列，以记忆正在访问的顶点的下一层顶点。  

广度优先搜索算法的伪代码如下：  

bool visited[MAX VERTEX NUM];//访问标记数组void BF S Traverse（Graph G){//对图G进行广度优先遍历for(  $\scriptstyle{\mathrm{~i}}=0$  ;i<G.vexnum;  ${++}\,{\mathrm{i}}$  visited[i] $=$ FALSE;//访问标记数组初始化InitQueue(Q); //初始化辅助队列Q for( $\scriptstyle{\dot{\mathbf{1}}}\,=\,0$ ;i<G.vexnum; ${++}\,{\mathrm{i}}$ //从0号顶点开始遍历if(!visited[i])//对每个连通分量调用一次BFS（）BFS(G,i);/诺 $v_{i}$ 未访问过，从v开始调用BFS（)  

用邻接表实现广度优先搜索的算法如下：  

void BFS（ALGraph G,int i){ //访问初始顶点ivisit（i); visited[i] $=$ TRUE;//对i做已访问标记EnQueue（Q,i);//顶点i入队while(!IsEmpty(Q)){ DeQueue(Q,v);/队首顶点v出队  
$w=\mathtt{p}->$  adjvex; if(visited  $[w]==$  FALSE){ visit（w); l/w为  $\triangledown$  的尚未访问的邻接点，访问w visited[w] $=$ TRUE;//对w做已访问标记EnQueue $(Q,w)$ ”//顶点 $\mathbf{w}$ 入队  

用邻接矩阵实现广度优先搜索的算法如下：  

void BFS（MGraph G,int i)(visit（i);//访问初始顶点ivisited[i]  $=$  TRUE; 对1做已访问标记 EnQueue（Q,i）;//顶点i入队while(!IsEmpty(Q)){ DeQueue(Q,v);/队首顶点v出队for $w\!=\!0$  $w\!<\!G$ .vexnum; $w++$ 1//检测 $\mathtt{v}$ 的所有邻接点if(visited  $[w]==$  FALSE&&G.edge[v][w]  $==1$  visit(w); /w为  $\mathbf{v}$  的尚未访问的邻接点，访问  $w$  visited[w]  $=$  TRUE; 1对  $w$  做已访问标记 EnQueue $(Q,w)$ //顶点 $\mathbf{w}$ 入队  

辅助数组visited[]标志顶点是否被访问过，其初始状态为FALSE。在图的遍历过程中，一旦某个顶点 $\nu_{i}$ 被访问，就立即置visited[i]为TRUE，防止它被多次访问。  

>#### pro：广度优先遍历的过程（2013）  

下面通过实例演示广度优先搜索的过程，给定图 $G$ 如图6.11所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/42543e3cbbf650ee51abdafe55648cf488f5a427608b8a1e32178060c28985aa.jpg)  
图6.11一个无向图 $G$  

假设从顶点 $a$ 开始访问， $a$ 先入队。此时队列非空，取出队头元素 $a$ ，因为 $^b$  $c$ 与 $a$ 邻接且未被访问过，于是依次访问 $b,\,c$ ，并将 $^b$  $c$ 依次入队。队列非空，取出队头元素 $^b$ ，依次访问与 $b$ 邻接且未被访问的顶点 $d,e$ ，并将 $d,e$ 入队（注意： $a$ 与 $^b$ 也邻接，但 $a$ 已置访问标记，所以不再重复访问）。此时队列非空，取出队头元素 $c$ ，访问与 $c$ 邻接且未被访问的顶点 $f,\,g$ ，并将 $f,g$ 入队。此时，取出队头元素 $d$ ，但与 $d$ 邻接且未被访问的顶点为空，所以不进行任何操作。继续取出队头元素 $e$ ，将 $h$ 入队列最终取出队头元素 $h$ 后，队列为空，从而循环自动跳出。遍历abcde f gh  

从上例不难看出，图的广度优先搜索的过程与二叉树的层序遍历是完全一致的，这也说明了图的广度优先搜索遍历算法是二叉树的层次遍历算法的扩展。  
# 1.BFS算法的性能分析  

无论是邻接表还是邻接矩阵的存储方式，BFS算法都需要借助一个辅助队列 $\mathcal{Q}$  $n$ 个顶点均需入队一次，在最坏的情况下，空间复杂度为 $O(|V|)$  

>#### pro：基于邻接表存储的BFS的效率（2012）  

遍历图的过程实质上是对每个顶点查找其邻接点的过程，耗费的时间取决于所采用的存储结 构。采用邻接表存储时，每个顶点均需搜索（或入队）一次，时间复杂度为 $O(|V|)$ ，在搜索每个顶点的邻接点时，每条边至少访问一次，时间复杂度为 $O(|E|)$ ，总的时间复杂度为 $O(|V|+|E|)$ 。采用邻接矩阵存储时，查找每个顶点的邻接点所需的时间为 $O(|V|)$ ，总时间复杂度为 $O(|V|^{2})$  

# 2.BFS算法求解单源最短路径问题  

若图 $G=(V,\,E)$ 为非带权图，定义从顶点 $u$ 到顶点 $v$ 的最短路径 $d(u,\,v)$ 为从 $u$ 到 $\nu$ 的任何路径中最少的边数；若从  $u$  到  $\nu$  没有通路，则  $d(u,v)=\infty$  6  

使用BFS，我们可以求解一个满足上述定义的非带权图的单源最短路径问题，这是由广度优先搜索总是按照距离由近到远来遍历图中每个顶点的性质决定的。  

BFS算法求解单源最短路径问题的算法如下：  

void BFS MIN Distance（Graph G,int u){ /ld[i]表示从u到i结点的最短路径 for(  $\scriptstyle{\dot{\mathbf{z}}}=0$  ;i<G.vexnum;  ${++i}$   ${\sf d}\left[\dot{\Sigma}\right]\!=\!\infty$ //初始化路径长度visited[u]  $=$  TRUE;d[u]  $=\!0$  EnQueue（Q,u）;while(!isEmpty(Q)){/BFS算法主过程DeQueue(Q,u);/队头元素u出队for  $w=$  First Neighbor(G,u);  $w\!>\!=\!0$   $w=$  Next Neighbor（G,u,w)) if(!visited[w]){//为u的尚未访问的邻接顶点visited[w]  $=$  TRUE; //设已访问标记 d[w]  $\scriptstyle=\operatorname{d}$  [u]  $^{+1}$  /路径长度加1 EnQueue(Q,w);/顶点w入队  

# 3.广度优先生成树  

在广度遍历的过程中，我们可以得到一棵遍历树，称为广度优先生成树，如图6.12所示。需要注意的是，同一个图的邻接矩阵存储表示是唯一的，所以其广度优先生成树也是唯一的，但因为邻接表存储表示不唯一，所以其广度优先生成树也是不唯一的。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a558e1e1aab5256ec092199096715091d9fd2bed801b23092ca6ae4ea150bdf2.jpg)  
图6.12图的广度优先生成树  
# 6.3.2 深度优先搜索  

与广度优先搜索不同，深度优先搜索（Depth-First-Search，DFS）类似于树的先序遍历。如其名称中所暗含的意思一样，这种搜索算法所遵循的策略是尽可能“深”地搜索一个图。  

它的基本思想如下：首先访问图中某一起始顶点 $v$ ，然后由 $v$ 出发，访问与 $v$ 邻接且未被访问的任意一个顶点 $w_{1}$ ，再访问与 $w_{1}$ 邻接且未被访问的任意一个顶点 $w_{2}$ …重复上述过程。当不能再继续向下访问时，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问过，则从该 点开始继续上述搜索过程，直至图中所有顶点均被访问过为止。  

一般情况下，其递归形式的算法十分简洁，算法过程如下：  

bool visited[MAX VERTEX NUM];/访问标记数组void DF S Traverse(Graph G){I/对图G进行深度优先遍历for  $\scriptstyle{\dot{\mathbf{1}}}\,=\,0$   $\scriptstyle{\dot{\mathbf{z}}}<G$  .vexnum;  $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$  visited[i] $=$ FALSE;//初始化已访问标记数组for $\scriptstyle{\dot{\mathbf{1}}}=0$  $\scriptstyle{\mathrm{~i}}<G$ .vexnum; $\dot{\mathbf{x}}_{++}$ 川本代码中是从 $v_{0}$ 开始遍历if(!visited[i])/对尚未访问的顶点调用DFS（）DFS(G,i);  

用邻接表实现深度优先搜索的算法如下：  

void DFS（ALGraph G,int i）{visit(i);/访问初始顶点ivisited[i]  $=$  TRUE; /对1做已访问标记 for $\scriptstyle{\mathfrak{p}}=G$ .vertices[i].firstarc;p; $\scriptstyle{\mathbb{P}}^{=}\mathbb{P}$ ->nextarc）（/检测i的所有邻接点j=p->adjvex; if（visited[j]  $==$  FALSE) DES(G,j）;为i的尚未访问的邻接点，递归访问  

用邻接矩阵实现深度优先搜索的算法如下：  

void DFS（MGraph G,int i）{visit（i);//访问初始顶点ivisited[i]  $=$  TRUE; /对1做已访问标记 for $(\stackrel{.}{\mathrm{j}}=\stackrel{0}{0}$ j<G.vexnum; $\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\$ //检测i的所有邻接点if(visited[j]  $==$  FALSE&&G.edge[i][j]  $==1$  DFS(G,j);j为i的尚未访问的邻接点，递归访问  

>#### pro：深度优先遍历的过程（2015、2016）  

以图6.11的无向图为例，深度优先搜索的过程：首先访问 $a$ ，并置 $a$ 访问标记：然后访问与 $a$ 邻接且未被访问的顶点 $b$ ，置 $^b$ 访问标记：然后访问与 $^b$ 邻接且未被访问的顶点 $d$ ，置 $d$ 访问标记。此时 $d$ 已没有未被访问过的邻接点，所以返回上一个访问的顶点 $^b$ ，访问与其邻接且未被访问的顶点 $e$ ，置 $e$ 访问标记，以此类推，直至图中所有顶点都被访问一次。遍历结果为abdehcfg。  

# 注意  

图的邻接矩阵表示是唯一的，但对邻接表来说，若边的输入次序不同，则生成的邻接表也不同。因此，对同样一个图，基于邻接矩阵的遍历得到的DFS序列和BFS序列是唯一的，基于邻接表的遍历得到的DFS序列和BFS序列是不唯一的。  
1.DFS算法的性能分析  

DFS算法是一个递归算法，需要借助一个递归工作栈，所以其空间复杂度为 $O(|V|)$  

遍历图的过程实质上是通过边查找邻接点的过程，因此两种遍历方式的时间复杂度都相同，不同之处仅在于对顶点访问顺序的不同。采用邻接矩阵存储时，总时间复杂度为 $O(|V|^{2})$ 采用邻接表存储时，总的时间复杂度为 $O(|V|+|E|)$  

# 2.深度优先的生成树和生成森林  

与广度优先搜索一样，深度优先搜索也会产生一棵深度优先生成树。当然，这是有条件的，即对连通图调用DFS才能产生深度优先生成树，否则产生的将是深度优先生成森林，如图6.13所示。与BFS类似，基于邻接表存储的深度优先生成树是不唯一的。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/80ef10fc4c40d90faf1f0f3f8503446a41b03c6ef2278ea05623bcbf8a932ea2.jpg)  
图6.13图的深度优先生成森林  

# 6.3.3图的遍历与图的连通性  

图的遍历算法可以用来判断图的连通性。对于无向图来说，若无向图是连通的，则从任意一个结点出发，仅需一次遍历就能够访问图中的所有顶点；若无向图是非连通的，则从某一个顶点出发，一次遍历只能访问到该顶点所在连通分量的所有顶点，而对于图中其他连通分量的顶点，则无法通过这次遍历访问。对于有向图来说，若从初始顶点到图中的每个顶点都有路径，则能够访问到图中的所有顶点，否则不能访问到所有顶点。  

因此，在BFSTraverse（)或DFSTraverse（）中添加了第二个for循环，再选取初始点，继续进行遍历，以防止一次无法遍历图的所有顶点。对于无向图，上述两个函数调用BFS(G，i)或DFS（G，i）的次数等于该图的连通分量数；而对于有向图则不是这样，因为一个连通的有向图分为强连通的和非强连通的，它的连通子图也分为强连通分量和非强连通分量，非强连通分量一次调用BFS（G，i)或DFS（G，i)无法访问到该连通分量的所有顶点，如图6.14所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/823fee21850cd372fbc2f6401fff35ce59784df00323e94b4176edf7aeec0711.jpg)  
图6.14有向图的非强连通分量  



# 6.4图的应用  

本节是历年考查的重点。图的应用主要包括：最小生成（代价）树、最短路径、拓扑排序和关键路径。一般而言，这部分内容直接以算法设计题形式考查的可能性极小，而更多的是结合图的实例来考查算法的具体操作过程，读者必须学会手工模拟给定图的各个算法的执行过程。此外，还需掌握对给定模型建立相应的图去解决问题的方法。  

# 6.4.1 最小生成树  

一个连通图的生成树包含图的所有顶点，并且只含尽可能少的边。对于生成树来说，若砍去它的一条边，则会使生成树变成非连通图；若给它增加一条边，则会形成图中的一条回路。  

对于一个带权连通无向图 $G$ ，生成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同。权值之和最小的那棵生成树称为 $G$ 的最小生成树（Minimum-Spanning-Tree,MST）。  

>#### pro：最小生成树的性质（2012、2017）  

不难看出，最小生成树具有如下性质  

1）若图 $G$ 中存在权值相同的边，则 $G$ 的最小生成树可能不唯一，即最小生成树的树形不唯一。当图 $G$ 中的各边权值互不相等时， $G$ 的最小生成树是唯一的：若无向连通图G的边数比顶点数少1，即 $G$ 本身是一棵树时，则 $G$ 的最小生成树就是它本身。  

2）虽然最小生成树不唯一，但其对应的边的权值之和总是唯一的，而且是最小的。  
3）最小生成树的边数为顶点数减1。  

命题追踪最小生成树中某顶点到其他顶点是否具有最短路径的分析（2023）  

# 注意  

最小生成树中所有边的权值之和最小，但不能保证任意两个顶点之间的路径是最短路径。如下图所示，最小生成树中A到C的路径长度为5，但原图中C到D的最短路径长度为4。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/02e492777fdd70471f99a72a7ca8d6237b0cbdc152f003539de53616c1664f55.jpg)  

构造最小生成树有多种算法，但大多数算法都利用了最小生成树的下列性质：假设 $G=(V,E)$ 是一个带权连通无向图， $U$ 是顶点集 $V$ 的一个非空子集。若 $(u,\,v)$ 是一条具有最小权值的边，其中 $u{\in}U$  $v{\in}V{-}\,U$ ，则必存在一棵包含边 $(u,v)$ 的最小生成树。  

基于该性质的最小生成树算法主要有 $\operatorname{Prim}$ 算法和Kruskal算法，它们都基于贪心算法的策略。对这两种算法应主要掌握算法的本质含义和基本思想，并能够手工模拟算法的实现步骤。  

下面介绍一个通用的最小生成树算法：  

GENERICMST(G)( $\scriptstyle{\mathrm{T}}=$  NULL; whileT未形成一棵生成树；do找到一条最小代价边 $(\boldsymbol{\mathrm{u}},\boldsymbol{\mathrm{v}})$ 并且加入T后不会产生回路 $\scriptstyle{\mathrm{T}=\mathrm{T}\cup\left(\mathrm{u},\,\mathrm{v}\right)}$  ”  

通用算法每次加入一条边以逐渐形成一棵生成树，下面介绍两种实现上述通用算法的途径。  

1.Prim算法  

Prim（普里姆）算法的执行非常类似于寻找图的最短路径的Dijkstra算法（见下一节）。  

命题追踪Prim算法构造最小生成树的实例（2015、2017、2018）  

Prim算法构造最小生成树的过程如图6.15所示。初始时从图中任取一顶点（如顶点1）加 入树 $T$ ，此时树中只含有一个顶点，之后选择一个与当前 $T$ 中顶点集合距离最近的顶点，并将该顶点和相应的边加入 $T$ ，每次操作后 $T$ 中的顶点数和边数都增1。以此类推，直至图中所有的顶点都并入 $T$ ，得到的 $T$ 就是最小生成树。此时 $T$ 中必然有 $n\!-\!1$ 条边。  

Prim算法的步骤如下：  

假设 $G=\{V,E\}$ 是连通图，其最小生成树 $T\!=\!(U,E_{T})$ ， $E_{T}$ 是最小生成树中边的集合。  

初始化：向空树 $T\!=\!(U,E_{T})$ 中添加图 $G=(V,E)$ 的任意一个顶点 $u_{0}$ ，使 $U=\{u_{0}\}$ ， $E_{T}\!=\!\emptyset$  

循环（重复下列操作直至 $U=V)$ ：从图 $G$ 中选择满足 $\{(u,\,v)|u{\in}U,\,v{\in}V{-}\,U\}$ 且具有最小权值的边 $(u,v)$ ，加入树 $T$ 置 $U\!=\!U\!\cup\{\nu\},\:\:E_{T}\!=\!E_{T}\!\cup\{(u,\nu)\}$  

Prim算法的简单实现如下：  

void Prim（G,T） $\scriptstyle{\mathrm{T}}=\varnothing$  /初始化空树  $\scriptstyle{\mathrm{U}=\{w\}}$ /添加任意一个顶点 $w$ while((V-U) $!\!=\!\!\bigcirc\!,$ //若树中不含全部顶点  
设 $(\boldsymbol{\mathrm{u}},\boldsymbol{\mathrm{v}})$ 是使ueU与 $\forall{\in}\left(\mathrm{V}{-}\mathrm{U}\right)$ ，且权值最小的边； $\scriptstyle{\mathbb{T}=\mathbb{T}\cup\{\ (\mathfrak{u},\mathfrak{v})\ \}}$  /边归入树  $\scriptstyle{\mathrm{U}=\mathrm{U}\cup\{\mathrm{v}\}}$  //顶点归入树  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/413704bf3253c2671855c3395ee5f1027e23761bf8da66bca7df35e4ef0ebc82.jpg)  
图6.15Prim算法构造最小生成树的过程  

Prim算法的时间复杂度为 $O(|V|^{2})$ ，不依赖于 $\cdot|E|$ ，因此它适用于求解边稠密的图的最小生成树。虽然采用其他方法能改进 $\operatorname{Prim}$ 算法的时间复杂度，但增加了实现的复杂性。  

# 2.Kruskal算法  

与 $\operatorname{Prim}$ 算法从顶点开始扩展最小生成树不同，Kruskal算法是一种按权值的递增次序选择合适的边来构造最小生成树的方法。  

>#### pro：Kruskal算法构造最小生成树的实例（2015、2018、2020）  

Kruskal算法构造最小生成树的过程如图6.16所示。初始时为只有  $n$  个顶点而无边的非连 通图 $T=\{V,\,\{\}\}$ ，每个顶点自成一个连通分量。然后按照边的权值由小到大的顺序，不断选取当前未被选取过且权值最小的边，若该边依附的顶点落在 $T$ 中不同的连通分量上（使用并查集判断这两个顶点是否属于同一棵集合树），则将此边加入T，杏则舍弃此边而选择下一条权值最小的边。以此类推，直至 $T$ 中所有顶点都在一个连通分量上。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/dfb9edf9b314446b65731e53e39a987ef76f3a653992a0d176bd51f77fe01337.jpg)  
图6.16Kruskal算法构造最小生成树的过程  
Kruskal算法的步骤如下：  

假设 $G=(V,E)$ 是连通图，其最小生成树 $T\!=\!(U,E_{T})$  

初始化： $\begin{array}{r}{U\!=\!V,E_{T}\!=\!\emptyset_{\circ}}\end{array}$ ，即每个顶点构成一棵独立的树， $T$ 此时是一个仅含IV个顶点的森林。  

循环（重复直至 $T$ 是一棵树)：按 $G$ 的边的权值递增顺序依次从 $E\!-\!E_{T}$ 中选择一条边，若这条边加入 $T$ 后不构成回路，则将其加入 $E_{T}$ ，否则舍弃，直到 $E_{T}$ 中含有 $n-1$ 条边。  

Kruskal算法的简单实现如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2b5891ebe5b470c06be5813e03e210a476a10eb80e5ae811e0df366ecf210561.jpg)  

根据图的相关性质，若一条边连接了两棵不同树中的顶点，则对这两棵树来说，它必定是连通的，将这条边加入森林中，完成两棵树的合并，直到整个森林合并成一棵树。  

在Kruskal算法中，最坏情况需要对 $|E|$ 条边各扫描一次。通常采用堆（见第7章）来存放边的集合，每次选择最小权值的边需要 $O(\log_{2}\lvert E\rvert)$ 的时间；每次使用并查集来快速判断两个顶点是否属于一个集合所需的时间为 $O(\alpha(|V|))$ ， $\alpha(V)$ 的增长极其缓慢，可视为常数。算法的总时间复杂度为 $O(|E|\log_{2}\lvert E\rvert)$ ，不依赖于 $|V|$ ，因此Kruskal算法适合于边稀疏而顶点较多的图。  

# 6.4.2最短路径  

>#### pro：最短路径的分析与举例以及相关的算法（2009、2023）  

6.3节所述的广度优先搜索查找最短路径只是对无权图而言的。当图是带权图时，把从一个顶点 $v_{0}$ 到图中其余任意一个顶点 $\nu_{i}$ 的一条路径所经过边上的权值之和，定义为该路径的带权路径长度，把带权路径长度最短的那条路径（可能不止一条）称为最短路径。  

求解最短路径的算法通常都依赖于一种性质，即两点之间的最短路径也包含了路径上其他顶点间的最短路径。带权有向图G的最短路径问题一般可分为两类：一是单源最短路径，即求图中某一顶点到其他各顶点的最短路径，可通过经典的Dijkstra（迪杰斯特拉）算法求解；二是求每对顶点间的最短路径，可通过Floyd（弗洛伊德）算法来求解。  

# 1.Dijkstra算法求单源最短路径问题  

Dijkstra $S$ 记录已求得的最短路径的顶点，初始时把源点 $\nu_{0}$ 放入 $S$ ，集合 $S$ 每并入一个新顶点 $\nu_{i}$ ，都要修改源点 $v_{0}$ 到集合 $V\!-\!S$ 中顶点当前的最短路径长度值（这里可能不太好理解？没关系，继续往下看，相信会逐步理解）。  

在构造的过程中还设置了三个辅助数组：  

·final[]：标记各顶点是否已找到最短路径，即是否归入集合 $S_{\circ}$ ·dist[]：记录从源点 $v_{0}$ 到其他各顶点当前的最短路径长度，它的初始值为：若从 $v_{0}$ 到 $v_{i}$ 有弧，则dist[i]为弧上的权值；否则置dist[i]为oo。path[]：path[i]表示从源点到顶点 $i$ 之间的最短路径的前驱结点。在算法结束时，可根据其值追溯得到源点 $\nu_{0}$ 到顶点 $v_{i}$ 的最短路径。  
假设从顶点0出发，即 $v_{0}\,{=}\,0$ ，集合 $S$ 最初只包含顶点O，邻接矩阵arcs表示带权有向图，arcs[i][j]表示有向边 ${<\!i,j\!>}$ 的权值，若不存在有向边 $\mid<\!i,j>$ ，则arcs[i][j]为o。  

Dijkstra算法的步骤如下（不考虑对path[的操作）：  

1）初始化：集合 $S$ 初始为 $\{0\}$ ，dist[]的初始值dist[i] $=$ arcs[0][i],i=1,2,.,n-1。2）从顶点集合  $V{-}S$  中选出  $v_{j}$  ，满足dist[j]  $=$  Min(dist[i]l  $\scriptstyle v_{i}\in V-S\}$   $\nu_{j}$  就是当前求得 的一条从 $\nu_{0}$ 出发的最短路径的终点，令 $S\!=\!S\cup\{j\}$ 。3）修改从 $v_{0}$ 出发到集合 $V\!-\!S$ 上任意一个顶点 $v_{k}$ 可达的最短路径长度：若dist[j]+arcs[j][k]  $<$  dist[k]，则更新dist[k]  $=$  dist[j]  $^+$  arcs[j][k]。  

4）重复 $2)\sim\!3)$ 操作共 $_{n-1}$ 次，直到所有的顶点都包含在集合 $S$ 中  

步骤3）也就是开头留下的疑问，每当一个顶点加入集合 $S$ 后，可能需要修改源点 $\nu_{0}$ 到集合 $V{-}S$ 中可达顶点当前的最短路径长度，下面举一简单例子证明。如下图所示，源点为 $v_{0}$ ，初始时 $S=\{v_{0}\}$ ，dist $[1]\!=\!3$ ,dist $[2]=7$ ，当将 $\nu_{1}$ 并入集合 $S$ 后，dist[2]需要更新为4。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d8cd3f126d0f9f02af5404cbc8a5301d32f89543ad84684ca594dafd871d7647.jpg)  

思考：Dijkstra  $\operatorname{Prim}$  算法有何异同之处？ 命题追踪Dijkstra算法求解最短路径的实例（2012、2014、2016、2021）  

例如，对图6.17中的图应用Dijkstra算法求从顶点1出发至其余顶点的最短路径的过程，如表6.2所示。算法执行过程的说明如下。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c7090950bb73763feef7e1ea4c3e3ea318d642815621a4657605a0e98585dbdc.jpg)  
图6.17应用Dijkstra算法图  

表6.2从 $\nu_{1}$ 到各终点的dist值和最短路径的求解过程
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9f8939ca7029cd3a8d7e5c73314b7488664116e02a550898bfbcd99d295b6878.jpg)  
初始化：集合 $S$ 初始为 $\{v_{1}\}$ ， $v_{1}$ 可达 $v_{2}$ 和 $v_{5}$  $v_{1}$ 不可达 $\nu_{3}$ 和 $v_{4}$ ，因此dist[]数组各元素的初始值依次设置为dist  $[2]\!=\!10$  ，dist  $\left[\,3\,\right]\mathrm{=}\infty$  , dist  $\left[\,4\,\right]\mathrm{=}\infty$  ,dist  $[\,5\,]\!=\!5$  

第1轮：选出最小值dist[5]，将顶点 $v_{5}$ 并入集合 $S$ ，即此时已找到 $\nu_{1}$ 到 $v_{5}$ 的最短路径。当 $v_{5}$ 加入 $S$ 后，从 $\nu_{1}$ 到集合 $V\!-\!S$ 中可达顶点的最短路径长度可能会产生变化。因此需要更新dist[]数组。 $v_{5}$ 可达 $\nu_{2}$ ，因 $v_{1}{\rightarrow}v_{5}{\rightarrow}v_{2}$ 的距离8比dist $[2]\!=\!10$ 小，更新 dist $[2]\!=\!8$  $v_{5}$ 可达 $v_{3}$ ， $v_{1}{\rightarrow}v_{5}{\rightarrow}v_{3}$ 的距离14，更新dist $[3]\!=\!14$ .. $v_{5}$ 可达 $v_{4}$  $v_{1}{\rightarrow}v_{5}{\rightarrow}v_{4}$ 的距离7，更新dist $[\,4\,]\,{=}7$ 。  

第2轮：选出最小值dist[4]，将顶点 $v_{4}$ 并入集合 $S_{\circ}$ 继续更新dist[]数组。 $v_{4}$ 不可达 $v_{2}$ ，dist[2]不变； $v_{4}$ 可达 $v_{3}$  $v_{1}{\rightarrow}v_{5}{\rightarrow}v_{4}{\rightarrow}v_{3}$ 的距离13比dist[3]小，故更新dist[3]=13。  

第3轮：选出最小值dist[2]，将顶点 $v_{2}$ 并入集合 $S_{\circ}$ 继续更新 dist[]数组。 $v_{2}$ 可达 $\nu_{3}$  $v_{1}{\rightarrow}v_{5}{\rightarrow}v_{2}{\rightarrow}v_{3}$ 的距离9比dist[3]小，更新dist $\left[\,3\,\right]\,=\,9.$  

第4轮：选出唯一最小值dist[3]，将顶点 $v_{3}$ 并入集合 $S_{i}$ ，此时全部顶点都已包含在 $S$ 中。  

显然，Dijkstra算法也是基于贪心策略的。  

使用邻接矩阵表示时，时间复杂度为 $O(|V|^{2})$ 。使用带权的邻接表表示时，虽然修改dist[]的时间可以减少，但由于在dist[中选择最小分量的时间不变，所以时间复杂度仍为 $O(|V|^{2})$  

人们可能只希望找到从源点到某个特定顶点的最短路径，但这个问题和求解源点到其他所有顶点的最短路径一样复杂，时间复杂度也为 $O(|V|^{2})$  

注意，边上带有负权值时，Dikstra算法并不适用。若充许边上带有负权值，则在与集合S（已求得最短路径的顶点集，归入 $S$ 内的顶点的最短路径不再变更）内某顶点（记为 $a$ ）以负边相连的顶点（记为6）确定其最短路径时，其最短路径长度加上这条负边的权值结果可能小于 $a$ 原先确定的最短路径长度，而此时 $a$ 在Dijkstra算法下是无法更新的。例如，对于图6.18所示的带权有向图，利用Dijkstra算法不一定能得到正确的结果。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/354061dd6653c1cf7d28647835680430baf780d8a8c6da4925a50828c972315d.jpg)  
图6.18边上带有负权值的有向带权图  

# 2.Floyd算法求各顶点之间最短路径问题  

求所有顶点之间的最短路径问题描述如下：已知一个各边权值均大于0的带权有向图，对任意两个顶点 $v_{i}\not=v_{j}$ ，要求求出 $\nu_{i}$ 与 $v_{j}$ 之间的最短路径和最短路径长度。  

Floyd算法的基本思想是：递推产生一个 $n$ 阶方阵序列 $A^{(-1)}$  $A^{(0)},\cdots,\,A^{(k)},\cdots,\,A^{(n-1)}$ ，其中 $A^{(k)}[i][j]$ 表示从顶点 $v_{i}$ 到顶点 $v_{j}$ 的路径长度， $k$ 表示绕行第 $k$ 个顶点的运算步骤。初始时，对于任意两个顶点 $v_{j}$ 和 $v_{j}$ ，若它们之间存在边，则以此边上的权值作为它们之间的最短路径长度；若它们之间不存在有向边，则以作为它们之间的最短路径长度。以后逐步尝试在原路径中加入顶点 $k$  $\textit{k}(k=0,\,1,\cdots,n-1\,)$ 作为中间顶点。若增加中间顶点后，得到的路径比原来的路径长度减少了，则以此新路径代替原路径。算法描述如下：  

定义一个 $n$ 阶方阵序列 $A^{(-1)},A^{(0)},\cdots,A^{(n-1)}$ ，其中，  

$$
A^{(-1)}[i][j]=\arcsin[i][j]
$$  

$$
\begin{array}{r}{A^{(k)}[i][j]=\operatorname{Min}\{A^{(k-1)}[i][j],\quad A^{(k-1)}[i][k]+A^{(k-1)}[k][j]\},\ k=0,1,\cdots,n-1}\end{array}
$$  

式中， $A^{(0)}[i][j]$ 是从顶点 $v_{i}$ 到 $\nu_{j\setminus}$ 中间顶点是 $\nu_{0}$ 的最短路径的长度， $A^{(k)}[i][j]$ 是从顶点 $\nu_{i}$ 到 $v_{j\setminus}$ 中间顶点的序号不大于 $k$ 的最短路径的长度。Floyd算法是一个迭代的过程，每迭代一次，在从 $\nu_{i}$ 到 $\nu_{j}$ 的最短路径上就多考虑了一个顶点；经过 $n$ 次迭代后，所得到的 $A^{(n-1)}[i][j]$ 就是 $v_{i}$ 到 $\nu_{j}$ 的最短路径长度，即方阵 $A^{(n-1)}$ 中就保存了任意一对顶点之间的最短路径长度。  
图6.19所示为带权有向图 $G$ 及其邻接矩阵。应用Floyd算法求所有顶点之间的最短路径长度的过程如表6.3所示。算法执行过程的说明如下。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9563eb9adc4d1c1bbd123557953338f0013fcf037d3a58a2bb15403ac38ae2a2.jpg)  
图6.19带权有向图 $G$ 及其邻接矩阵  

初始化：方阵 $A^{(-1)}[i][j]=$ arcs[][]  

第1轮：将 $v_{0}$ 作为中间顶点，对于所有顶点对 $\{i,j\}$ ，若有 $\boldsymbol{A}^{-1}[i][j]>\boldsymbol{A}^{-1}[i][0]+\boldsymbol{A}^{-1}[0][j]$ ，则将 $A^{-1}[i][j]$  更新为  $\begin{array}{r}{\boldsymbol{A}^{-1}[i][0]+\boldsymbol{A}^{-1}[0][j].}\end{array}$  有  $\begin{array}{r}{\boldsymbol{A}^{-1}[2][1]>\boldsymbol{A}^{-1}[2][0]+\boldsymbol{A}^{-1}[0][1]=11}\end{array}$  ，更新  $A^{-1}[2][1]=11$  ，更 新后的方阵标记为 $A^{0}$  

第2轮：将 $\nu_{1}$ 作为中间顶点，继续检测全部顶点对 $\{i,j\}$ 。有 $A^{0}[0][2]>A^{0}[0][1]+A^{0}[1][2]=$ 10，更新 $A^{0}[0][2]=10$ ，更新后的方阵标记为 $A^{1}$  

第3轮：将 $\nu_{2}$ 作为中间顶点，继续检测全部顶点对i,}。有 $\begin{array}{r}{\boldsymbol{A}^{1}[1][0]>\boldsymbol{A}^{1}[1][2]+\boldsymbol{A}^{1}[2][0]=\boldsymbol{9},}\end{array}$ 更新 $A^{1}[1][0]=9$ ，更新后的方阵标记为 $A^{2}$ 。此时 $A^{2}$ 中保存的就是任意顶点对的最短路径长度。  

表6.3Floyd算法的执行过程
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/91b9d670ed390741ce41fa7fada27f7a43fe887b80c64666880ba9353d11e80f.jpg)  

Floyd算法的时间复杂度为 $O(|V|^{3})$ 。不过由于其代码很紧凑，且并不包含其他复杂的数据结构，因此隐含的常数系数是很小的，即使对于中等规模的输入来说，它仍然是相当有效的。  

Floyd算法允许图中有带负权值的边，但不允许有包含带负权值的边组成的回路。Floyd算法同样适用于带权无向图，因为带权无向图可视为权值相同往返二重边的有向图。  

也可以用单源最短路径算法来解决每对顶点之间的最短路径问题。轮流将每个顶点作为源点，并且在所有边权值均非负时，运行一次Dijkstra算法，其时间复杂度为 $O(|V|^{2}){\cdot}|V|\!=\!O(|V|^{3})$  

BFS算法、Dijkstra算法和Floyd算法求最短路径的总结如表6.4所示。  

表6.4BFS算法、Dijkstra算法和Floyd算法求最短路径的总结 
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7c367d52e0336cc1a989ce844941cf5beff18d63452f540edc3163d0104266fc.jpg)  
6.4.3有向无环图描述表达式  

有向无环图：若一个有向图中不存在环，则称为有向无环图，简称DAG图。  

命题追踪构建表达式的有向无环图（2019）  

有向无环图是描述含有公共子式的表达式的有效工具。例如表达式 $((a+b)^{*}(b^{*}(c+d))+(c+d)^{*}e)^{*}((c+d)^{*}e)$  

可以用上一章描述的二义树来表示，如图6.20所示。仔细观察该表达式，可发现有一些相同的子表达式 $(c+d$ )和 $(c+d)^{*}e$ ，而在二叉树中，它们也重复出现。若利用有向无环图，则可实现对相同子式的共享，从而节省存储空间，图6.21所示为该表达式的有向无环图表示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7e1ae982871a34fb5119dda6581088409768da4bd88e8d177af012108a5f7ae4.jpg)  
图6.20二叉树描述表达式  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e4c2332ba4acd478e43e4a2865dff8a8e7911989ffb9daa949ca81a074232194.jpg)  
图6.21有向无环图描述表达式  

# 注意  

在表达式的有向无环图表示中，不可能出现重复的操作数顶点。  

# 6.4.4 拓扑排序  

AOV网：若用有向无环图表示一个工程，其顶点表示活动，用有向边 $\begin{array}{r}{{<}V_{i},}\end{array}$  $V_{j}>$ 表示活动 $V_{i}$ 必须先于活动 $V_{j}$ 进行的这样一种关系，则将这种有向图称为顶点表示活动的网络，简称AOV网。在AOV网中，活动 $V_{i}$ 是活动 $V_{j}$ 的直接前驱， $V_{j}$ 是 $V_{i}$ 的直接后继，这种前驱和后继关系具有传递性，且任何活动 $V_{i}$ 不能以它自己作为自己的前驱或后继。  

拓扑排序：在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序：  

1）每个顶点出现且只出现一次。  

2）若顶点A在序列中排在顶点 $B$ 的前面，则在图中不存在从 $B$ 到 $A$ 的路径。  

或定义为：拓扑排序是对有向无环图的顶点的一种排序，它使得若存在一条从顶点A到顶点 $B$ 的路径，则在排序中 $B$ 出现在 $A$ 的后面。每个AOV网都有一个或多个拓扑排序序列。  

>#### pro：拓扑排序和回路的关系（2011）  

对一个AOV网进行拓扑排序的算法有很多，下面介绍比较常用的一种方法的步骤 $\textcircled{\scriptsize{1}}$ 从AOV网中选择一个没有前驱（入度为0）的顶点并输出。 $\circledcirc$ 从网中删除该顶点和所有以它为起点的有向边。  

$\textcircled{3}$ 重复 $\circledcirc$ 和 $^{(\mathcal{Q})}$ 直到当前的AOV网为空或当前网中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。  
命题追踪拓扑排序的实例（2010、2014、2018、2021）  

图6.22所示为拓扑排序过程的示例。每轮选择一个入度为0的顶点并输出，然后删除该顶点和所有以它为起点的有向边，最后得到拓扑排序的结果为 $\{1,2,4,3,5\}$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8810ace9ff20c9670d0e1272ddf371bd248455d387e1a48022dfcfc7f025d42a.jpg)  
图6.22有向无环图的拓扑排序过程  

拓扑排序算法的实现如下：  

o ol Topological Sort(Graph G){ InitStack(S);/初始化栈，存储入度为0的顶点int i; for(  $\scriptstyle{\dot{\mathbf{1}}}=0$  ;i<G.vexnum;  $\ \ \dot{\mathbf{1}}_{++}$  if（indegree[i] $==0$ 一Push(S,i); //将所有入度为0的顶点进栈 int count $=\!0$ //计数，记录当前已经输出的顶点数while(!IsEmpty(S)){//栈不空，则存在入度为0的顶点Pop(S,i); /栈顶元素出栈 print[count ${\bf++}]\!=\!\mathrm{i}$ /输出顶点for  $\scriptstyle{\mathrm{sp}}=G$  .vertices[i].firstarc;p;p=p->nextarc)( //将所有i指向的顶点的入度减1，并且将入度减为0的顶点压入栈S $\scriptstyle{\mathrm{~v=p~}}$  ->adjvex; if(!(--indegree[v]))Push(S,v); 11入度为0，则入栈 if（count<G.vexnum)returnfalse;/排序失败，有向图中有回路else return true; /拓扑排序成功  
>#### pro：不同存储方式下的拓扑排序的效率（2016）  

因为输出每个顶点的同时还要删除以它为起点的边，所以采用邻接表存储时拓扑排序的时间复杂度为 $O(|V|+|E|)$ ，采用邻接矩阵存储时拓扑排序的时间复杂度为 $O(|V|^{2})$  

>#### pro：》DFS实现拓扑排序的思想（2020）  

此外，利用上一节的深度优先遍历也可以实现拓扑排序，下面简单描述其思路，具体代码见本节后的习题。对于有向无环图 $G$ 中的任意结点 $u,v$ ，它们之间的关系必然是下列三种之一：  

1）若  $u$  是  $\nu$  的祖先，则在调用DFS访问  $u$  之前，必然已对  $v$  进行了DFS访问，即v的DFS 结束时间先于 $u$ 的DFS结束时间。从而可考虑在DFS函数中设置一个时间标记，在DFS调用结束时，对各顶点计时。因此，祖先的结束时间必然大于子孙的结束时间。  

2）若 $u$ 是 $v$ 的子孙，则v为 $u$ 的祖先，按上述思路，v的结束时间大于 $u$ 的结束时间。  

3）若 $u$ 和 $v$ 没有路径关系，则 $u$ 和 $\nu$ 在拓扑序列的关系任意。  

于是，按结束时间从大到小排列，就可以得到一个拓扑排序序列。  

对一个AOV网，若采用下列步骤进行排序，则称之为逆拓扑排序：  

$\textcircled{\scriptsize{1}}$ 从AOV网中选择一个没有后继（出度为0）的顶点并输出。  

$\textcircled{2}$ 从网中删除该顶点和所有以它为终点的有向边。  

$\textcircled{3}$ 重复 $\textcircled{\scriptsize{1}}$ 和 $\textcircled{2}$ 直到当前的AOV网为空。  

用拓扑排序算法处理AOV网时，应注意以下问题：  

1）入度为零的顶点，即没有前驱活动的或前驱活动都已经完成的顶点，工程可以从这个顶点所代表的活动开始或继续。  

>#### pro：分析给定图的拓扑序列的存在性和唯一性（2011）  

2）若一个顶点有多个直接后继，则拓扑排序的结果通常不唯一；但若各个顶点已经排在一个线性有序的序列中，每个顶点有唯一的前驱后继关系，则拓扑排序的结果是唯一的。  

3）由于AOV网中各顶点的地位平等，每个顶点编号是人为的，因此可以按拓扑排序的结果重新编号，生成AOV网的新的邻接存储矩阵，这种邻接矩阵可以是三角矩阵；但对于一般的图来说，若其邻接矩阵是三角矩阵，则存在拓扑序列；反之则不一定成立。  

# 6.4.5关键路径  

在带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销（如完成活动所需的时间），称之为用边表示活动的网络，简称AOE网。AOE网和AOV网都是有向无环图，不同之处在于它们的边和顶点所代表的含义是不同的，AOE网中的边有权值；而AOV网中的边无权值，仅表示顶点之间的前后关系。  

AOE网具有以下两个性质：  

$\textcircled{\scriptsize{1}}$ 只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始； $\circledcirc$ 只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。  

在AOE网中仅有一个入度为0的顶点，称为开始顶点（源点），它表示整个工程的开始；也仅有一个出度为0的顶点，称为结束顶点（汇点），它表示整个工程的结束。  

>#### pro：关键路径的性质（2020）  

在AOE网中，有些活动是可以并行进行的。从源点到汇点的有向路径可能有多条，并且这些路径长度可能不同。完成不同路径上的活动所需的时间虽然不同，但是只有所有路径上的活动都已完成，整个工程才能算结束。因此，从源点到汇点的所有路径中，具有最大路径长度的路径称为关键路径，而把关键路径上的活动称为关键活动。  
完成整个工程的最短时间就是关键路径的长度，即关键路径上各活动花费开销的总和。这是因为关键活动影响了整个工程的时间，即若关键活动不能按时完成，则整个工程的完成时间就会延长。因此，只要找到了关键活动，就找到了关键路径，也就可以得出最短完成时间。  

下面给出在寻找关键活动时所用到的几个参量的定义。  

# 1．事件 $\nu_{k}$ 的最早发生时间 $\nu_{e}(k)$  

它是指从源点 $\nu_{1}$ 到顶点 $v_{k}$ 的最长路径长度。事件 $v_{k}$ 的最早发生时间决定了所有从 $v_{k}$ 开始的活动能够并工的最早时间。可用下面的递推公式来计算：  

v.(源点)  $=0$  

$\nu_{e}(k)=\operatorname{Max}\{\nu_{e}(j)+\operatorname{Weibht}(\nu_{j},\nu_{k})\},\nu_{k}$ 为 $v_{j}$ 的任意后继，Weight $(v_{j},v_{k})$ 表示 $\begin{array}{r}{\negthickspace\negthickspace\negthickspace<\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\negthickspace\neg\negthickspace\negthickspace\negthickspace\negthickspace\neg\negthickspace\negthickspace\negthickspace\neg\negthickspace\negthickspace\neg\negthickspace\neg\!\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\!\,\,\!\,\!\,\!\,\!\,\!\,\!\,\,\!\,\!\,\!\,\!\,\!$ v>上的权值  

# 注意  

计算 $\nu_{e}()$ 值时，按从前往后的顺序进行，可以在拓扑排序的基础上计算：  

$\textcircled{\scriptsize{1}}$ 初始时，令 $\nu_{e}[1...n]=0$  

$\circledcirc$ 输出一个入度为 $0$ 的顶点 $\nu_{j}$ 时，计算它所有直接后继顶点 $\nu_{k}$ 的最早发生时间，若ve[] $\mathrm{Weibt}(\nu_{j},\nu_{k})>\nu_{e}[k],$ 则 $\nu_{e}[k]=\nu_{e}[j]+\mathrm{Weibt}(\nu_{j},\nu_{k})$ 。以此类推，直至输出全部顶点。  

# 2.事件 $\nu_{k}$ 的最迟发生时间 $\nu_{l}(k)$  

它是指在不推迟整个工程完成的前提下，即保证它的后继事件 $v_{j}$ 在其最迟发生时间 $v(j)$ 能够发生时，该事件最迟必须发生的时间。可用下面的递推公式来计算：  

$v_{I}($  汇点)  $=$  v(汇点)  

$\nu_{l}(k)=\mathrm{Min}\{\nu_{l}(j)-\mathrm{Weibh}(\nu_{k},\nu_{j})\},\nu_{k}$  为  $\nu_{j}$  的任意前驱  

# 注意  

计算 $v_{l}(k)$ 值时，按从后往前的顺序进行，可以在逆拓扑排序的基础上计算。增设一个栈以记录拓扑序列，拓扑排序结束后从栈顶至栈底便为逆拓扑有序序列。过程如下：  

$\textcircled{\scriptsize{1}}$ 初始时，令 $\nu_{l}[1...n]=\nu_{e}[n].$  

$\circledcirc$ 栈顶顶点 $v_{j}$ 出栈，计算其所有直接前驱顶点 $v_{k}$ 的最迟发生时间，若 $v_{l}[j]-\mathsf{W e i g h t}(v_{k},\,v_{j})<$  $\displaystyle{\nu_{l}[k]}$ ，则 $\nu_{l}[k]=\nu_{l}[j]-\mathrm{Weigint}(\nu_{k},\nu_{j}).$ ，以此类推，直至输出全部栈中顶点。  

# 3.活动 $\pmb{a}_{i}$ 的最早开始时间 $e(i)$  

它是指该活动弧的起点所表示的事件的最早发生时间。若边 $\begin{array}{r}{\sqrt{\!\!\mathrm{\Sigma}_{k}^{\mathrm{}}\!\!},}\end{array}$ v>表示活动 $a_{i}$ ，则有 $e(i)=$  $\nu_{e}(k)$  

# 4.活动 $\mathbf{\delta}_{\mathbf{\alpha}_{i}}$ 的最迟开始时间I(i)  

它是指该活动弧的终点所表示事件的最迟发生时间与该活动所需时间之差。若边 $\begin{array}{r}{{\mathbf{\mu}}^{<\nu_{k},}}\end{array}$ V>表示活动 $a_{i}$ ，则有 $l(i)=\nu_{i}(j)-\mathrm{Weibull}(\nu_{k},\nu_{j})\,.$  

# 5.一个活动 $\mathbf{\delta}a_{i}$ 的最迟开始时间 $\iota(i)$ 和其最早开始时间 $e(i)$ 的差额 $\begin{array}{r}{d(i)=l(i)-e(i)}\end{array}$  

它是指该活动完成的时间余量，即在不增加完成整个工程所需总时间的情况下，活动 $a_{i}$ 可以拖延的时间。若一个活动的时间余量为零，则说明该活动必须要如期完成，否则就会拖延整个工程的进度，所以称 $l\!(i)\!-\!e(i)\!=\!0$ 即 $l(i)=e(i)$ 的活动 $a_{i}$ 是关键活动。  
>#### pro：求关键路径的实例（2019、2022）  

求关键路径的算法步骤如下：  

$\textcircled{\scriptsize{1}}$ 从源点出发，令v(源点) $=0$ ，按拓扑有序求其余顶点的最早发生时间 $\nu_{e}(0)_{\circ}$  

$\textcircled{2}$ 从汇点出发，令 $v_{l}($ 汇点） $=v_{e}$ (汇点)，按逆拓扑有序求其余顶点的最迟发生时间 $\nu(0)$  

$\textcircled{3}$ 根据各顶点的 $\nu_{e}()$ 值求所有弧的最早开始时间 $e()$  

$\textcircled{4}$ 根据各顶点的 $v_{I}()$ 值求所有弧的最迟开始时间 $l().$  

$\circledast$ 求AOE网中所有活动的差额 $d()$ ，找出所有 $d()=0$ 的活动构成关键路径。  

图6.23所示为求解关键路径的过程，简单说明如下：  

$\textcircled{\scriptsize{1}}$ 求 $\nu_{e}()$ ：初始 $\nu_{e}(1)=0$ ，在拓扑排序输出顶点过程中，求得 $\nu_{e}(2)=3\,,\,\,\nu_{e}(3)=2\,,\,\,\nu_{e}(4)=$  $\operatorname*{max}\left\{\nu_{e}(2)+2,\nu_{e}(3)+4\right\}=\operatorname*{max}\left\{5,6\right\}=6,\;\;\nu_{e}(5)=6,\;\;\nu_{e}(6)=\operatorname*{max}\left\{\nu_{e}(5)+1,\nu_{e}(4)+2,\nu_{e}(3)+4\right\}=2.$   $3\}=\operatorname*{max}\{7,8,5\}=8.$  

若这是一道选择题，根据上述求 $\nu_{e}()$ 的过程就已经能知道关键路径。  

$\circledcirc$ 求 $v()$ ：初始 $\nu(6)\!=\!8$ ，在逆拓扑排序出栈过程中，求得 $\nu(5)\!=\!7$ ， $v(4)\!=\!6$ ， $\begin{array}{r}{v_{i}(3)\!=\!\operatorname*{min}\{v_{i}(4)\!-\!4,}\end{array}$  $\nu_{\ell}(6)-3\}=\operatorname*{min}\{2,\,5\}=2,\,\,\,\nu_{\ell}(2)=\operatorname*{min}\{\nu_{\ell}(5)-3,\,\nu_{\ell}(4)-2\}=\operatorname*{min}\{4,\,4\}=4,$   $v_{l}(1)$  必然为  $0$  而无 须再求。  

$\textcircled{3}$ 弧的最早开始时间e(等于该弧的起点的顶点的 $\nu_{e}(\r)$ ，结果如下表。  

$\textcircled{4}$ 弧的最迟开始时间 $l(i)$ 等于该弧的终点的顶点的 $v_{\Lambda}()$ 减去该弧持续的时间，结果如下表。 $\circledast$ 根据 $l(i)\,-\,e(i)=0$ 的关键活动，得到的关键路径为 $(v_{1},v_{3},v_{4},v_{6}).$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3c83283a75649b4d8c5c2d0548388cadf2a7ab0f11784d1e7fa5d35976e5c5b2.jpg)  
图6.23求解关键路径的过程  

>#### pro：缩短工期的相关分析（2013）  

对于关键路径，需要注意以下几点：  

1）关键路径上的所有活动都是关键活动，它是决定整个工程的关键因素，因此可以通过加快关键活动来缩短整个工程的工期。但也不能任意缩短关键活动，因为一旦缩短到一定的程度，该关键活动就可能会变成非关键活动。  

2）网中的关键路径并不唯一，且对于有几条关键路径的网，只提高一条关键路径上的关键活动速度并不能缩短整个工程的工期，只有加快那些包括在所有关键路径上的关键活动才能达到缩短工期的目的。  

各种图算法在采用邻接矩阵或邻接表存储时的时间复杂度如表6.5所示。  
表6.5采用不同存储结构时各种图算法的时间复杂度
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0cd28f07c2726861bd6847070ff8c2ca1109e478a5a69b4406f36d63f04ed47e.jpg)  



# 思维拓展  

【网易有道笔试题】求一个无向连通图的割点。割点的定义是，若除去此结点和与其相关的边，无向图不再连通，描述算法。  

提示：要判断一个点是否为割点，最简单直接的方法是，先把这个点和所有与它相关的边从图中去掉，再用深搜或广搜来判断剩下的图的连通性，这种方法适合判断给定结点是否为割点；还有一种比较复杂的方法可以快速找出所有割点，有兴趣的读者可自行搜索相关资料。  