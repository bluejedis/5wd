# above

## 【考纲内容】  

（一）sort的基本概念  

（二）插入sort直接插入sort：折半插入sort：希尔sort（shellsort）（三）交换sort冒泡sort（bubblesort）：快速sort（四）选择sort简单选择sort：堆sort （五）二路归并sort（mergesort）（六）基数sort（七）外部sort（八）sort算法的分析和应用  

## 【知识框架】  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/08a16d8a8b640262f36d9686866d92f5ba9d690ee8e2b9b03a94808ae99e6d5b.jpg)  

## 【复习提示】  

堆sort、快速sort和归并sort是本章的重难点。

读者应深入掌握各种sort算法的思想、sort过程（能动手模拟）和特征（初态的影响、复杂度、稳定性、适用性等），通常以选择题的形式考查不同算法之间的对比。

此外，对于一些常用sort算法的关键代码，要达到熟练编写的程度：看到某特定序列，读者应具有选择最优sort算法（根据sort算法特征）的能力。  

# sort的基本概念  

## sort的定义  

sort，就是重新排列表中的元素，使表中的元素满足按关键字有序的过程。为了查找方便，通常希望计算机中的表是按关键字有序的。sort的确切定义如下：  

输入： $n$ 个记录 $R_{1},R_{2},\cdots,R_{n}$ ，对应的关键字为 $k_{1},k_{2},\cdots,k_{n}$  

输出：输入序列的一个重排 $R_{1}^{\prime},R_{2}^{\prime},\cdots,R_{n}^{\prime}$ ，使得 $k_{1}^{\prime}\leqslant k_{2}^{\prime}\leqslant\cdots\leqslant k_{n}^{\prime}$ （其中“≤”可以换成其他的比较大小的符号)。  

算法的稳定性：
- 若待sort表中有两个元素 $R_{i}$ 和 $R_{j}$ 
  - 其对应的关键字相同，即 ${\bf k e y}_{i}={\bf k e y}_{j}$ 
  - &在sort前 $R_{i}$ 在 $R_{j}$ 的前面
- 若使用某一sort算法sort后
  - $R_{i}$ 仍然在 $R_{j}$ 的前面
- sort算法是稳定的
  - or else称这个sort算法是不稳定的

notice：算法是否具有稳定性并不能衡量一个算法的优劣，它主要是对算法的性质进行描述。若待sort表中的关键字不充许重复，sort结果是唯一的，则对于sort算法的选择，稳定与否无关紧要。  

>**attention**  

对于不稳定的sort算法，只需举出一组关键字的实例，说明它的不稳定性即可。  

在sort过程中，根据数据元素是否完全存放在内存中，可将sort算法分为两类： $\textcircled{\scriptsize{1}}$ 内部sort，是指在sort期间元素全部存放在内存中的sort： $\circledcirc$ 外部sort，是指在sort期间元素无法全部同时存放在内存中，必须在sort的过程中粮据要求不断地在内、外存之间移动的sort。  

一般情况下，内部sort算法在执行过程中都要进行两种操作：比较和移动。通过比较两个关键字的大小，确定对应元素的前后关系，然后通过移动元素以达到有序。当然，并非所有的内部sort算法都要基于比较操作，事实上，基数sort就不基于比较操作。  

每种sort算法都有各自的优缺点，适合在不同的环境下使用，就其全面性能而言，很难提出一种被认为是最好的算法。通常可以将sort算法分为插入sort、交换sort、选择sort、归并sort和基数sort五大类，后面几节会分别进行详细介绍。内部sort算法的性能取决于算法的时间复杂度和空间复杂度，而时间复杂度一般是由比较和移动的次数决定的。  

>**attention**  

大多数的内部sort算法都更适用于顺序存储的线性表。  


# 内部sort
##  插入sort  

插入sort是一种简单直观的sort算法，其基本思想是每次将一个待sort的记录按其关键字大小插入前面已排好序的子序列，直到全部记录插入完成。由插入sort的思想可以引申出三个重要的sort算法：直接插入sort、折半插入sort和希尔sort。  

### 直接~

根据上面的插入sort思想，不难得出一种最简单也最直观的直接插入sort算法。假设在sort过程中，待sort表L[1..n]在某次sort过程中的某一时刻状态如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d25ff3c4c8f034d8e69956e4e46fa3d66458180385b7fec90ac66beacd5b43c8.jpg)  
要将元素L（i）插入已有序的子序列L[1i-1]，需要执行以下操作（为避免混淆，下面用L[表示一个表，而用L（）表示一个元素）：  

1）查找出L（i）在L[1.i-1]中的插入位置k。  

2）将L[k...i-1]中的所有元素依次后移一个位置。  

3）将L（i）复制到L（k）。  

为了实现对L[1.n]的sort，可以将 $\mathtt{L}\left(2\right)\sim\mathtt{L}\left(\mathtt{n}\right)$ 依次插入前面已排好序的子序列，初始工[1]可以视为一个已排好序的子序列。上述操作执行 $n-1$ 次就能得到一个有序的表。插入sort在实现上通常采用原地sort（空间复杂度为 $O(1)$ ），因而在从后往前的比较过程中，需要反复把已sort元素逐步向后挪位，为新元素提供插入空间。  

下面是直接插入sort的代码，其中再次用到了前面提到的“哨兵”（作用相同）  

void InsertSort（ElemType A[],int n){ inti,j; for( $_{\pm=2}$  $\scriptstyle{\dot{\mathbf{\rho}}}_{\mathrm{E}}<={\mathbf{\rho}}_{\mathrm{E}}$  //依次将 $\mathtt{A}\left[2\right]\sim\mathtt{A}\left[\mathfrak{n}\right]$ 插入前面已sort序列if(A[i] $<\mathtt{A}$ [i-1]){/若A[i]关键码小于其前驱，将A[i]插入有序表 $\mathbb{A}\left[\,0\,\right]=\mathbb{A}\left[\,{\mathrm{i}}\,\right]$ //复制为哨兵，A[0]不存放元素for（j=i-1；A[0]<A[j]；--j）/从后往前查找待插入位置A[ $_{1+1]=\mathbb{A}}$ [j];/向后挪位 $\mathbb{A}\left[\,\mathfrak{j}+1\,\right]=\mathbb{A}\left[\,\mathfrak{O}\right.$ /复制到插入位置  

假定初始序列为49，38，65，97，76，13，27，49，初始时49可以视为一个已排好序的子序列，按照上述算法进行直接插入sort的过程如图8.1所示，括号内是已排好序的子序列。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9f692fcf6091936b992c48b73392b1b8b99439fcc63adb80f34bf4a92dc3a7bc.jpg)  
图8.1直接插入sort示例  

直接插入sort算法的性能分析如下：  

空间efficiency：仅使用了常数个辅助单元，因而空间复杂度为 $O(1)$  

时间efficiency：在sort过程中，向有序子表中逐个地插入元素的操作进行了 $n\!-\!1$ 趟，per trip操作都分为比较关键字和移动元素，而比较次数和移动次数取决于待sort表的初始状态。  

在最好情况下，表中元素已经有序，此时每插入一个元素，都只需比较一次而不用移动元素，因而时间复杂度为 $O(n)$  

在最坏情况下，表中元素顺序刚好与sort结果中的元素顺序相反（逆序），总的比较次数达到最大，总的移动次数也达到最大，总的时间复杂度为 $O(n^{2})$  

平均情况下，考虑待sort表中元素是随机的，此时可以取上述最好与最坏情况的平均值作为  
平均情况下的时间复杂度，总的比较次数与总的移动次数均约为 $n^{2}/4$ thus，直接插入sort算法的时间复杂度为 $O(n^{2})$  

稳定性：因为每次插入元素时总是从后往前先比较再移动，所以不会出现相同元素相对位置发生变化的情况，即直接插入sort是一个稳定的sort算法。  

适用性：直接插入sort适用于顺序存储和链式存储的线性表，采用链式存储时无须移动元素。  

### 折半~

从直接插入sort算法中，不难看出per trip插入的过程中都进行了两项工作： $\textcircled{\scriptsize{1}}$ 从前面的有序子表中查找出待插入元素应该被插入的位置： $\circledcirc$ 给插入位置腾出空间，将待插入元素复制到表中的插入位置。注意到在该算法中，总是边比较边移动元素。下面将比较和移动操作分离，即先折半查找出元素的待插入位置，然后统一地移动待插入位置之后的所有元素。当sort表为顺序表时，可以对直接插入sort算法做如下改进：因为是顺序存储的线性表，所以查找有序子表时可以用折半查找来实现。确定待插入位置后，就可统一地向后移动元素。算法代码如下：  

void InsertSort（ElemType A[l,int n){ int i,j,low,high,mid; for(  $_{\dot{\mathbf{1}}=2}$   $\scriptstyle{\dot{\mathbf{1}}}<={\boldsymbol{\mathrm{n}}}$   $\ \ \mathrm{i++}$  //依次将A[2]\~A[n]插入前面的已sort序列  $\mathtt{A}\left[\,0\,\right]\mathrm{=A}$  [i]; //将A[i]暂存到A[0] low  $^{=1}$  ;high  $\scriptstyle{\cfrac{\sinh(i-1)}{\sinh(i-1)}}$  //设置折半查找的范围 while(low< $\mathbf{\beta}=$ high){//折半查找（默认递增有序）mid=（low+high)/2;//取中间点if（A[mid]>A[0]）high=mid-1；//查找左半子表elselow=mid+l;//查找右半子表for( $\scriptstyle{\mathrm{j}}={\mathrm{i}}-1$ ;j>=high+1;--j)A[j $+1]=\mathtt{A}$ [j];//统一后移元素，空出插入位置A[high+1] $\mathtt{\ =}\mathtt{A}$ [0];/插入操作  

>#### pro：直接插入sort和折半插入sort的比较（2012）  

从上述算法中，不难看出折半插入sort仅减少了比较元素的次数，时间复杂度约为 $O(n\mathrm{log}_{2}n)$ 该比较次数与待sort表的初始状态无关，仅取决于表中的元素个数 $n$ ：而元素的移动次数并未改变，它依赖于待sort表的初始状态。thus，折半插入sort的时间复杂度仍为 $O(n^{2})$ ，但对于数据量不很大的sort表，折半插入sort往往能表现出很好的性能。折半插入sort是一种稳定的sort算法。  

折半插入sort仅适用于顺序存储的线性表。  

### 希尔sort  

从前面的分析可知，直接插入sort算法的时间复杂度为 $O(n^{2})$ ，但若待sort列为“正序”时，其时间efficiency可提高至 $O(n)$ ，由此可见它更适用于基本有序的sort表和数据量不大的sort表。希尔sort正是基于这两点分析对直接插入sort进行改进而得来的，又称缩小增量sort。  

>#### pro：希尔sort中各子序列采用的sort算法（2015）  

希尔sort的基本思想是：先将待sort表分割成若干形如 $\operatorname{L}[i,i+d,i+2d,\cdots,i+k d]|$ 的“特殊”子表，即把相隔某个“增量”的记录组成一个子表，对各个子表分别进行直接插入sort，当整个表中的元素已呈“基本有序”时，再对全体记录进行一次直接插入sort。  
>#### pro：根据希尔sort的中间过程判断所采用的增量（2014、2018）  

希尔sort的过程如下：先取一个小于 $n$ 的增量 $d_{1}$ ，把表中的全部记录分成 $d_{1}$ 组，所有距离为 $d_{1}$ 的倍数的记录放在同一组，在各组内进行直接插入sort；然后取第二个增量 $d_{2}\!<\!d_{1}$ ，重复上述过程直到所取到的 $d_{t}=1$ ，即所有记录已放在同一组中，再进行直接插入sort，由于此时已经具有较好的局部有序性，thus可以很快得到最终结果。到目前为止，尚未求得一个最好的增量序列。仍以8.2.1节的关键字为例，假定第一趟取增量 $d_{1}=5$ ，将该序列分成5个子序列，即图中第2行至第6行，分别对各子序列进行直接插入sort，结果如第7行所示：假定第二趟取增量 $d_{2}\!=\!3$ ，分别对三个子序列进行直接插入sort，结果如第11行所示：最后对整个序列进行一趟直接插入sort，整个sort过程如图8.2所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/fed15f10d006d56734ed7a4ea13576087c06e17f9b076afa8e5ea4725e0fb071.jpg)  
图8.2希尔sort示例  

希尔sort算法的代码如下：  

void ShellSort（ElemType A[],int n)( I/A[0】只是暂存单元，不是哨兵，当 $\scriptstyle{\frac{1}{3}}<=0$ 时，插入位置已到int dk,i，j; for( ${\mathsf{d k}}{=}{\mathsf{n}}/2$ ;dk ${>}{=}1$ ;dk=dk/2)/增量变化（无统一规定）for(  $\scriptstyle{\dot{1}}=\mathrm{d}k+1$   $\scriptstyle{\mathrm{i}}<={\mathrm{n}}$   ${++}\,{\mathrm{i}}$  if(A[i]<A[i-dk]){ //需将A[i]插入有序增量子表  $\mathbb{A}\left[0\right]{=}\mathbb{A}\left[\mathrm{i}\right]$ //暂存在A[0]for(  $\scriptstyle{\dot{\mathbf{j}}}={\dot{\mathbf{i}}}\cdot$  -dk;j>0&&A[0]<A[j];j-=dk) A[j+dk] $\mathtt{\ =A}$ [j];//记录后移，查找插入的位置A[j+dk] $\mathbf{\equiv}\mathtt{A}\left[0\right]$ //插入  

希尔sort算法的性能分析如下：  

空间efficiency：仅使用了常数个辅助单元，因而空间复杂度为 $O(1)$  

时间efficiency：因为希尔sort的时间复杂度依赖于增量序列的函数，这涉及数学上尚未解决的难题，所以其时间复杂度分析比较困难。当 $n$ 在某个特定范围时，希尔sort的时间复杂度约为 $O(n^{1.3})$ 在最坏情况下希尔sort的时间复杂度为 $O(n^{2})$  
稳定性：当相同关键字的记录被划分到不同的子表时，可能会改变它们之间的相对次序，thus希尔sort是一种不稳定的sort算法。例如，图8.2中49与49的相对次序已发生了变化。适用性：希尔sort仅适用于顺序存储的线性表。  

  

## 交换sort  

所谓交换，是指根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置。基于交换的sort算法很多，本书主要介绍冒泡sort和快速sort，其中冒泡sort算法比较简单，一般很少直接考查，通常会重点考查快速sort算法的相关内容。  

### 冒泡sort  

**基本思想**：

从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即A[i-1]>A[i]），则交换它们，直到序列比较完。我们称它为第一趟冒泡，结果是将最小的元素交换到待sort列的第一个位置（或将最大的元素交换到待sort列的最后一个位置），关键字最小的元素如气泡一般遂渐往上“漂浮”至“水面”（或关键字最大的元素如石头一般下沉至水底）。下一趟冒泡时，前一趟确定的最小元素不再参与比较，per trip冒泡的结果是把序列中的最小元素（或最大元素）放到了序列的最终位置·in this way，最多做 $n-1$ 趟冒泡就能把所有元素排好序。  

图8.3所示为冒泡sort的过程，第一趟冒泡时： $27<\overline{{49}}$ ，不交换； $13<27$ ，不交换； $76>13$ 交换； $97>13$ ，交换； $65>13$ ，交换； $38>13$ ，交换； $49>13$ ，交换。通过第一趟冒泡后，最小元素已交换到第一个位置，也是它的最终位置。第二趟冒泡时对剩余子序列采用同样方法进行sort，如此重复，到第五趟结束后没有发生交换，说明表已有序，冒泡sort结束。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ed7cdadbc990048828d90cd70389495b74cc134c304ca5434cc034bef5c682a7.jpg)  
图8.3冒泡sort示例  

冒泡sort算法的代码如下：  

void BubbleSort（ElemType A[],int for(int  $\scriptstyle{\dot{\boldsymbol{\perp}}}=0$  ;i<n-1;    boolflag  $=$  false; for(int  $\scriptstyle{\mathfrak{j}}=\mathbf{n}-1$  ;j>i;j--) if(A[j-1]>A[j]){  

//表示本趟冒泡是否发生交换的标志

/一趟冒泡过程

//若为逆序  
swap（A[j-1]，A[j]）；//使用封装的swap函数交换flag  $=$  true; if(flag  $==$  false) return;川本趟遍历后没有发生交换，说明表已经有序  

**性能分析**：  

- 空间efficiency：
  - 仅使用了常数个辅助单元，因而空间复杂度为 $O(1)$  

- 时间efficiency：
  - 当初始序列有序时，显然第一趟冒泡后flag依然为false（本趟没有元素交换）
  - thus直接跳出循环，比较次数为 $n\!-\!1$ ，移动次数为0
    - 最好情况下的时间复杂度为 $O(n)$ ：  
      - 当初始序列为逆序时
        - 需要进行 $n-1$ 趟sort，第 $i$ 趟sort要进行 $_{n-i}$ 次关键字的比较
        - and每次比较后都必须移动元素3次来交换元素位置
        - this type，  $=\sum_{i=1}^{n-1}3(n-i)={\frac{3n(n-1)}{2}}$  
      - 最坏情况下的时间复杂度为 $O(n^{2})$ ，平均时间复杂度为 $O(n^{2})$ 
- 稳定性：
  - 由于 $i\!>\!j$ & $\mathbb{A}\left[\dot{\mathtt{\lambda}}\right]{=}\mathbb{A}$ [j]时，
  - 不会发生交换
  - thus冒泡sort是一种稳定的sort算法
- 适用性：
  -  suitable for顺序存储和链式存储'**线性表**

>**attention**  

- ~中所产生的 有序子序列must是全局有序的（不同于直接插入sort）

that's to say：
**有序**子序列中的所有元素的关键字must **<** or **>** **无序**子序列~~，in this way，per tripsort都会place一个元素to其最终的位置上  

### 快速sort  

快速sort（以下有时简称快排）的基本思想是基于分治法的：在待sort表L[1..n]中任取一个元素pivot作为枢轴（或称基准，通常取首元素），通过一趟sort将待sort表划分为独立的两部分L[1.k-1]和 $\operatorname{L}\left[\mathsf{k}\!+\!1...\mathsf{n}\right]$ ，使得L[1.k-1]中的所有元素小于pivot， $\mathrm{L}\,[\,\mathsf{k}\!+\!1...\mathsf{n}\,]$ 中的所有元素大于或等于pivot，则pivot放在了其最终位置L（k）上，这个过程称为一次划分。然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或为空为止，即所有元素放在了其最终位置上。Y  

一趟快速sort的过程是一个交替搜索和交换的过程，下面通过实例来介绍，附设两个指针和j，初值分别为low和high，取第一个元素49为枢轴赋值到变量pivot。  

指针j从high往前搜索找到第一个小于枢轴的元素27，将27交换到i所指位置。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/526c93eb7112f29a9e13e9ad683c9d3dc855c77dc463ca2b2d7e5ec96387ca9d.jpg)  

指针i从1ow往后搜索找到第一个大于枢轴的元素65，将65交换到j所指位置。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/567c047e31d6ce1a994c684a4dfb4b2d64c9ba4e4c04b1136c9c4c4e3317aa7d.jpg)  
指针继续往前搜索找到小于枢轴的元素13，将13交换到1所指位置。  

27 38 97 76 13 65 49  

指针i继续往后搜索找到大于枢轴的元素97，将97交换到j所指位置。  

27 38 13 97 76 65 4S  

指针j继续往前搜索小于枢轴的元素，直至 $\scriptstyle{\dot{\Sigma}}=={\dot{\bar{\jmath}}}$  

27 38 13 76 97 65 49  

命题追踪快速sort的中间过程的分析（2014、2019、2023）  

此时，指针i（ $==$ ）之前的元素均小于49，指针i之后的元素均大于或等于49，将49放在 $i$ 所指位置即其最终位置，经过第一趟sort后，将原序列分割成了前后两个子序列。  

第一趟后：{273813}4976976549}按照同样的方法对各子序列进行快速sort，若待sort列中只有一个元素，显然已有序。  

第二趟后：{13}27{38}49{4965}76{97}第三趟后：1327384949{65)76{97}第四趟后：13273849496576(97}  

用二叉树的形式描述这个举例的递归调用过程，如图8.4所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2bdd6336cf0831776e3ad890454e55448ca6aee0524d2ccb668cfe812107e532.jpg)  
图8.4快速sort的递归执行过程  

假设划分算法已知，记为Partition（），返回的是上述的 $\boldsymbol{\kappa}$ ，则L（k）已放在其最终位置。thus可以先对表进行划分，然后对两个子表递归地调用快速sort算法进行sort。代码如下：  
//Partition（）就是划分操作，将表A[low"high]划分为满足上述条件的两个子表 in t pivot pos $=$ Partition（A,low，high）;//划分QuickSort（A，low，pivotpos-l）；//QuickSort(A,pivotpos  $^{+1}$  ,high);  

>#### pro：（算法题）快速sort中划分操作的应用（2016）  

快速sort算法的性能主要取决于划分操作的好坏。考研所考查的快速sort的划分操作通常总以表中第一个元素作为枢轴来对表进行划分，则将表中比枢轴大的元素向右移动，将比枢轴小的元素向左移动，使得一趟Partition（)操作后，表中的元素被枢轴一分为二。代码如下：  

in t Partition（ElemTypeA[]，intlow，inthigh）{//一趟划分 ElemType pivot $\mathtt{=}\mathtt{A}$ [1ow］；//将当前表中第一个元素设为枢轴，对表进行划分while（low<high){//循环跳出条件while（low<high&&A[high]>=pivot)--high; A[low]  $\mathtt{\ =}\mathtt{A}$  [high]；//将比枢轴小的元素移动到左端 while(low<high&&A[low]  $<=$  pivot)  $++\bot{\mathrm{or}}w$  A[high] $\mathtt{\ =}\mathtt{A}$ [low]；/将比枢轴大的元素移动到右端A[low] $=$ pivot;//枢轴元素存放到最终位置returnlow;/返回存放枢轴的最终位置  

快速sort算法的性能分析如下：  

>#### pro：快速sort中递归次数的影响因素分析（2010）  

空间efficiency：由于快速sort是递归的，thus需要借助一个递归工作栈来保存每层递归调用的必要信息，其容量与递归调用的最大层数一致。最好情况下为 $O(\log_{2}\!n)$ ；最坏情况下，要进行 $n-1$ 次递归调用，thus栈的深度为 $O(n)$ ；平均情况下，栈的深度为 $O(\log_{2}n)$  

时间efficiency：快速sort的运行时间与划分是否对称有关，快速sort的最坏情况发生在两个区域分别包含 $n\!-\!1$ 个元素和0个元素时，这种最大限度的不对称性若发生在每层递归上，即对应于初始sort表基本有序或基本逆序时，就得到最坏情况下的时间复杂度为 $O(n^{2})$  

有很多方法可以提高算法的efficiency：一种方法是尽量选取一个可以将数据中分的枢轴元素，如从序列的头尾及中间选取三个元素，再取这三个元素的中间值作为最终的枢轴元素；或者随机地从当前表中选取枢轴元素，in this way，做可使得最坏情况在实际sort中几乎不会发生。  

在最理想的状态下，即Partition（)能做到最平衡的划分，得到的两个子问题的大小都不可能大于 $n/2$ ，在这种情况下，快速sort的运行速度将大大提升，此时，时间复杂度为 $O(n\mathrm{log}_{2}n)$ 好在快速sort平均情况下的运行时间与其最佳情况下的运行时间很接近，而不是接近其最坏情况下的运行时间。快速sort是所有内部sort算法中平均性能最优的sort算法。  

稳定性：在划分算法中，若右端区间有两个关键字相同，&均小于基准值的记录，则在交换到左端区间后，它们的相对位置会发生变化，即快速sort是一种不稳定的sort算法。例如，表 $L=$ 3，2，2}，经过一趟sort后 $L=\{2,2,3\}$ ，最终sort序列也是 $L=\{2,2,3\}$ ，显然，2与2的相对次序已发生了变化。  

>#### pro：快速sort适合采用的存储方式（2011）  

适用性：快速sort仅适用于顺序存储的线性表。  
>**attention**  

在快速sort算法中，并不产生有序子序列，但每一趟sort后会将上一趟划分的各个无序子表的枢轴（基准）元素放到其最终的位置上。  



##  选择sort  

基本思想：

每一趟（如第 $i$ 趟）在后面 $n-i+1\ (i=1,2,\cdots,n-1)$ 个待sort元素中选取关键字最小的元素，作为有序子序列的第 $i$ 个元素，直到第 $n\!-\!1$ 趟做完，待sort元素只剩下1个，就不用再选。选择sort中的堆sort是历年统考考查的重点。  

### 简单~  

根据上面选择sort的思想，可以很直观地得出简单选择sort算法的思想：假设sort表为L[1.n]，第 $i$ 趟sort即从L[i.n]中选择关键字最小的元素与L（i）交换，每一趟sort可以确定一个元素的最终位置，in this way，经过 $n\!-\!1$ 趟sort就可使得整个sort表有序。  

简单选择sort算法的代码如下：  

void SelectSort（ElemType A[l,int n){ for(int  $\scriptstyle{\dot{\boldsymbol{\mathbf{z}}}}=0$   $\scriptstyle{\mathrm{i}}<{\mathrm{n}}-1$   $\ \ \mathrm{i}_{\mathrm{^{++}}}$  //一共进行n-1趟 int min $\mathbf{\tau}=\dot{\mathbf{\tau}}\mathbf{\Gamma}$ //记录最小元素位置for（int $\scriptstyle{\mathrm{j}}={\mathrm{i}}+1$ ;j<n; $\j++$ //在A[in-1]中选择最小的元素if(A[j] $\tt<\tt A$ [min]） min=j;/更新最小元素位置if(min ${\mathfrak{z}}={\mathfrak{z}}$ ）swap（A[i]，A[min]）；//封装的swap（）函数共移动元素3次  

简单选择sort算法的性能分析如下：  

空间efficiency：仅使用常数个辅助单元，所以空间efficiency为 $O(1)$  

时间efficiency：从上述伪码中不难看出，在简单选择sort过程中，元素移动的操作次数很少，不会超过 $3(n-1)$ 次，最好的情况是移动0次，此时对应的表已经有序；但元素间比较的次数与序列的初始状态无关，始终是 $n(n-1)/2$ 次，thus时间复杂度始终是 $O(n^{2})$  

稳定性：在第 $i$ 趟找到最小元素后，和第 $i$ 个元素交换，可能会导致第 $i$ 个元素与含有相同关键字的元素的相对位置发生改变。例如，表 $L=\{2,2,1\}$ ，经过一趟sort后 $L=\{1,2,2\}$ ，最终sort序列也是 $L=\{1,2,2\}$ ，显然，2与2的相对次序已发生变化。thus，简单选择sort是一种不稳定的sort算法。女  

适用性：简单选择sort适用于顺序存储和链式存储的线性表，以及关键字较少的情况。  

### 堆sort  

定义: $n$ 个关键字序列L[1..n]称为堆，当&仅当该序列满足：  

$\textcircled{1}\,\texttt{L}(\dot{\texttt{i}})>=\texttt{L}$ （2i）& $\tt L\left(\mathrm{i}\right)\mathrm{>=}\tt L$ （2i+1）或 $\circledcirc\mathrm{~\bf~L~}(\dot{\mathrm{~\bf~i~}})<=\tt{L}$ （2i）& $\mathrm{~\tt~L~}(\mathrm{i})<=\tt L\;(2\,\mathrm{i}+1)$ （1≤i≤Ln/2]）  

命题追踪堆的性质与特点（2020）  

可以将堆视为一颗完全二叉树，满足条件 $\circledcirc$ 的堆称为大根堆（大顶堆），大根堆的最大元素存放在根结点，&其任意一个非根结点的值小于或等于其双亲结点值。满足条件 $\mathcal{Q}$ 的堆称为小根堆（小顶堆），小根堆的定义刚好相反，根结点是最小元素。图8.5所示为一个大根堆。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2247078dce401249cf3e73341e50d39d624875f9123a83d24eb59f6fed868004.jpg)  
图8.5一个大根堆示意图  

堆sort的思路很简单：首先将存放在L[1.n]中的 $n$ 个元素建成初始堆，因为堆本身的特点（以大顶堆为例），所以堆顶元素就是最大值。输出堆顶元素后，通常将堆底元素送入堆顶，此时根结点已不满足大顶堆的性质，堆被破坏，将堆顶元素向下调整使其继续保持大顶堆的性质，再 输出堆顶元素。如此重复，直到堆中仅剩一个元素为止。可见，堆sort需要解决两个问题： $\textcircled{\scriptsize{1}}$ 如可将无序序列构造成初始堆？ $\circledcirc$ 输出堆顶元素后，如何将剩余元素调整成新的堆？  

>#### pro：初始建堆的操作（2018、2021）  

堆sort的关键是构造初始堆。 $n$ 个结点的完全二叉树，最后一个结点是第 $\lfloor n/2\rfloor$ 个结点的孩子。对以第 $\lfloor n/2\rfloor$ 个结点为根的子树筛选（对于大根堆，若根结点的关键字小于左右孩子中关键字较大者，则交换），使该子树成为堆。之后向前依次对以各结点 $(\lfloor n/2\rfloor-1{\sim}1)$ 为根的子树进行筛选，看该结点值是否大于其左右子结点的值，若不大于，则将左右子结点中的较大值与之交换，交换后可能会破坏下一级的堆，于是继续采用上述方法构造下一级的堆，直到以该结点为根的子树构成堆为止。反复利用上述调整堆的方法建堆，直到根结点。  

如图8.6所示，初始时调整  $L(4)$  子树，  $09<32$  ，交换，交换后满足堆的定义；向前继续调整 L(3）子树， $78<$ 左右孩子的较大者87，交换，交换后满足堆的定义；向前调整 $L(2)$ 子树， $17<$ 左右孩子的较大者45，交换后满足堆的定义：向前调整至根结点 $L(1)$ ， $53<$ 左右孩子的较大者87，交换，交换后破坏了 $L(3)$ 子树的堆，采用上述方法对 $L(3)$ 进行调整， $53<$ 左右孩子的较大者78，交换，至此该完全二叉树满足堆的定义。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a02575fe03c9077c1e1b12da0a42128eed1a6389ff67ccc69548cc3ecd8c9411.jpg)  
图8.6自下往上逐步调整为大根堆  
>#### pro：输出堆顶元素后调整堆的比较次数的分析（2015）  

输出堆顶元素后，将堆的最后一个元素与堆顶元素交换，此时堆的性质被破坏，需要向下进行筛选。将09和左右孩子的较大者78交换，交换后破坏了 $L(3)$ 子树的堆，继续对 $L(3)$ 子树向下筛选，将09和左右孩子的较大者65交换，交换后得到了新堆，调整过程如图8.7所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/705800718fde337b1004d353eb67a4467c05345b00380d86c440143a0192d934.jpg)  
图8.7输出堆顶元素后再将剩余元素调整成新堆  

下面是建立大根堆的算法：  

void Build Max Heap（ElemType A[],intlen) for（inti=len/2;i>0;i--) 川/从  $\mathrm{i}\!=\![\mathrm{n}/2]\!\sim\!1$  ，反复调整堆 HeadAdjust（A,i,len);  

void HeadAdjust（ElemType A[],int k,int len）(//Head Adjust  $\kappa$  为根的子树进行调整  

$\mathtt{A}\left[\,0\,\right]\mathtt{=A}\left[\,k\,\right]$  I/A[0】暂存子树的根结点 for（int $\scriptstyle{\dot{1}}=Z^{\star}k$  $\scriptstyle{\mathrm{i}}<={\mathrm{1em}}$  $\scriptstyle{\mathrm{~i~}}\star=2$ ）/沿key较大的子结点向下筛选if（i<len&&A[i]<A[i+l])   //取key较大的子结点的下标if  $\scriptstyle(\mathtt{A}\,[\,0\,]\,>=\mathtt{A}\,[\,\mathtt{i}\,]$  )break; 筛选结束 elsel A[k]  $\mathtt{\ =A}$  [i]; //将A[i]调整到双亲结点上  $\kappa{=}1$ //修改 $\kappa$ 值，以便继续向下筛选A[k]=A[0];//被筛选结点的值放入最终位置  

调整的时间与树高有关，为 $O(h)$ 。在建含 $n$ 个元素的堆时，关键字的比较总次数不超过 $4n$ 时间复杂度为 $O(n)$ ，这说明可以在线性时间内将一个无序数组建成一个堆。  

下面是堆sort算法：  

void HeapSort（ElemType A[],int len){ Build Max Heap(A,len); /初始建堆 for（int i=len; $^{\mathrm{i}>1}$ ;i--）{ ${\mathrm{{//n-1}}}$ 趟的交换和建堆过程Swap(A[i],A[1]);//输出堆顶元素（和堆底元素交换）HeadAdjust（A,l,i-1); /调整，把剩余的i-1个元素整理成堆  

>#### pro：堆的插入操作及比较次数的分析（2009、2011）  

同时，堆也支持插入操作。对堆进行插入操作时，先将新结点放在堆的末端，再对这个新结点向上执行调整操作。大根堆的插入操作示例如图8.8所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/98ce82e66a4eab0bac8b05ca1e714ecc3d9283c4602d47d25fd506bba0c39752.jpg)  
图8.8大根堆的插入操作示例  

>#### pro：堆在海量数据中选出最小 $\pmb{k}$ 个数的应用及efficiency分析（2022）  

堆sort适合关键字较多的情况。例如，在1亿个数中选出前100个最大值。首先使用一个大小为100的数组，读入前100个数，建立小顶堆，而后依次读入余下的数，若小于堆顶则舍弃，or else用该数取代堆顶并重新调整堆，待数据读取完毕，堆中100个数为所求。  

堆sort算法的性能分析如下：  

空间efficiency：仅使用了常数个辅助单元，所以空间复杂度为 $O(1)$  

时间efficiency：建堆时间为 $O(n)$ ，之后有 $n\!-\!1$ 次向下调整操作，每次调整的时间复杂度为 $O(h)$ 所以在最好、最坏和平均情况下，堆sort的时间复杂度为 $O(n\log_{2}n)$  

稳定性：进行筛选时，有可能把后面相同关键字的元素调整到前面，所以堆sort算法是一种不稳定的sort算法。例如，表 $L=\{1,2,2\}$ ，构造初始堆时可能将2交换到堆顶，此时 $L=\{2,1,2\}$ 最终sort序列为 $L=\{1,2,2\}$ ，显然，2与2的相对次序已发生变化。  

适用性：堆sort仅适用于顺序存储的线性表。  



## 归并sort、基数sort和计数sort  

### 归并sort  

命题追踪二路归并操作的功能（2022）  

归并sort与上述基于交换、选择等sort的思想不一样，归并的含义是将两个或两个以上的有序表合并成一个新的有序表。假定待sort表含有  $n$  个记录，则可将其视为  $n$  个有序的子表，每个 子表的长度为1，然后两两归并，得到 $\lceil n/2\rceil$ 个长度为2或1的有序表；继续两两归并如此重复，直到合并成一个长度为 $n$ 的有序表为止，这种sort算法称为二路归并sort。  

图8.9所示为二路归并sort的一个例子，经过三趟归并后合并成了有序序列。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/365d58fda45f0a53c2d1bd276f956db5d5d2faf07813666f234e33ea5ffff7d7.jpg)  
图8.9二路归并sort示例  
>#### pro：（算法题）归并sort思想的应用（2011）  

Merge（）的功能是将前后相邻的两个有序表归并为一个有序表。设两段有序表A[low..mid]、A[mid+1..high]存放在同一顺序表中的相邻位置，先将它们复制到辅助数组B中。每次从B的两段中取出一个记录进行关键字的比较，将较小者放入A中，当B中有一段的下标超出其对应的表长（即该段的所有元素都已复制到A中）时，将另一段的剩余部分直接复制到A中。算法如下：  

ElemType ${}^{\star}\mathtt{B}=$ （ElemType \*)malloc（ $(\mathtt{n}\!+\!1)$ \*sizeof（ElemType））；//辅助数组Bvoid Merge（ElemType A[],int low,int mid,int high)(表A的两段A[low..mid]和A[mid+1..high]各自有序，将它们合并成一个有序表int i,j，k; for(  $\kappa=$  low;  $\kappa\!<=$  high;  $\kappa++$  B[k]  $\mathtt{\ =}\mathtt{A}$  [k]; /将A中所有元素复制到B中 for(  $\dot{x}=$  low,j=mid+1,  $\kappa{=}1$   $\mathrm{i}<=$  mid&&j  $<=$  high;  $\kappa++$  if（B[i] $<=\mathtt{B}$ [j])/比较B的两个段中的元素A[k] $\mathbf{\tau}=\mathbf{F}$ 3 $\mathtt{i}_{\mathcal{+++}}$ //将较小值复制到A中else A[k]=B[j++]; while $\scriptstyle{\dot{\mathbf{z}}}<={\mathfrak{m}}$ id) $\mathbb{A}\left[\mathbb{k}^{++}\right]\!=\!\mathbb{B}\left[\mathbb{i}^{++}\right]$ ：//若第一个表未检测完，复制while( $\scriptstyle{\mathrm{~j}}<=$ high) $\mathbb{A}\left[\mathbb{k}{+}{+}\right]{=}\mathbb{B}\left[\mathbb{j}{+}{+}\right]$ ：//若第二个表未检测完，复制  

>**attention**  

在上面的代码中，最后两个while循环只有一个会执行  

一趟归并sort的操作是，调用 $\left(n/2h\right]$ 次算法merge（），将L[1..n]中前后相邻&长度为 $h$ 的有序段进行两两归并，得到前后相邻、长度为 $_{2h}$ 的有序段，整个归并sort需要进行1ogn趟。  

递归形式的二路归并sort算法是基于分治的，其过程如下。  

分解：将含有 $n$ 个元素的待sort表分成各含 $n/2$ 个元素的子表，采用二路归并sort算法对两个子表递归地进行sort。  

合并：合并两个已sort的子表得到sort结果。  

void MergeSort（ElemType A[],int low,int high）{if(low<high){ int mid $=$ (low+high)/2;从中间划分两个子序列MergeSort（A,low,mid);//对左侧子序列进行递归sortMergeSort(A,mid+l,high); /对右侧子序列进行递归sort Merge(A,low,mid,high); /归并  

>#### pro： 归并sort和插入sort的对比（2017）  

二路归并sort算法的性能分析如下：  

空间efficiency：Merge（）操作中，辅助空间刚好为 $n$ 个单元，thus算法的空间复杂度为 $O(n)$  

时间efficiency：per trip归并的时间复杂度为 $O(n)$ ，共需进行 $\lceil\log_{2}n\rceil$ 趟归并，thus算法的时间复杂度为 $O(n\mathrm{log}_{2}n)$  

稳定性：由于Merge（）操作不会改变相同关键字记录的相对次序，thus二路归并sort算法是一种稳定的sort算法。  
适用性：归并sort适用于顺序存储和链式存储的线性表。  

>**attention**  

一般而言，对于 $N$ 个元素进行 $k$ 路归并sort时，sort的趟数 $m$ 满足 $k^{m}\!=\!N$ ，thus $m\!=\!\log_{k}\!N$ 又考虑到 $m$ 为整数，thus $\scriptstyle m\,=\,\lceil\log_{k}N\rceil_{\circ}$ 这和前面的二路归并sort算法是一致的。  

### 基数sort  

基数sort是一种很特别的sort算法，它不基于比较和移动进行sort，而基于关键字各位的大小进行sort。基数sort是一种借助多关键字sort的思想对单逻辑关键字进行sort的方法。  

假设长度为  $n$  的线性表中每个结点  $a_{j}$  的关键字由  $d$  元组  $(\,k_{j}^{d-1}\,,k_{j}^{d-2}\,,\cdots,k_{j}^{1}\,,k_{j}^{0}\,)$  ）组成，满足  $0\!\leqslant\!k_{j}^{\iota}\!\leqslant\!r\!-\!1\:\:(0\!\leqslant\!j\!<\!n,0\!\leqslant\!i\!\leqslant\!d\!-\!1)$ 。其中 $k_{j}^{d-1}$ 为最主位关键字， $k_{j}^{0}$ 为最次位关键字。  

为实现多关键字sort，通常有两种方法：第一种是最高位优先（MISD）法，按关键字位权重递减依次逐层划分成若干更小的子序列，最后将所有子序列依次连接成一个有序序列：第二种是最低位优先（LSD）法，按关键字位权重递增依次进行sort，最后形成一个有序序列。  

下面描述以 $r$ 为基数的最低位优先基数sort的过程，在sort过程中，使用 $r$ 个队列 $Q_{0},\boldsymbol{Q}_{1},\cdots$  $Q_{r-1}$ 。基数sort的过程如下：  

对 $i\!=\!0,1,\cdots,d\!-\!1$ ，依次做一次分配和收集（其实是一次稳定的sort过程）。  

$\textcircled{\scriptsize{1}}$ 分配：开始时，把 $\mathcal{Q}_{0},\mathcal{Q}_{1},\cdots,\mathcal{Q}_{r-1}$ 各个队列置成空队列，然后依次考察线性表中的每个结点 $a_{j}$  $_i\ (j\,{=}\,0,1,\cdots,n-1)$ ，若 $a_{j}$ 的关键字 $k_{j}^{i}\!=\!k_{i}$ ，就把 $a_{j}$ 放进 $Q_{k}$ 队列中。  

$\circledcirc$ 收集：把 $\mathcal{Q}_{0},\mathcal{Q}_{1},\cdots,\mathcal{Q}_{r-1}$ 各个队列中的结点依次首尾相接，得到新的结点序列，thus组成新的线性表。  

>#### pro：基数sort的中间过程的分析（2013、2021）  

通常采用链式基数sort，假设对如下10个记录进行sort：  

$$
\twoheadrightarrow\left[278\right]\twoheadrightarrow\left[109\right]\twoheadrightarrow\left[063\right]\twoheadrightarrow\left[589\right]\twoheadrightarrow\left[184\right]\twoheadrightarrow\left[505\right]\twoheadrightarrow\left[269\right]\twoheadrightarrow\left[008\right]\twoheadrightarrow\left[083\right]
$$  

每个关键字是1000以下的正整数，基数 $r=10$ ，在sort过程中需借助10个链队列，每个关键字由3位子关键字构成一一 $\cdot\mathrm{K}^{1}\mathrm{K}^{2}\mathrm{K}^{3}$ ，分别代表百位、十位和个位，一共进行三趟“分配”和“收集”操作。第一趟分配用最低位子关键字 $\mathrm{K}^{3}$ 进行，将所有最低位子关键字（个位）相等的记录分配到同一个队列，如图8.10(a)所示，然后进行收集操作。第一趟收集后的结果如图8.10(b)所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/48cc62165ce2360ed01930db009972b6262a390392448a6089225dc7f219ffea.jpg)  
图8.10第一趟链式基数sort操作  

第二趟分配用次低位子关键字 $\mathrm{K}^{2}$ 进行，将所有次低位子关键字（十位）相等的记录分配到同一个队列，如图8.11(a)所示。第二趟收集后的结果如图8.11(b)所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9c6f2bf6f54e66bb9877535bef33f0c0f8826a93ead82956fa1cc97ee0d7f7ec.jpg)  
图8.11第二趟链式基数sort操作  

第三趟分配用最高位子关键字 $\mathrm{K}^{1}$ 进行，将所有最高位子关键字（百位）相等的记录分配到同一个队列，如图8.12（a）所示，第三趟收集后的结果如图8.12（b）所示，至此整个sort结束。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/16003a2547311992cc50f4c5ee3d857229a213f2dc465318c889f2714a206b93.jpg)  
图8.12第三趟链式基数sort操作  

基数sort算法的性能分析如下。  

空间efficiency：一趟sort需要的辅助存储空间为 $r~(r$ 个队列： $r$ 个队头指针和 $r$ 个队尾指针），但以后的sort中会重复使用这些队列，所以基数sort的空间复杂度为 $O(r)$  

>#### pro：元素的移动次数与序列初态无关的sort算法（2015）  

时间efficiency：基数sort需要进行 $d$ 趟“分配”和”收集”操作。一趟分配需要遍历所有关键字，时间复杂度为 $O(n)$ ；一趟收集需要合并 $r$ 个队列，时间复杂度为 $O(r)$ 。thus基数sort的时间复杂度为 $O(d(n+r))$ ，它与序列的初始状态无关。  

稳定性：每一趟分配和收集都是从前往后进行的，不会交换相同关键字的相对位置，thus基数sort是一种稳定的sort算法。  

适用性：基数sort适用于顺序存储和链式存储的线性表。  

###  计数sort  

>#### pro：（算法题）计数sort思想的应用（2013、2015、2018）  

计数sort也是一种不基于比较的sort算法。计数sort的思想是：对每个待sort元素 $x$ ，统计小于 $x$ 的元素个数，利用该信息就可确定 $x$ 的最终位置。例如，若有8个元素小于 $x$ ，则 $x$ 就排在第9号位置上。当有几个元素相同时，该sort方案还需做must的优化。  

>**attention**  

计数sort并不在统考大纲的范围内，但其sort思想在历年真题中多次涉及！  
在计数sort算法的实现中，假设输入是一个数组A[n]，序列长度为n，我们还需要两个数组：B[n]存放输出的sort序列，C[k]存储计数值。用输入数组A中的元素作为数组C的下标（索引），而该元素出现的次数存储在该元素作为下标的数组C中。算法如下：  

>#### pro：计数sort相关的思想和代码的分析（2021）  

void CountSort（ElemType A[],ElemType B[],int n,int k){ int i,C[k]; for(  $\scriptstyle{\dot{\mathbf{1}}}=0$  ;i<k;     ${\textsf{C}}\left[{\dot{\Sigma}}\right]\,=\,0$ //初始化计数数组for( $\scriptstyle{\dot{\boldsymbol{\mathbf{z}}}}=0$ ;i<n; $\ \ \dot{\mathbf{i}}_{++}$ 1//遍历输入数组，统计每个元素出现的次数C[A[i] $]{++}$ //C[A[i]]保存的是等于A[i]的元素个数for(  $_\mathrm{i}\!=\!\mathtt{1}$   $\scriptstyle{\dot{\mathbf{1}}}\times\mathbf{k}$   $\dot{\mathbf{1}}++$  C[i]=C[i]+C[i-1];//C[x]保存的是小于或等于 $\mathrm{_x}$ 的元素个数for( $\scriptstyle{\dot{\mathbf{z}}}=\mathbf{n}-1$  $\scriptstyle{\dot{\mathbf{z}}}>=0$ ;i--）{1/从后往前遍历输入数组B[C[A[i]-1]]=A[i];//将元素A[i]放在输出数组B[]的正确位置上C[A[i]]  $\scriptstyle{=\mathbb{C}}$  [A[i]]-1;  

第一个for循环执行完后，数组c的值初始化为0。第二个for循环遍历输入数组A，若一个输入元素的值为 $_\mathrm{x}$ ，则将c[x]值加1，该for循环执行完后，C[x]中保存的是等于 $_\mathrm{x}$ 的元素个数。第三个for循环通过累加计算后，C[x]中保存的是小于或等于 $_\mathrm{x}$ 的元素个数。第四个for循环从后往前遍历数组A，把每个元素A[i1放入它在输出数组B的正确位置上。若数组A中不存在相同的元素，则C[A[i]]-1就是A[i]在数组B中的最终位置，这是因为共有C[A[i]]个元素小于或等于A[i]。若数组A中存在相同的元素，将每个元素A[i]放入数组B[]后，都要将C[A[i]]减1，in this way，，当遇到下一个等于A[i]的输入元素（若存在）时，该元素就可放在数组B中A[i]的前一个位置上。  

假设输入数组 $\mathbb{A}\left[\,\right]=\left\{\,2\,,\,4\,,\,3\,,\,0\,,\,2\,,\,3\,\right\}$ ，第二个for循环执行完后，辅助数组c的情况如图8.13（a）所示；第三个for循环执行完后，辅助数组c的情况如图8.13（b）所示。图8.13（c）至图8.13（h）分别是第四个for循环每迭代一次后，输出数组B和辅助数组c的情况。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e6d44032ce8506b47ebbb00a8709f6c74ae4f9f3c10eef0ae5cff2a9686fb669.jpg)  
图8.13计数sort的过程  
thus
- 原理：
  
数组的索引（下标）是递增有序的，通过将序列中的元素作为辅助数组的索引，其个数作为值放人辅助数组，遍历辅助数组来sort。  

- 性能分析  

空间efficiency：计数sort是一种用空间换时间的做法。输出数组的长度为 $n$ ：辅助的计数数组的长度为 $k$ ，空间复杂度为 $O(n+k)$ 。若不把输出数组视为辅助空间，则空间复杂度为 $O(k)$  

时间efficiency：上述代码的第1个和第3个for循环所花的时间为 $O(k)$ ，第2个和第4个for循环所花的时间为 $O(n)$ ，总时间复杂度为 $O(n+k)$ 。thus，当 $k=O(n)$ 时，计数sort的时间复杂度为 $O(n)$ ：但当 $k\!>\!O(n\!\log\!n)$ 时，其efficiency反而不如一些基于比较的sort（如快速sort、堆sort等）。  

稳定性：上述代码的第4个for循环从后往前遍历输入数组，相同元素在输出数组中的相对位置不会改变，thus计数sort是一种稳定的sort算法。  

适用性：计数sort更适用于顺序存储的线性表。计数sort适用于序列中的元素是整数&元素范围 $(0{\sim}\mathrm{k{-}l}$ ）不能太大，or else会造成辅助空间的浪费。  



# 8.6各种内部sort算法的比较及应用  

##  比较  

前面讨论的sort算法很多，对各种sort算法的比较是考研常考的内容。一般基于五个因素进行对比：时间复杂度、空间复杂度、稳定性、适用性和过程特征。  

>#### pro：各种sort算法的特点、比较和适用场景（2017、2020、2022）  

从时间复杂度看：简单选择sort、直接插入sort和冒泡sort平均情况下的时间复杂度都为 $O(n^{2})$ ，&实现过程也较为简单，但直接插入sort和冒泡sort最好情况下的时间复杂度可以达到 $O(n)$ ，而简单选择sort则与序列的初始状态无关。希尔sort作为插入sort的拓展，对较大规模的数据都可以达到很高的efficiency，但目前未得出其精确的渐近时间。堆sort利用了一种称为堆的数据结构，可以在线性时间内完成建堆，&在 $O(n\mathrm{log}_{2}n)$ 内完成sort过程。快速sort基于分治的思想，虽然最坏情况下的时间复杂度会达到 $O(n^{2})$ ，但快速sort的平均性能可以达到 $O(n\mathrm{log}_{2}n)$ ，在实际应用中常常优于其他sort算法。归并sort同样基于分治的思想，但由于其分割子序列与初始序列的排列无关，thus它的最好、最坏和平均时间复杂度均为 $O(n\log_{2}n)$  

从空间复杂度看：简单选择sort、插入sort、冒泡sort、希尔sort和堆sort都仅需借助常数个辅助空间。快速sort需要借助一个递归工作栈，平均大小为 $O(\log_{2}\!n)$ ，当然在最坏情况下可能会增长到 $O(n)_{\circ}$ 二路归并sort在合并操作中需要借助较多的辅助空间用于元素复制，大小为 $O(n)$ 虽然有方法能克服这个缺点，但其代价是算法会很复杂and时间复杂度会增加。  

>#### pro：sort算法的稳定性判断及改进（2021、2023）  

从稳定性看：插入sort、冒泡sort、归并sort和基数sort是稳定的sort算法，而简单选择排 序、快速sort、希尔sort和堆sort都是不稳定的sort算法。平均时间复杂度为 $O(n\mathrm{log}_{2}n)$ 的稳定sort算法只有归并sort，对于不稳定的sort算法，只需举出一个不稳定的实例即可。对于sort算法的稳定性，读者应能从算法本身的原理上去理解，而不应拘泥于死记硬背。  

>#### pro：更适合采用顺序存储的sort算法（2017）  

从适用性看：折半插入sort、希尔sort、快速sort和堆sort适用于顺序存储。直接插入sort、冒泡sort、简单选择sort、归并sort和基数sort既适用于顺序存储，又适用于链式存储。  
>#### pro：根据sort的中间过程判断所采用的sort算法（2009、2010）  

>#### pro：per tripsort后都至少能确定一个元素的最终位置的sort算法（2012）  
  

从过程特征看：采用不同的sort算法，在一趟或几趟处理后的sort结果通常是不同的，考研题中经常出现给出一个待sort的初始序列和已部分sort的序列，问其采用何种sort算法。这就要对各类sort算法的过程特征十分熟悉，如冒泡sort、简单选择sort和堆sort在per trip处理后都能产生当前的最大值或最小值，而快速sort一趟处理至少能确定一个元素的最终位置等。  

表8.1列出了各种sort算法的时空复杂度和稳定性情况，其中空间复杂度仅列举了平均情况的复杂度，因为希尔sort的时间复杂度依赖于增量函数，所以无法准确给出其时间复杂度。  

表8.1各种sort算法的性质
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0b1409c5ee2c569d34f51b5f3a267d60625ccf83b77b7de8ecb3eb03282fc0fb.jpg)  

## 应用  

通常情况，对sort算法的比较和应用应考虑以下情况。  

>#### pro：选取sort算法时需要考虑的因素（2019）  

### 1.选取sort算法需要考虑的因素  

1）待sort的元素个数 $n$ 2）待sort的元素的初始状态。3）关键字的结构及其分布情况。4）稳定性的要求。5）存储结构及辅助空间的大小限制等。  

### 2.sort算法小结  

1）若 $n$ 较小，可采用直接插入sort或简单选择sort。由于直接插入sort所需的记录移动次数较简单选择sort的多，thus当记录本身信息量较大时，用简单选择sort较好。  

2）若 $n$ 较大，应采用时间复杂度为 $O(n\mathrm{log}_{2}n)$ 的sort算法：快速sort、堆sort或归并sort。当待sort的关键字随机分布时，快速sort被认为是目前基于比较的内部sort算法中最好的算法。堆sort所需的辅助空间少于快速sort，&不会出现快速sort可能的最坏情况，这两种sort都是不稳定的。若要求稳定&时间复杂度为 $O(n\mathrm{log}_{2}n)$ ，可选用归并sort。  

3）若文件的初始状态已按关键字基本有序，则选用直接插入或冒泡sort为宜。4）在基于比较的sort算法中，每次比较两个关键字的大小之后，仅出现两种可能的转移，  
thus可以用一棵二叉树来描述比较判定过程，由此可以证明：当文件的 $n$ 个关键字随机分布时，任何借助于“比较”的sort算法，至少需要 $O(n\mathrm{log}_{2}n)$ 的时间。  

5）若 $n$ 很大，记录的关键字位数较少&可以分解时，采用基数sort较好。  

6）当记录本身信息量较大时，为避免耗费大量时间移动记录，可用链表作为存储结构。  



#  外部sort  

外部sort可能会考查相关概念、方法和sort过程，外部sort的算法比较复杂，不会在算法设计上进行考查。本节的主要内容有：  

$\textcircled{\scriptsize{1}}$ 外部sort指的是大文件的sort，即待sort的记录存储在外存中，待sort的文件无法一次性装入内存，需要在内存和外存之间进行多次数据交换，以达到sort整个文件的自的。 $\circledcirc$ 为减少平衡归并中外存读/写次数所采取的方法：增大归并路数和减少归并段个数。  

$\textcircled{3}$ 利用败者树增大归并路数。  

$\textcircled{4}$ 利用置换-选择sort增大归并段长度来减少归并段个数。 $\circledast$ 由长度不等的归并段进行多路平衡归并，需要构造最佳归并树。  

## 基本概念  

前面介绍过的sort算法都是在内存中进行的（称为内部sort）。而在许多应用中，经常需要对大文件进行sort，因为文件中的记录很多，无法将整个文件复制进内存中进行sort。thus，需要将待sort的记录存储在外存上，sort时再把数据一部分一部分地调入内存进行sort，在sort过程中需要多次进行内存和外存之间的交换。这种sort算法就称为外部sort。  

## 方法  

文件通常是按块存储在磁盘上的，操作系统也是按块对磁盘上的信息进行读/写的。因为磁盘读/写的机械动作所需的时间远远超过在内存中进行运算的时间（相比而言可以忽略不计），thus在外部sort过程中的时间代价主要考虑访问磁盘的次数，即1/O次数。  

>#### pro：对大文件sort时使用的sort算法（2016）  

外部sort通常采用归并sort算法。它包括两个阶段： $\textcircled{\scriptsize{1}}$ 根据内存缓冲区大小，将外存上的文件分成若干长度为 $\ell$ 的子文件，依次读入内存并利用内部sort算法对它们进行sort，并将sort后得到的有序子文件重新写回外存，称这些有序子文件为归并段或顺串； $\circledcirc$ 对这些归并段进行逐趟归并，使归并段（有序子文件）逐渐由小到大，直至得到整个有序文件为止。  
例如，一个含有2000个记录的文件，每个磁盘块可容纳125个记录，首先通过8次内部sort得到8个初始归并段 $\mathrm{R1\!\sim\!R8}$ ，每段都含250条记录。然后对该文件做如图8.15所示的两两归并，直至得到一个有序文件。可以把内存工作区等分为三个缓冲区，如图8.14所示，其中的两个为输入缓冲区，一个为输出缓冲区。首先，从两个输入归并段R1和R2中分别读入一个块，放在输入缓冲区1和输入缓冲区2中。然后，在内存中进行二路归并，归并后的对象顺序存放在输出缓冲区中。若输出缓冲区中对象存满，则将其顺序写到输出归并段（R1）中，再清空输出缓冲区，继续存放归并后的对象。若某个输入缓冲区中的对象取空，则从对应的输入归并段中再读取下一块，继续参加归并。如此继续，直到两个输入归并段中的对象全部读入内存并都归并完成为止。当R1和R2归并完后，再归并R3和R4、R5和R6、最后归并R7和R8，这是一趟归并。再把上趟的结果R1'和R2、R3'和R4'两两归并，这又是一趟归并。最后把R1"和R2"两个归并段归并，得到最终的有序文件，一共进行了3趟归并。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f9dfc2273b2657ab8f22bac4053500f6f3c968af70843c709cd6de6d27e0e7f8.jpg)  
图8.14二路归并  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/594c62b9eed6c74fbcd2ef228dc89133d1f7dacc1faac7b8cf3699861e02d96b.jpg)  
图8.15二路平衡归并的sort过程  

在外部sort中实现两两归并时，由于不可能将两个有序段及归并结果段同时存放在内存中，thus需要不停地将数据读出、写入磁盘，而这会耗费大量的时间。一般情况下：  

外部sort的总时间 $=$ 内部sort的时间 $^+$ 外存信息读/写的时间 $^+$ 内部归并的时间  

显然，外存信息读/写的时间远大于内部sort和内部归并的时间，thus应着力减少1/0次数。由于外存信息的读/写是以“磁盘块”为单位的，thus可知per trip归并需进行16次读和16次写，3趟归并加上内部sort时所需进行的读/写，使得总共需进行 $32\!\times\!3+32=128$ 次读/写。  

若改用4路归并sort，则只需2趟归并，外部sort时的总读/写次数便减至 $32\!\times\!2+32=96.$ thus，增大归并路数，可减少归并趟数，进而减少总的磁盘1/0次数，如图8.16所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/29ffd4a87f89e3a71844bdb43087db397877ef3872bcda905c7c5cc68854e819.jpg)  
图8.164路平衡归并的sort过程  

一般地，对 $r$ 个初始归并段，做 $k$ 路平衡归并（即per trip将 $k$ 个或 $k$ 个以下的有序子文件归并成一个有序子文件）。第一趟可将 $r$ 个初始归并段归并为 $\bar{_{r/k}}$ 个归并段，以后per trip归并将 $m$ 个归并段归并成 $\dot{}_{m/k}$ 个归并段，直至最后形成一个大的归并段为止。树的高度 $-1=\lceil\log_{k}r\rceil=$ 归并趟数S。可见，只要增大归并路数  $k$  ，或减少初始归并段个数  $r$  ，都能减少归并趟数  $S$  ，进而减少读/写 磁盘的次数，达到提高外部sort速度的目的。  

##  多路平衡归并与败者树  

增加归并路数 $k$ 能减少归并趟数S，进而减少1/O次数。然而，增加归并路数 $k$ 时，内部归并的时间将增加。做内部归并时，在 $k$ 个元素中选择关键字最小的元素需要 $k\!-\!1$ 次比较。  
per trip归并 $n$ 个元素需要做 $(n-1)(k-1)$ 次比较， $S$ 趟归并总共需要的比较次数为  

$$
S(n-1)(k-1)=\lceil\log_{k}r\rceil(n-1)(k-1)=\lceil\log_{2}r\rceil(n-1)(k-1)/\lceil\log_{2}k\rceil
$$  

式中， $(\,k-1\,)/\left\lceil\log_{2}\!k\right\rceil$ 随 $k$ 增长而增长，thus内部归并时间亦随 $k$ 的增长而增长。这将抵消因增大 $k$ 而减少外存访问次数所得到的效益。thus，不能使用普通的内部归并sort算法。  

为了使内部归并不受 $k$ 的增大的影响，引入了败者树。败者树是树形选择sort的一种变体，可视为一棵完全二叉树。 $k$ 个叶结点分别存放 $k$ 个归并段在归并过程中当前参加比较的元素，内部结点用来记忆左右子树中的“失败者”，而让胜利者往上继续进行比较，一直到根结点。若比较两个数，大的为失败者、小的为胜利者，则根结点指向的数为最小数。  

如图8.17(a)所示，b3与b4比较，b4是败者，将段号4写入父结点ls[4]。b1与b2比较，b2 是败者,将段号2写入 ls[3]。b3与b4 的胜者b3与b0 比较,b0是败者,将段号0写入 Is[2]。最后两个胜者 b3与b1 比较,b1是败者，将段号1写入Is[1]。而将胜者b3 的段号 3写入 ls[0]。此时，根结点ls[0]所指的段的关键字最小。对于 $k$ 路归并，初始构造败者树需要 $k-1$ 次比较。b3中的6输出后，将下一关键字填入b3，继续比较。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e2a0f7cbaa050a4bfea0e9a28cf40956989e3d9e2e56ab38136f036fb8d98f85.jpg)  
图8.17实现5路归并的败者树  

因为 $k$ 路归并的败者树深度为 $\lceil\log_{2}\!k\rceil\!+\!1$ ，所以从 $k$ 个记录中选择最小关键字，仅需进行[logzk]次比较。thus总的比较次数约为  

$$
S(n-1)\,{\widetilde{\Gamma\log_{2}\!k}}\,{=}\,{\widetilde{\Gamma\log_{k}\!r}}\,(n-1)\,{\widetilde{\Gamma\log_{2}\!k}}\,{=}\,(n-1)\,{\widetilde{\Gamma\log_{2}\!r}}\,{\widetilde{\Gamma\log_{2}\!r}}\,{\widetilde{\Gamma\log_{2}\!r}}\,
$$  

可见，使用败者树后，内部归并的比较次数与 $k$ 无关了。thus，只要内存空间允许，增大归并路数 $k$ 将有效地减少归并树的高度，thus减少I/O次数，提高外部sort的速度。  

值得说明的是，归并路数 $k$ 并不是越大越好。归并路数 $k$ 增大时，相应地需要增加输入缓冲区的个数。若可供使用的内存空间不变，势必要减少每个输入缓冲区的容量，使得内存、外存交换数据的次数增大。当 $k$ 值过大时，虽然归并趟数会减少，但读/写外存的次数仍会增加。  

## 置换-选择sort（生成初始归并段）  

从8.7.2节的讨论可知，减少初始归并段个数 $r$ 也可以减少归并趟数 $S_{\circ}$ 若总的记录个数为 $n$ 每个归并段的长度为，则归并段的个数 $\scriptstyle{r=\left\lceil n/\ell\right\rceil}$ 1。采用内部sort算法得到的各个初始归并段长度都相同（除最后一段外），它依赖于内部sort时可用内存工作区的大小。thus，必须探索新的方法，用来产生更长的初始归并段，这就是本节要介绍的置换-选择算法。  
>#### pro：置换-选择sort生成初始归并段的实例（2023）  

设初始待排文件为FI，初始归并段输出文件为FO，内存工作区为WA，FO和WA的初始状态为空，WA可容纳 $w$ 个记录。置换-选择算法的步骤如下：  

1）从FI输入 $w$ 个记录到工作区WA。  

2）从WA中选出其中关键字取最小值的记录，记为MINIIMAX记录。  

3）将MINIMAX记录输出到FO中去。  

4）若FI不空，则从FI输入下一个记录到WA中。  

5）从WA中所有关键字比MINIMAX记录的关键字大的记录中选出最小关键字记录，作为MINI MAX。  

6）重复 $3)\sim\!51$ ），直至在WA中选不出新的MINIMAX记录为止，由此得到一个初始归并段，输出一个归并段的结束标志到FO中去。  

7）重复 $2)\sim\!6)$ ，直至WA为空。由此得到全部初始归并段。设待排文件 $\mathrm{FI}=\{17,21$ ，05,44,10,12,56,32,29}，WA容量为3，sort过程如表8.2所示。  

表8.2置换-选择sort过程示例
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/06a91576d394233195d293599a1105b769edc8b13f4d56330f10343b1c301dd4.jpg)  

上述算法，在WA中选择MINIMAX记录的过程需利用败者树来实现。  

## 最佳归并树  

文件经过置换-选择sort后，得到的是长度不等的初始归并段。下面讨论如何组织长度不等的初始归并段的归并顺序，使得1/0次数最少。假设由置换-选择sort得到9个初始归并段，其长度（记录数）依次为 $9,30,12,18,3,17,2,6,24$ 。现做3路平衡归并，其归并树如图8.18所示。  

在图8.18中，各叶结点表示一个初始归并段，上面的权值表示该归并段的长度，叶结点到根的路径长度表示其参加归并的趟数，各非叶结点代表归并成的新归并段，根结点表示最终生成的归并段。树的带权路径长度WPL为归并过程中的总读记录数，所以I/O次数 $\stackrel{\cdot}{=}2\times\mathrm{WPL}=484$  
>#### pro：构造三叉哈夫曼树及相关的分析和计算（2013）  

显然，归并方案不同，所得归并树不同，树的带权路径长度（I/O次数）亦不同。为了优化归并树的WPL，可以将哈夫曼树的思想推广到 $m$ 叉树的情形，在归并树中，让记录数少的初始归并段最先归并，记录数多的初始归并段最晚归并，就可以建立总的1/0次数最少的最佳归并树。上述9个初始归并段可构造成一棵如图8.19所示的归并树，按此树进行归并，仅需对外存进行446次读/写，这棵归并树便称为最佳归并树。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/750b4b70d0ce28d6e100a1915c1ed3b27078c90f2f1ab7eb391e62ad4abbcbd8.jpg)  
图8.183路平衡归并的归并树  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8c05244e5d184f1800bafd18f0e9500aee22c219443d98eaf2a153b89b8ca4f3.jpg)  
图8.193路平衡归并的最佳归并树  

图8.19中的哈夫曼树是一棵严格3叉树，即树中只有度为3或0的结点。若只有8个初始归并段，如上例中少了一个长度为30的归并段。若在设计归并方案时，缺额的归并段留在最后，即除最后一次做二路归并外，其他各次归并仍是3路归并，此归并方案的1/0次数为386。显然，这不是最佳方案。正确的做法是：若初始归并段不足以构成一棵严格 $k$ 叉树（也称正则 $k$ 叉树）时，需添加长度为0的“虚段”，按照哈夫曼树的原则，权为0的叶子应离树根最远。thus，最佳归并树应如图8.20所示，此时的1/0次数仅为326。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/400c7ffb6e3e01b16694a55f891313b9094c8e8fae3723f8318229f52ec41d71.jpg)  
图8.208个归并段的最佳归并树  

如何判定添加虚段的数目？  

设度为0的结点有  $n_{0}$  个，度为  $k$  的结点有  $n_{k}$  个，归并树的结点总数为  $n$  ，则有：  

$n\,{=}\,n_{k}+n_{0}$ （总结点数 $=$ 度为 $k$ 的结点数 $^+$ 度为0的结点数） $n=k n_{k}+1$ （总结点数 $=$ 所有结点的度数之和+1)thus，对严格 $k$ 叉树有 $n_{0}\!=\!(k\!-\!1)n_{k}\!+1$ ，由此可得 $n_{k}\!=\!(n_{0}\!-\!1)/(k\!-\!1)\,\circ$ 若 $(n_{\scriptscriptstyle0}-1)\%(k-1)=0$ ( $\%$ 为取余运算)，则说明这 $n_{0}$ 个叶结点（初始归并段）正好可以构造  $k$  叉归并树。此时，内结点有  $n_{k}$  个。 若 $(n_{\scriptscriptstyle0}-1)\%(k-1)=u\neq0$ ，则说明对于这 $n_{0}$ 个叶结点，其中有 $u$ 个多余，不能包含在 $k$ 叉归并树中。为构造包含所有 $n_{0}$ 个初始归并段的 $k$ 叉归并树，应在原有 $n_{k}$ 个内结点的基础上再增加1个内结点。它在归并树中代替了一个叶结点的位置，被代替的叶结点加上刚才多出的 $u$ 个叶结点，即再加上 $k\!-\!u\!-\!1$ 个空归并段，就可以建立归并树。  

>#### pro：实现最佳归并时需补充的虚段数量的分析（2019）  

以图8.19为例，用8个归并段构成3叉树， $(n_{\scriptscriptstyle0}-1)\%(k-1)=(8-1)\%(3-1)=1$ ，说明7个归并段刚好可以构成一棵严格3叉树（假设把以5为根的树视为一个叶子)。为此，将叶子5变成一个内结点，再添加 $3\!-\!1\!-\!1\!=\!1$ 个空归并段，就可以构成一棵严格3叉树。  


# 归纳总结  

sort算法进行一次系统的比较和复习。  

1．直接插入sort、冒泡sort和简单选择sort是基本的sort算法，它们主要用于元素个数 $n$ 不是很大 ( $n<10000$ ）的情形。  

它们的平均时间复杂度均为 $O(n^{2})$ ，实现也都非常简单。直接插入sort对于规模很小的元素序列（ $_{,n\leqslant25}$ ）非常有效。它的时间复杂度与待sort元素序列的初始排列有关。在最好情况下，直接插入sort只需要 $n-1$ 次比较操作就可以完成，&不需要交换操作。在平均情况下和最差情况下，直接插入sort的比较和交换操作都是 $O(n^{2})$ 。冒泡sort在最好情况下只需要一趟sort过程就可以完成，此时也只需要 $n\!-\!1$ 次比较操作，不需要交换操作。简单选择sort的关键字比较次数与待sort元素序列的初始排列无关，其比较次数总是 $O(n^{2})$ ，但元素移动次数则与待sort元素序列的初始排列有关，最好情况下数据不需要移动，最坏情况下元素移动次数不超过 $3(n-1)$  

从空间复杂度来看，这三种基本的sort算法除一个辅助元素外，都不需要其他额外空间。从稳定性来看，直接插入sort和冒泡sort都是稳定的，但简单选择sort不是。  
2.对于中等规模的元素序列（ $n{\leqslant}1000$ ），希尔sort是一种很好的选择。  

在希尔sort中，开始时增量较大，分量较多，每个组内的记录数较少，因而记录的比较和移动次数较少，&移动距离较远；到后来步长越来越小（最后一步为1），分组越少，每个组内的记录数越多，但同时记录次序也越来越接近有序，因而记录的比较和移动次数也都比较少。从理论上和实验上都已证明，在希尔sort中，记录的总比较次数和总移动次数比直接插入sort时少得多，特别是当 $n$ 越大时效果越明显。and，希尔sort代码简单，基本上不需要什么额外内存，但希尔sort是一种不稳定的sort算法。  

3.对于元素个数 $n$ 很大的情况，可以采用快速sort、堆sort、归并sort或基数sort，其中快速sort和堆sort都是不稳定的，而归并sort和基数sort是稳定的sort算法。  

快速sort是最通用的高效内部sort算法，特别是它的划分思想经常在很多算法设计题中出现。平均情况下它的时间复杂度为 $O(n\mathrm{log}_{2}n)$ ，一般情况下所需要的额外空间也是 $O(\log_{2}n)$ 。但是快速sort在有些情况下也可能会退化（如元素序列已经有序时），时间复杂度会增加到 $O(n^{2})$ ，空间复杂度也会增加到 $O(n)$ 。但我们可以通过“三者取中”法来避免最坏情况的发生。  

堆sort也是一种高效的内部sort算法，它的时间复杂度是 $O(n\mathrm{log}_{2}n)$ ，and没有什么最坏情况会导致堆sort的运行明显变慢，并&堆sort基本上不需要额外的空间。但堆sort不大可能提供比快速sort更好的平均性能。  

归并sort也是一个重要的高效sort算法，它的一个重要特性是性能与输入元素序列无关，时间复杂度总是 $O(n\mathrm{log}_{2}n)$ 。归并sort的主要缺点是需要 $O(n)$ 的额外存储空间。  

基数sort是一种相对特殊的sort算法，这类算法不仅是对元素序列的关键字进行比较，更重要的是它们对关键字的不同位部分进行处理和比较。虽然基数sort具有线性增长的时间复杂度，但由于在常规编程环境中，基数sort的线性时间开销实际上并不比快速sort的时间开销小很多，并&由于基数sort基于的关键字抽取算法受到操作系统和sort元素的影响，其适应性远不如普通的进行比较和交换操作的sort算法。thus，在实际工作中，常规的高效sort算法如快速sort的应用要比基数sort广泛得多。基数sort需要的额外存储空间包括和待sort元素序列规模相同的存储空间及与基数数目相等的一系列桶（一般用队列实现）。  

4.混合使用。  

我们可以混合使用不同的sort算法，这也是得到普遍应用的一种算法改进方法，例如，可以将直接插人sort集成到归并sort的算法中。这种混合算法能够充分发挥不同算法各自的优势，thus在整体上得到更好的性能。  


