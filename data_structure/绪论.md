# above

## 【考纲内容】  

算法时间复杂度和空间复杂度的分析&计算  

## 【知识框架】  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/07b4046e520345a2f48d4734855c101b74d5ea80544a0b7500411d020f367de0.jpg)  

## 【复习提示】  

不在考研大纲中
可通过对本章的学习，初步了解数据结构的基本内容和基本方法。分析算法的时间复杂度和空间复杂度是本章重点，need熟练掌握，算法设计题通常都会要求分析时间复杂度、空间复杂度，同时会出现考查时间复杂度的选择题。  



# 基本概念和术语  

## 1.数据  

信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。

数据是计算机程序加工的原料。  

## 2.数据元素  

数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。eg，学生记录就是一个数据元素，它由学号、姓名、性别等数据项组成。  

## 3.数据对象  

具有相同性质的数据元素的**集合**

数据的一个子集

eg
整数数据对象是集合 $N=\{0,\pm1,\pm2,\cdots\}$  

## 4.数据类型  

数据类型是一个值的集合和定义在此集合上的一组操作的总称。  

1）原子类型。其值不可再分的数据类型。  

2）结构类型。其值可以再分解为若干成分（分量）的数据类型。  

3）抽象数据类型。一个数学模型及定义在该数学模型上的一组操作。它通常是对数据的某种抽象，定义了数据的取值范围及其结构形式，以及对数据操作的集合。  

## 5.数据结构  

数据结构是相互之间存在一种或多种特定关系的数据元素的集合。

在任何问题中，数据元素都不是孤立存在的，它们之间存在某种关系，这种数据元素相互之间的关系称为结构（Structure）。

数据结构包括三方面的内容：
- 逻辑结构
- 存储结构
- 数据的运算

数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构。  

# ds三要素  

## 1.data'逻辑结构  

逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。它&数据的存储无关，是独立于计算机的。数据的逻辑结构分为线性结构和非线性结构，线性表是典型的线性结构；集合、树和图是典型的非线性结构。数据的逻辑结构分类如图1.1所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4c0160e3de7b882cb02760de400a3f1d14a69d82805811692110d7243ef0d6d6.jpg)  
图1.1数据的逻辑结构分类图  

集合。结构中的数据元素之间除“同属一个集合”外，别无其他关系，如图1.2（a）所示线性结构。结构中的数据元素之间只存在一对一的关系，如图1.2（b）所示。树形结构。结构中的数据元素之间存在一对多的关系，如图1.2（c）所示。图状结构或网状结构。结构中的数据元素之间存在多对多的关系，如图1.2（d）所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3d4eee36de9ffedeebe77662203b1d9d8c21ec8508de8057cb03357e0b73365f.jpg)  
图1.2四类基本结构关系示例图  
## 2.data'存储结构  

存储结构是指数据结构在计算机中的表示（又称映像），也称物理结构。它包括数据元素的表示和关系的表示。数据的存储结构是用计算机语言实现的逻辑结构，它依赖于计算机语言。数据的存储结构主要有顺序存储、链式存储、索引存储和散列存储。  

1）顺序存储

把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。其优点是可以实现随机存取，每个元素占用最少的存储空间；缺点是只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片。  

2）链式存储

不要求逻辑上相邻的元素在物理位置上也相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。其优点是不会出现碎片现象，能充分利用所有存储单元：缺点是每个元素因存储指针而占用额外的存储空间，且只能实现顺序存取。  

3）索引存储

在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址）。其优点是检索速度快；缺点是附加的索引表额外占用存储空间。另外，增加和删除数据时也要修改索引表，因而会花费较多的时间。  

4）散列存储

根据元素的关键字直接计算出该元素的存储地址，又称哈希（Hash）存储。其优点是检索、增加和删除结点的操作都很快；缺点是若散列函数不好，则可能出现元素存储单元的冲突，而解决冲突会增加时间和空间开销。  

## 3.data'运算  

施加在数据上的运算includes运算的定义&实现

- 定义is aimed at逻辑结构的，point out运算的功能；

- 实现is aimed at存储结构的，point out运算的具体操作步骤



# 算法和算法评价  

## 基本概念  

算法（Algorithm）是对特定问题 **求解步骤**的一种描述
- 是指令的有限序列
- 每条指令表示一个或多个操作

一个算法具有下列五个重要**特性**：  

1）有穷性。

一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。

2）确定性。算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。

3）可行性。算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。

4）输入。一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。  

5）输出。一个算法有一个或多个输出，这些输出是&输入有着某种特定关系的量。

**设计**一个“好”的算法应考虑达到以下目标：  

1）正确性

- 正确地解决求解问题

2）可读性

- 良好的可读性

3）健壮性

- 对输入的**非法**数据做出反应或**处理**

4）高efficiency&低存储量需求

- efficiency：算法执行的时间
- 存储量需求：算法执行过程中所need的最大存储空间

both与问题的规模有关

## 算法efficiency的度量  

>#### pro：（算法题）分析时空复杂度（2010一2013、2015、2016、2018一2021）  

算法efficiency的度量 is described through **时间**复杂度和**空间**复杂度 

### 1．时间复杂度  

>#### port：分析算法的时间复杂度（2011一2014、2017、2019、2022）  

一个语句的**频度** ← 该语句在算法中被重复执行的**次数**

算法中所有语句的频度之和记为 $T(n)$ 

- 是该算法问题规模 $n$ 的函数，时间复杂度主要分析 $T(n)$ 的数量级

- 基本运算（最深层循环中的语句）的频度与 $T(n)$ 同数量级
  - thus, usually将算法中 **基本运算**的执行次数的数量级as该算法的时间复杂度

算法的时间复杂度记为  

$$
T(n)=O(f(n))
$$  

式中:
- $O$ 的含义是 $T(n)$ 的数量级
  - 严格的数学定义是：
    - 若 $T(n)$ 和 $f(n)$ 是定义在正整数集合上的两个函数
      - 则存在正常数 $C$ 和 $n_{0}$ 
      - 使得当 $n{\geqslant}n_{0}$ 时
    - 都满足 $0\leqslant T(n)\leqslant C f(n).$  

算法的T复杂度not only依赖于问题的**规模** $n$ ，but also取决于待输入数据的**性质**（如输入数据元素的初始状态)。

eg，在数组 $\mathbb{A}\left[0...\mathtt{n}-1\right]$ 中，查找给定值 $k$ 的算法大致如下：  

(1)  $\scriptstyle{\dot{\mathbf{i}}}=\mathbf{n}-1$  (2)while(  $\scriptstyle{\dot{\mathbf{1}}}>=0\,\&$  &(A[i]  $!\!=\!\!\kappa$  (3)  $\mathrm{i--}$  （4)returni;  

该算法中语句3（基本运算）的频度不仅&问题规模 $n$ 有关，而且&下列因素有关：  

$\textcircled{\scriptsize{1}}$ 若A中没有& $\kappa$ 相等的元素，则语句3的频度 $f(n)\!=\!n$  $\circledcirc$ 若A的最后一个元素等于k，则语句3的频度 $f(n)$ 是常数0。最坏时间复杂度是指在最坏情况下，算法的时间复杂度。  

平均时间复杂度是指所有可能输入实例在等概率出现的情况下，算法的期望运行时间。  

最好时间复杂度是指在最好情况下，算法的时间复杂度。

一般总是考虑在最坏情况下的时间复杂度，以保证算法的运行时间不会比它更长。  

- TMIE COMPLEXITY两条规则：  

  - 1）加法规则： 
  $$T(n)=T_{1}(n)+T_{2}(n)=O(f(n))+O(g(n))=O(\operatorname*{max}(f(n),g(n)))$$ 

  - 2）乘法规则： 
  $$T(n)=T_{1}(n)\times T_{2}(n)=O(f(n))\times O(g(n))=O(f(n)\times g(n))$$

eg，设a{）、b{}、c{}三个语句块的时间复杂度分别为 $O(1)$ 、 $O(n)$ 、 $O(n^{2})$ ，则  

$\textcircled{\scriptsize{1}}$  #a  
c() /时间复杂度为  $O(n^{2})$  ，满足加法规则  $\circledcirc$  al bi ）/时间复杂度为  $O(n^{3})$  ，满足乘法规则  

- 常见的渐近时间复杂度 
$$
O(1)<O(\log_{2}n)<O(n)<O(n\log_{2}n)<O(n^{2})<O(n^{3})<O(2^{n})<O(n!)<O(n^{n})
$$  

### 2.空间复杂度  

算法的空间复杂度 $S(n)$ 定义为该算法所需的**存储空间** ,是问题规模 $n$ 的**函数**
记为:  

$$
S(n)=O(g(n))
$$  

程序执行时
- need**存储空间**来deposit本身所用的指令、常数、变量和输入数据外
- need some对数据进行操作的工作单元和存储一些为实现计算所需信息的**辅助**空间

if输入数据occupy空间only取决于问题本身，和算法无关
→ only need分析 除输入和程序之外的 额外空间 (→ 以 空间 来确定)

eg，若算法中新建了几个 输入数据规模 $\bf{n}$ 相同的辅助数组 → 空间复杂度为 $\bf{O(n)}$  

#### 算法原地工作:

算法所需的辅助空间为常量，即 $O(1)$  

 

# 归纳总结  

## 重点：分析程序的时间复杂度。
一定要掌握分析时间复杂度的方法和步骤，很多读者在做题时一眼就能看出程序的时间复杂度，但就是无法规范地表述其推导过程。
## 题型的两种形式: 

### 1.循环主体中的变量 参与循环条件   

递推实现的算法中，首先找出基本运算的执行次数 $x$ &问题规模 $n$ 之间的关系式，解得 $x=f(n)$  $f(n)$ 的最高次幂为 $k$ ，则算法的时间复杂度为 $O(n^{k})$ 。

eg
![image.png](https://s2.loli.net/2024/11/10/nCfwxqPOMhp2sZL.png)

在例1中，设基本运算 $\dot{\Sigma}\!=\!\dot{\Sigma}^{\star}2$ 的执行次数为 $t$ ，则 $2^{t}{\leqslant}n$ ，解得 $t{\leqslant}\log_{2}\!n$ ，故 $T(n)=O(\log_{2}\!n).$  

在例2中，设基本运算 $\scriptstyle{\mathrm{y}}={\mathrm{y}}+1$ 的执行次数为1，则 $t\!=\!y\!-\!5$ ，且 $(t+5+1)(t+5+1)<n$ ，解得 $t\!<\!\sqrt{n}-6$ ，即 $T(n)=O({\sqrt{n}}\,)$  

### 2.循环主体中的变量 与循环条件无关  

数学归纳法或直接累计循环次数

多层循环时从内到外分析，忽略单步语句条件判断语句，只关注主体语句的执行次数

递归程序和非递归程序：  

#### 递归程序
一般使用公式进行递推。
时间复杂度的分析如下： $T(n)=1+T(n-1)=1+1+T(n-2)=\cdots=n-1+T(1)$  

即  $T(n)=O(n)$  0  

#### 非递归程序

分析比较简单，可以直接累计次数  

 