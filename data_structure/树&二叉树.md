# 第5章树与二叉树  

# 【考纲内容】  

（一）树的基本概念  

（二）二叉树  

二叉树的定义及其主要特征：二叉树的顺序存储结构和链式存储结构：二叉树的遍历：线索二叉树的基本概念和构造  

（三）树、森林树的存储结构：森林与二叉树的转换；树和森林的遍历  

（四）树与二叉树的应用哈夫曼（Huffman）树和哈夫曼编码：并查集及其应用  

# 【知识框架】  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d54ca676f546045fcd23c9d722b45ed4375e969ecfffd2829a916600c7dcb654.jpg)  

【复习提示】  

本章内容多以选择题或综合题的形式考查，但统考也会出涉及树遍历相关的算法题。树和二叉树的性质、遍历操作、转换、存储结构和操作特性等，满二叉树、完全二叉树、线索二叉树、哈夫曼树的定义和性质，都是选择题必然会涉及的内容。  

# 5.1树的基本概念  

5.1.1树的定义  

树是 $n$  $n{\geqslant}0$ ）个结点的有限集。当 $n=0$ 时，称为空树。在任意一棵非空树中应满足  
1）有且仅有一个特定的称为根的结点。  

2）当 $n>1$ 时，其余结点可分为 $m$  $m\!>\!0$ ）个互不相交的有限集 $T_{1},T_{2},\cdots,T_{m}$ ，其中每个集合本身又是一棵树，并且称为根的子树。显然，树的定义是递归的，即在树的定义中又用到了其自身，树是一种递归的数据结构。树作为一种逻辑结构，同时也是一种分层结构，具有以下两个特点：1）树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱。  

2）树中所有结点都可以有零个或多个后继。  

树适用于表示具有层次结构的数据。树中的某个结点（除根结点外）最多只和上一层的一个结点（即其父结点）有直接关系，根结点没有直接上层结点，因此在 $n$ 个结点的树中有 $n\!-\!1$ 条边。而树中每个结点与其下一层的零个或多个结点（即其孩子结点）都有直接关系。  

# 5.1.2基本术语  

下面结合图5.1中的树来说明一些基本术语和概念。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/19c3d1765bb49ccc50656074b4b2909d9ab012f0a47d45e72e85165ba4b81d5f.jpg)  
图5.1树的树形表示  

1）祖先、子孙、双亲、孩子、兄弟和堂兄弟。  

考虑结点 $K$ ，从根 $A$ 到结点 $K$ 的唯一路径上的所有其他结点，称为结点 $K$ 的祖先。如结点 $B$ 是结点 $K$ 的祖先，而 $K$ 是 $B$ 的子孙，结点 $B$ 的子孙包括 $E,F,K,L$ 。路径上最接近结点 $K$ 的结点 $E$ 称为 $K$ 的双亲，而 $K$ 为 $E$ 的孩子。根 $A$ 是树中唯一没有双亲的结点。有相同双亲的结点称为兄弟，如结点 $K$ 和结点 $L$ 有相同的双亲 $E$ ，即 $K$ 和 $L$ 为兄弟。双亲在同一层的结点互为堂兄弟，结点 $G$ 与 $E,F,H,I,J$ 互为堂兄弟。  

2）结点的度和树的度。  

树中一个结点的孩子个数称为该结点的度，树中结点的最大度数称为树的度。如结点B的度为2，结点 $D$ 的度为3，树的度为3。  

3）分支结点和叶结点。  

度大于0的结点称为分支结点（又称非终端结点）；度为0（没有孩子结点）的结点称为叶结点（又称终端结点）。在分支结点中，每个结点的分支数就是该结点的度。  

4）结点的深度、高度和层次。  

结点的层次从树根开始定义，根结点为第1层，它的孩子为第2层，以此类推。结点的深度就是结点所在的层次。树的高度（或深度）是树中结点的最大层数。结点的高度是以该结点为根的子树的高度。图5.1中树的高度为4。  

5）有序树和无序树。  

树中结点的各子树从左到右是有次序的，不能互换，称该树为有序树，否则称为无序树。  
假设图5.1为有序树，若将子结点位置互换，则变成一棵不同的树。  

6）路径和路径长度。  

树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的，而路径长度是路径上所经过的边的个数。  

# 注意  

因为树中的分支是有向的，即从双亲指向孩子，所以树中的路径是从上向下的，同一双亲的两个孩子之间不存在路径。  

7）森林。  

>#### pro：森林中树的数量、边数和结点数的关系（2016）  

森林是 $m$ ( $m{\gtrsim}0$ ）棵互不相交的树的集合。森林的概念与树的概念十分相近，因为只要把树的根结点删去就成了森林。反之，只要给 $m$ 棵独立的树加上一个结点，并把这 $m$ 棵树作为该结点的子树，则森林就变成了树。  

# 注意  

上述概念无须刻意记忆，根据实例理解即可。考研时不大可能直接考查概念，而都是结合具体的题目考查。做题时，遇到不熟悉的概念可以翻书，练习得多自然就记住了。  

# 5.1.3 树的性质  

树具有如下最基本的性质：  

>#### pro：树中结点数和度数的关系的应用（2010、2016）  

1）树的结点数 $n$ 等于所有结点的度数之和加1。  

结点的度是指该结点的孩子数量，每个结点与其每个孩子都由唯一的边相连，因此树中所有结点的度数之和等于树中的边数之和。树中的结点（除根外）都有唯一的双亲，因此结点数 $n$ 等于边数之和加1，即所有结点的度数之和加1。  

2）度为  $m$  的树中第  $i$  层上至多有  $m^{i-1}$  个结点（  $i\!\geqslant\!1$  

第1层至多有1个结点（即根结点），第2层至多有 $m$ 个结点，第3层至多有 $m^{2}$ 个结点，以此类推。使用数学归纳法可推出第 $i$ 层至多有 $m^{i-1}$ 个结点。  

3）高度为  $h$  的  $m$  叉树至多有  $(m^{h}\!-\!1)/(m\!-\!1)$  个结点。 当各层结点数达到最大时，树中至多有 $1+m+m^{2}+\cdots+m^{h-1}=(m^{h}-1)/(m-1)$ 个结点。命题追踪指定结点数的三叉树的最小高度分析（2022）4）度为 $m$ 、具有 $n$ 个结点的树的最小高度 $h$ 为 $\lceil\log_{m}(n(m-1)+1)\rceil.$  

为使树的高度最小，在前 $h-1$ 层中，每层的结点数都要达到最大，前 $h-1$ 层最多有 $(m^{h-l}-1)/(m-1)$ 个结点，前 $h$ 层最多有 $(m^{h}\!-\!1)/(m\!-\!1)$ 个结点。因此 $(m^{h-l}-1)/(m-1)<n\leqslant$  $(m^{h}\!-\!1)\,/(m\!-\!1)$ ，即 $h-1<\log_{m}(n(m-1)+1){\leqslant}h$ ，解得 $h_{\mathrm{min}}\!=\!\lceil\log_{m}\!(n(m\!-\!1)\!+\!1)\rceil.$  

5）度为 $m$ 、具有 $n$ 个结点的树的最大高度 $h$ 为 $\begin{array}{r}{n\!-\!m+1.}\end{array}$  

由于树的度为 $m$ ，因此至少有一个结点有 $m$ 个孩子，它们处于同一层。为使树的高度最大，其他层可仅有一个结点，因此最大高度（层数）为 $n-m+1$ 。由此，也可逆推出高度为  $h$  、度为  $m$  的树至少有  $h+m-1$  个结点。  

# 注意  

综合以上几题，常用于求解树结点与度之间关系的有：  

$\textcircled{\scriptsize{1}}$ 总结点数 $=n_{0}+n_{1}+n_{2}+\ldots+n_{m}.$  

$\textcircled{2}$ 总分支数 $=1n_{1}+2n_{2}+\ldots+m n_{m}$ （度为 $m$ 的结点引出 $m$ 条分支）  

$\textcircled{3}$ 总结点数 $=$ 总分支数 $+1$  

这类题目常在选择题中出现，读者对以上关系应当熟练掌握并灵活应用。  

# 5.2 二叉树的概念  

# 5.2.1二叉树的定义及其主要特性  

# 1.二叉树的定义  

二叉树是一种特殊的树形结构，其特点是每个结点至多只有两棵子树（即二叉树中不存在度大于2的结点），并且二叉树的子树有左右之分，其次序不能任意颠倒。  

与树相似，二叉树也以递归的形式定义。二叉树是 $n$  $n{\geqslant}0$ ）个结点的有限集合：  

$\textcircled{\scriptsize{1}}$ 或者为空二叉树，即 $n=0$  

$\circledcirc$ 或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树。  

二叉树是有序树，若将其左、右子树颠倒，则成为另一棵不同的二叉树。即使树中结点只有一棵子树，也要区分它是左子树还是右子树。二叉树的5种基本形态如图5.2所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a9c401a0608c49b1b443c3b48c43f6a1ee4376c25cae2385958287b1cf7a89d5.jpg)  
图5.2二叉树的5种基本形态  

二叉树与度为2的有序树的区别：  

$\textcircled{\scriptsize{1}}$ 度为2的树至少有3个结点，而二叉树可以为空。  

$\circledcirc$ 度为2的有序树的孩子的左右次序是相对于另一个孩子而言的，若某个结点只有一个孩子，则这个孩子就无须区分其左右次序，而二叉树无论其孩子数是否为2，均需确定其左右次序，即二叉树的结点次序不是相对于另一结点而言的，而是确定的。  

# 2.儿种特殊的二叉树  

1）满二叉树。一棵高度为 $h$ ，且有 $2^{h}\!-\!1$ 个结点的二叉树称为满二叉树，即二叉树中的每层都含有最多的结点，如图5.3（a）所示。满二叉树的叶结点都集中在二叉树的最下一层，并且除叶结点之外的每个结点度数均为2。  

可以对满二叉树按层序编号：约定编号从根结点（根结点编号为1）起，自上而下，自左向右。这样，每个结点对应一个编号，对于编号为 $i$ 的结点，若有双亲，则其双亲为i/2，若有左孩子，则左孩子为2i：若有右孩子，则右孩子为 $2i+1$  
2）完全二叉树。高度为 $h$ 、有 $n$ 个结点的二叉树，当且仅当其每个结点都与高度为 $h$ 的满二叉树中编号为 $1\!\sim\!n$ 的结点一一对应时，称为完全二叉树，如图5.3（b）所示。其特点如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bdec3149d9bd6e25b24dc7017ddcb7cbf0abc9f5ff55b78c04ee30a8463a64aa.jpg)  
图5.3两种特殊形态的二叉树  

$\textcircled{\scriptsize{1}}$ 若 $i{\leqslant}\lfloor n/2\rfloor$ ，则结点 $i$ 为分支结点，否则为叶结点。 $\circledcirc$ 叶结点只可能在层次最大的两层上出现。对于最大层次中的叶结点，都依次排列在该层最左边的位置上。 $\textcircled{3}$ 若有度为1的结点，则最多只可能有一个，且该结点只有左孩子而无右孩子。 $\textcircled{4}$ 按层序编号后，一旦出现某结点（编号为i）为叶结点或只有左孩子，则编号大于i的结点均为叶结点。 $\circledast$ 若 $n$ 为奇数，则每个分支结点都有左孩子和右孩子：若 $n$ 为偶数，则编号最大的分支结点（编号为 $n/2$ ）只有左孩子，没有右孩子，其余分支结点左、右孩子都有。  

3）二叉排序树。左子树上所有结点的关键字均小于根结点的关键字；右子树上所有结点的关键字均大于根结点的关键字；左子树和右子树又各是一棵二叉排序树。  

4）平衡二叉树。树中任意一个结点的左子树和右子树的高度之差的绝对值不超过1。关于二叉排序树和平衡二叉树的详细介绍，见本书中的73节。  

>#### pro：正则 $\pmb{k}$ 叉树树高和结点数的关系的应用（2016）  

5）正则二叉树。树中每个分支结点都有2个孩子，即树中只有度为0或2的结点。  

# 3.二叉树的性质  

1）非空二叉树上的叶结点数等于度为2的结点数加1，即 $n_{0}\!=\!n_{2}+1$  

证明：设度为0.1和2的结点个数分别为 $n_{0},n_{1}$ 和 $n_{2}$ ，结点总数 $n\!=\!n_{0}+n_{1}+n_{2}.$ 再看二叉树中的分支数，除根结点外，其余结点都有一个分支进入，设 $B$ 为分支总数，则 $n\,{=}\,B+1$ 。由于这些分支是由度为1或2的结点射出的，因此又有 $B\,{=}\,n_{1}+2n_{2}$ 于是得 $n_{0}+n_{1}+n_{2}=n_{1}+2n_{2}+1$ ，则 $n_{0}\!=\!n_{2}+1$ 。  

# 注意  

该性质经常在选择题中涉及，希望读者牢记并灵活应用。  
2）非空二叉树的第  $k$  层最多有  $2^{k-1}$  个结点（  $k\!\geqslant\!1$  

第1层最多有 $2^{1-1}\!=\!1$ 个结点（根），第2层最多有 $2^{2-1}\!=\!2$ 个结点，以此类推，可以证明其为一个公比为2的等比数列 $2^{k-1}$  

3）高度为  $h$  的二叉树至多有  $2^{h}\!-\!1$  个结点（  $h{\geqslant}1$  该性质利用性质2求前 $h$ 项的和，即等比数列求和的结果。  

# 注意  

性质2和性质3还可以拓展到 $m$ 叉树的情况，即 $m$ 叉树的第 $k$ 层最多有 $m^{k-1}$ 个结点，高度为  $h$  的  $m$  叉树至多有  $(2^{h}\!-\!1)/(m\!-\!1)$  个结点。  

4）对完全二叉树按从上到下、从左到右的顺序依次编号 $1,2,\cdots,n$ ，则有以下关系：  

$\textcircled{\scriptsize{1}}$ 若 $i{\leqslant}\lfloor n/2\rfloor$ ，则结点 $i$ 为分支结点，否则为叶结点，即最后一个分支结点的编号为 $\lfloor n/2\rfloor$ 。 $\circledcirc$ 叶结点只可能在层次最大的两层上出现（若删除满二叉树中最底层、最右边的连续2个或以上的叶结点，则倒数第二层将会出现叶结点）。 $\textcircled{3}$ 若有度为1的结点，则只可能有一个，且该结点只有左孩子而无右孩子（度为1的分支结点只可能是最后一个分支结点，其结点编号为 $\lfloor n/2\rfloor$ )。 $\textcircled{4}$ 按层序编号后，一旦出现某结点（如结点i）为叶结点或只有左孩子的情况，则编号大于 $i$ 的结点均为叶结点（与结论 $\circledcirc$ 和结论 $^{(3)}$ 是相通的）。 $\circledast$ 若 $n$ 为奇数，则每个分支结点都有左、右孩子；若 $n$ 为偶数，则编号最大的分支结点（编号为 $n/2$ ）只有左孩子，没有右孩子，其余分支结点都有左、右孩子。 $\circledcirc$ 当 $i>1$ 时，结点 $i$ 的双亲结点的编号为Li/2]。 $\circleddash$ 若结点 $i$ 有左、右孩子，则左孩子编号为 $2i$ ，右孩子编号为 $2i+1$ 6 $\textcircled{8}$ 结点 $i$ 所在层次（深度）为 $\lfloor\log_{2}i\rfloor+1$  

5）具有 $n$ 个( $n>0$ ）结点的完全二叉树的高度为 $\lceil\log_{2}(n+1)\rceil$ 或 $\lfloor\log_{2}\!n\rfloor+1.$ 设高度为 $h$ ，根据性质3和完全二叉树的定义有  

得 $2^{h-1}<n+1\leqslant2^{h}$ ，即 $h-1<\log_{2}(n+1){\leqslant}h$ ，因为 $h$ 为正整数，所以 $h=\lceil\log_{2}(n+1)\rceil$ ，或者得 $h-1\!\leqslant\!\log_{2}\!n<h$ ，所以 $h\!=\!\!\lfloor\log_{2}\!n\rfloor\!+1$  

# 5.2.2二叉树的存储结构  

# 1.顺序存储结构  

二叉树的顺序存储是指用一组连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素，即将完全二叉树上编号为 $i$ 的结点元素存储在一维数组下标为-1的分量中。  

依据二叉树的性质，完全二叉树和满二叉树采用顺序存储比较合适，树中结点的序号可以唯一地反映结点之间的逻辑关系，这样既能最大可能地节省存储空间，又能利用数组元素的下标值确定结点在二叉树中的位置，以及结点之间的关系。  

>#### pro：特定条件下二叉树树形及占用存储空间的分析（2020）  

但对于一般的二叉树，为了让数组下标能反映二叉树中结点之间的逻辑关系，只能添加一些并不存在的空结点，让其每个结点与完全二叉树上的结点相对照，再存储到一维数组的相应分量中。然而，在最坏情况下，一个高度为 $h$ 且只有 $h$ 个结点的单支树却需要占据近 $2^{h}\!-\!1$ 个存储单元。二叉树的顺序存储结构如图5.4所示，其中0表示并不存在的空结点。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1f9ce9f8887f82c175b169c3e33e125a549ecefdeb97d371167ce7f968695b4a.jpg)  
图5.4二叉树的顺序存储结构  

# 注意  

建议从数组下标1开始存储树中的结点，保证数组下标和结点编号一致。  

# 2.链式存储结构  

由于顺序存储的空间利用率较低，因此二叉树一般都采用链式存储结构，用链表结点来存储二叉树中的每个结点。在二叉树中，结点结构通常包括若干数据域和若干指针域，二叉链表至少包含3个域：数据域data、左指针域1child和右指针域rchild，如图5.5所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ee0d9ff6fcf5b36a43fcb3916082d9458841fc02d0057838e76bb0fbd67621ad.jpg)  
图5.5二叉树链式存储的结点结构  

图5.6所示为一棵二叉树及其对应的二叉链表。而实际上在不同的应用中，还可以增加某些指针域，如增加指向父结点的指针后，变为三叉链表的存储结构。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/cc755ffdb13a30c0f9b94e9364d417701c44e786b9f5aaa944f9db48ce9145e5.jpg)  
图5.6二叉链表的存储结构  

二叉树的链式存储结构描述如下：  

typedef struct BiTNode{ El em Type data;//数据域struct BiTNode\*lchild,\*rchild;川左、右孩子指针)BiTNode,\*BiTree;  

使用不同的存储结构时，实现二叉树操作的算法也会不同，因此要根据实际应用场合（二叉树的形态和需要进行的运算）来选择合适的存储结构。  

容易验证，在含有 $n$ 个结点的二叉链表中，含有 $n+1$ 个空链域（重要结论，经常出现在选择题中）。在下一节中，我们将利用这些空链域来组成另一种链表结构一一线索链表。  


# 5.3 二叉树的遍历和线索二叉树  

# 5.3.1二叉树的遍历  

三义树的遍历是指按某条搜索路径访问树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。由于二叉树是一种非线性结构，每个结点都可能有两棵子树，因此需要寻找一种规律，以便使二叉树上的结点能排列在一个线性队列上，进而便于遍历。  

命题追踪二叉树遍历方式的分析（2009、2011、2012）命题追踪（算法题）二叉树遍历的相关应用（2014、2017、2022）  

由二叉树的递归定义可知，遍历一棵二叉树便要决定对根结点N、左子树L和右子树R的访问顺序。按照先遍历左子树再遍历右子树的原则，常见的遍历次序有先序（NLR）、中序（LNR）和后序（LRN）三种遍历算法，其中“序”指的是根结点在何时被访问。  

# 1.先序遍历（PreOrder）  

若二叉树为空，则什么也不做：否则  

1）访问根结点；2）先序遍历左子树：3）先序遍历右子树。  

图5.7中的虚线表示对该二叉树进行先序遍历的路径，得到先序遍历序列为124635。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bb476333d53f3ddbbf63ed5dee671597c8d51d49b039178da94fd12e16d3cb6c.jpg)  
图5.7二叉树的先序遍历  

对应的递归算法如下：  

void PreOrder（BiTree T){ if（T!=NULL){ visit(T);//访问根结点PreOrder(T->lchild); /递归遍历左子树 PreOrder（T->rchild); //递归遍历右子树  

# 2.中序遍历（InOrder）  

若二叉树为空，则什么也不做；否则，  

1）中序遍历左子树：  
2）访问根结点：3）中序遍历右子树。  

命题追踪中序序列中结点关系的分析（2017）图5.8中的虚线表示对该二叉树进行中序遍历的路径，得到中序遍历序列为264135。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5a7a1e8979699afa63f476d125c173136bfd388f5b6d78a36bb8bedfd9462925.jpg)  
图5.8二叉树的中序遍历  

对应的递归算法如下：  

void InOrder（BiTree T）{ if（T!=NULL){ InOrder（T->lchild); //递归遍历左子树 visit(T);/访问根结点InOrder(T->rchild); //递归遍历右子树  

3.后序遍历（PostOrder）  

若二叉树为空，则什么也不做；否则  

1）后序遍历左子树：2）后序遍历右子树：3）访问根结点。  

图5.9中的虚线表示对该二叉树进行后序遍历的路径，得到后序遍历序列为642531。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/83d65a43ce1d35fa50d330ff9b10a6426b21fdcc73aff5dc92b3166bd085a05b.jpg)  
图5.9二叉树的后序遍历  

对应的递归算法如下：  

void PostOrder（BiTree T) if（T!=NULL){  
PostOrder(T->lchild); /递归遍历左子树 PostOrder(T->rchild); /递归遍历右子树 visit(T);//访问根结点  

上述三种遍历算法中，递归遍历左、右子树的顺序都是固定的，只是访问根结点的顺序不同。不管采用哪种遍历算法，每个结点都访问一次且仅访问一次，所以时间复杂度都是 $O(n)$ 。在递归遍历中，递归工作栈的栈深恰好为树的深度，所以在最坏情况下，二叉树是有 $n$ 个结点且深度为 $n$ 的单支树，遍历算法的空间复杂度为 $O(n)$  

# 4.递归算法和非递归算法的转换  

在上节介绍的三种遍历算法中，暂时抹去和递归无关的visitO语句，则3个遍历算法完全相同，因此，从递归执行过程的角度看先序、中序和后序遍历也是完全相同的。  

# 注意  

非递归遍历算法的难度较大，统考对非递归遍历算法的要求通常不高。  

图5.10用带箭头的虚线表示了这三种遍历算法的递归执行过程。其中，向下的箭头表示更深一层的递归调用，向上的箭头表示从递归调用退出返回；虚线旁的三角形、圆形和方形内的字符分别表示在先序、中序和后序遍历的过程中访问根结点时输出的信息。例如，由于中序遍历中访问结点是在遍历左子树之后、遍历右子树之前进行的，则带圆形的字符标在向左递归返回和向右递归调用之间。由此，只要沿虚线从1出发到2结束，将沿途所见的三角形（或圆形或方形）内的字符记下，便得到遍历二叉树的先序（或中序或后序）序列。例如，在图5.10中，沿虚线游走可以分别得到先序序列为ABDEC、中序序列为DBEAC、后序序列为DEBCA。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7a51d5bf37d72f50eb146aea747131d612db4759b8ba5278104c5bcb2f119547.jpg)  

借助栈的思路，我们来分析中序遍历的访问过程：  

$\textcircled{\scriptsize{1}}$ 沿着根的左孩子，依次入栈，直到左孩子为空，说明已找到可以输出的结点，此时栈内元素依次为 $A B D$ 。 $\textcircled{2}$ 栈顶元素出栈并访问：若其右孩子为空，继续执行 $\circledcirc$ ；若其右孩子不空，将右子树转执行 $^{\astrosun}$ 。栈顶 $D$ 出栈并访问，它是中序序列的第一个结点： $D$ 右孩子为空，栈顶 $B$ 出栈并访问； $B$ 右孩子不空，将其右孩子 $E$ 入栈， $E$ 左孩子为空，栈顶 $E$ 出栈并访问； $E$ 右孩子为空，栈顶 $A$ 出栈并访问； $A$ 右孩子不空，将其右孩子 $C$ 入栈， $C$ 左孩子为空，栈顶 $C$ 出栈并访问。由此得到中序序列DBEAC。读者可根据上述分析画出遍历过程的出入栈示意图。  
根据分析可以写出中序遍历的非递归算法如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bea97dfd359f4fa23e37774cbc37c392186c7ec83025a3781c4431d1c371b0ee.jpg)  

先序遍历和中序遍历的基本思想是类似的，只需把访问结点操作放在入栈操作的前面，读者可以参考中序遍历的过程说明自行模拟出入栈示意图。先序遍历的非递归算法如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/551c0911a426ccd11fb7cd94140b7a15d86c77102cd7c3edad266c7d8f1fd06c.jpg)  

后序遍历的非递归实现是三种遍历方法中最难的。因为在后序遍历中，要保证左孩子和右孩子都已被访问并且左孩子在右孩子前访问才能访问根结点，这就为流程的控制带来了难题。  

后序非递归遍历算法的思路分析：从根结点开始，将其入栈，然后沿其左子树一直往下搜索，直到搜索到没有左孩子的结点，但是此时不能出栈并访问，因为若其有右子树，则还需按相同的规则对其右子树进行处理。直至上述操作进行不下去，若栈顶元素想要出栈被访问，要么右子树 为空，要么右子树刚被访问完（此时左子树早已访问完），这样就保证了正确的访问顺序。  

后序遍历的非递归算法见本节综合应用题03的解析部分（不重要）。  

按后序非递归算法遍历图5.10(a)中的二叉树，当访问到 $E$ 时，A, $B,\,D$ 都已入过栈，对于后序非递归遍历，当一个结点的左右子树都被访问后才会出栈，图中 $D$ 已出栈，此时栈内还有 $A$ 和 $B$ 这是 $E$ 的全部祖先。实际上，访问一个结点 $p$ 时，栈中结点恰好是结点 $p$ 的所有祖先，从栈底到栈顶结点再加上结点 $p$ ，刚好构成从根结点到结点 $p$ 的一条路径。在很多算法设计中都可以利用这一思路来求解，如求根到某结点的路径、求两个结点的最近公共祖先等。  

# 5.层次遍历  

图5.11所示为二叉树的层次遍历，即按照箭头所指方向，按照 $1,2,3,4$ 的层次顺序，自上而下，从左至右，对二叉树中的各个结点进行逐层访问。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/fcc01cff756f99920e69dd2b2480873979105c906664f3b0bf11376b861896dd.jpg)  
图5.11二叉树的层次遍历  

进行层次遍历，需要借助一个队列。层次遍历的思想如下： $\textcircled{\scriptsize{1}}$ 首先将二义树的根结点入队。 $\circledcirc$ 若队列非空，则队头结点出队，访问该结点，若它有左孩子，则将其左孩子入队：若它有右孩子，则将其右孩子入队。 $\textcircled{3}$ 重复 $\circledcirc$ 步，直至队列为空。  

二叉树的层次遍历算法如下：  

void LevelOrder（BiTree T) InitQueue（Q);//初始化辅助队列BiTree p; EnQueue（Q,T）;//将根结点入队while(!IsEmpty(Q)){ /队列不空则循环 DeQueue（Q,p）;/队头结点出队visit(p);/访问出队结点if(p->lchild！  $=$  NULL) EnQueue(Q,p->lchild);/若左孩子不空，则左孩子入队if(p->rchild!  $=$  NULL) EnQueue(Q,p->rchild);川若右孩子不空，则右孩子入队  

上述二叉树层次遍历的算法，读者在复习过程中应将其作为一个模板，在熟练掌握其执行过程的基础上来记忆，并达到熟练手写的程度。这样才能将该模板应用于各种题目之中。  

# 注意  

遍历是二叉树各种操作的基础，例如对于一棵给定二叉树求结点的双亲、求结点的孩子、求二叉树的深度、求叶结点个数、判断两棵二叉树是否相同等。所有这些操作都是在遍历的过程中进行的，因此必须掌握二叉树的各种遍历过程，并能灵活运用以解决各种问题。  

# 6.由遍历序列构造二叉树  

>#### pro：先序序列对应的不同二叉树的分析（2015）  

对于一棵给定的二叉树，其先序序列、中序序列、后序序列和层序序列都是确定的。然而，只给出四种遍历序列中的任意一种，却无法唯一地确定一棵二叉树。若已知中序序列，再给出其他三种遍历序列中的任意一种，就可以唯一地确定一棵二叉树。  

（1）由先序序列和中序序列构造二叉树  

命题追踪先序序列和中序序列相同时确定的二叉树（2017）  

命题追踪由先序序列和中序序列构造一棵二叉树（2020、2021）  

在先序序列中，第一个结点一定是二叉树的根结点；而在中序遍历中，根结点必然将中序序列分割成两个子序列，前一个子序列是根的左子树的中序序列，后一个子序列是根的右子树的中序序列。左子树的中序序列和先序序列的长度是相等的，右子树的中序序列和先序序列的长度是相等的。根据这两个子序列，可以在先序序列中找到左子树的先序序列和右子树的先序序列，如图5.12所示。如此递归地分解下去，便能唯一地确定这棵二叉树。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f95f56d393b614bbe625168363fd791b2fa3b99d431538422cdb0c9dfce8aee8.jpg)  
图5.12由先序序列和中序序列构造二叉树  

例如，求先序序列（ABCDEFGHI）和中序序列（BCAEDGHFI）所确定的二叉树。首先，由先序序列可知  $A$  为二叉树的根结点。中序序列中  $A$  之前的  $B C$  为左子树的中序序列，EDGHFI为 右子树的中序序列。然后，由先序序列可知 $B$ 是左子树的根结点， $D$ 是右子树的根结点。以此类推，就能将剩下的结点继续分解下去，最后得到的二叉树如图5.13(c)所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1bdfc32800eb0bdcdf69f66b04372af5f987fca29874a7edb3170bdcc7281785.jpg)  
图5.13一棵二叉树的构造过程  

（2）由后序序列和中序序列构造二叉树  

命题追踪由后序序列和树形构造一棵二叉树（2017、2023）  

同理，由二叉树的后序序列和中序序列也可以唯一地确定一棵二叉树。因为后序序列的最后一个结点就如同先序序列的第一个结点，可以将中序序列分割成两个子序列，如图5.14所示，然后采用类似的方法递归地进行分解，进而唯一地确定这棵二叉树。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b7ff525d65d5eecf2e799de58498c82c5cc855212f4dedd5b861b42917822ce2.jpg)  
图5.14由后序序列和中序序列构造二叉树  

请读者分析后序序列（CBEHGIFDA）和中序序列（BCAEDGHFI）所确定的二叉树。  

（3）由层序序列和中序序列构造二叉树  

在层序遍历中，第一个结点一定是二叉树的根结点，这样就将中序序列分割成了左子树的中序序列和石子树的中序序列。若存在左子树，则层序序列的第二个结点一定是左子树的根，可进一步划分左子树；若存在右子树，则中序序列中紧接着的下一个结点一定是右子树的根，可进一步划分右子树，如图5.15所示。采用这种方法继续分解，就能唯一确定这棵二叉树。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bfeb791360f3d1b1e847316927966170a32c8f5faecc10370d6de9816a2ae6c1.jpg)  
图5.15由层序序列和中序序列构造二叉树  

请读者分析后序序列（ABDCEFGIH）和中序序列（BCAEDGHFI）所确定的二叉树。  

需要注意的是，先序序列、后序序列和层序序列的两两组合，无法唯一确定一棵二叉树。例如，图5.16所示的两棵二义树的先序序列都为 $A B$ ，后序序列都为BA，层序序列都为 $A B_{c}$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8a85e2de2af6b7d96b93dbde3997116acee9adafbb64aa34b17139eaf5456102.jpg)  
图5.16两棵不同的二叉树  

# 5.3.2 线索二叉树  

# 1.线索二叉树的基本概念  

遍历二叉树是以一定的规则将二叉树中的结点排列成一个线性序列，从而得到几种遍历序列，使得该序列中的每个结点（第一个和最后一个除外）都有一个直接前驱和直接后继。  

>#### pro：后序线索二叉树的定义（2010）  

传统的二叉链表存储仅能体现一种父子关系，不能直接得到结点在遍历中的前驱或后继。前面提到，在含 $n$ 个结点的二叉树中，有 $n+1$ 个空指针。这是因为每个叶结点都有2个空指针，每个度为1的结点都有1个空指针，空指针总数为 $2n_{0}+n_{1}$ ，又 $n_{0}\!=\!n_{2}\!+1$ ，所以空指针总数为 $n_{0}+n_{1}+n_{2}+1=n+1.$ 由此设想能否利用这些空指针来存放指向其前驱或后继的指针？这样就可以像遍历单链表那样方便地遍历二叉树。引入线索二叉树正是为了加快查找结点前驱和后继的速度。  

规定：若无左子树，令lchild指向其前驱结点：若无右子树，令rchild指向其后继结点。 如图5.17所示，还需增加两个标志域，以标识指针域指向左（右）孩子或前驱（后继）。）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a9348224b92a82715ff985f8c31844579514448dbf87208d26fb3b1653501d4d.jpg)  

其中，标志域的含义如下：  

线索二叉树的存储结构描述如下：  

typedef struct ThreadNode{ El em Type data;struct Thread Node \*lchild,\*rchild; intltag,rtag;  

//数据元素

//左、右孩子指针I/左、右线索标志)ThreadNode,\*ThreadTree;  
以这种结点结构构成的二叉链表作为二叉树的存储结构，称为线索链表，其中指向结点前驱和后继的指针称为线索。加上线索的二叉树称为线索二叉树。  

# 2.中序线索二叉树的构造  

二叉树的线索化是将二叉链表中的空指针改为指向前驱或后继的线索。而前驱或后继的信息只有在遍历时才能得到，因此线索化的实质就是遍历一次二叉树。  

>#### pro：中序线索二叉树中线索的指向（2014）  

以中序线索二叉树的建立为例。附设指针pre指向刚刚访问过的结点，指针P指向正在访问的结点，即pre指向p的前驱。在中序遍历的过程中，检查p的左指针是否为空，若为空就将它指向pre；检查pre的右指针是否为空，若为空就将它指向p，如图5.18所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/76585adca20c3587f88d89587e71edca8e1fc50e3353660a5d0938cbebc7c9fa.jpg)  
图5.18中序线索二叉树及其二叉链表示  

通过中序遍历对二叉树线索化的递归算法如下：  

void InThread(ThreadTree &p,ThreadTree&pre){ if（p!=NULL）{ InThread(p->lchild,pre); //递归，线索化左子树 if(p->lchild $==$ NULL){/当前结点的左子树为空p->lchild=pre;I/建立当前结点的前驱线索p->ltag  $^{=1}$  if(pre! $=$ NULL&&pre->rchild= $:=$ NULL）（/前驱结点非空且其右子树为空pre->rchild=p;/建立前驱结点的后继线索pre->rtag  $\scriptstyle{\varphi=1}$  pre=p; /标记当前结点成为刚刚访问过的结点 InThread(p->rchild,pre); /递归，线索化右子树  

通过中序遍历建立中序线索二叉树的主过程算法如下：  

void Create In Thread(ThreadTree T){ ThreadTree pre  $=$  NULL; //非空二叉树，线索化if（T!=NULL){ InThread（T,pre); 线索化二叉树 pre->rchild $\scriptstyle=$ NULL;//处理遍历的最后一个结点pre->rtag  $^{=1}$  

为了方便，可以在二叉树的线索链表上也添加一个头结点，令其1chi1a域的指针指向二叉树的根结点，其rchild域的指针指向中序遍历时访问的最后一个结点：令二叉树中序序列中的第一个结点的1child域指针和最后一个结点的rchild域指针均指向头结点。这好比为二叉树建立了一个双向线索链表，方便从前往后或从后往前对线索二叉树进行遍历，如图5.19所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3b88560b15260cda3cfd0b4e2229bfad1694c1d19f2b50c0d4c2b47f5c35b88e.jpg)  
图5.19带头结点的中序线索二叉树  

# 3.中序线索二叉树的遍历  

中序线索二叉树的结点中隐含了线索二叉树的前驱和后继信息。在对其进行遍历时，只要先找到序列中的第一个结点，然后依次找结点的后继，直至其后继为空。在中序线索二叉树中找结点后继的规律是：若其右标志为“1”，则右链为线索，指示其后继，否则遍历右子树中第一个访问的结点（右子树中最左下的结点）为其后继。不含头结点的线索二叉树的遍历算法如下。  

1）求中序线索二叉树的中序序列下的第一个结点：  

ThreadNode \*Firstnode(ThreadNode  $\star_{\mathbb{P}}$  while(p->ltag $==0$ ）p=p->lchild；/最左下结点（不一定是叶结点）returnp;  

2）求中序线索二叉树中结点p在中序序列下的后继：  

ThreadNode \*Nextnode(ThreadNode  ${}^{\star}\mathtt{p}.$  if(p->rtag $==0$ ）return First node（p->rchild）；l/右子树中最左下结点else return p->rchild;l/若rtag $==1$ 则直接返回后继线索  

请读者自行分析并完成求中序线索二叉树的最后一个结点和结点p前驱的运算?。3）利用上面两个算法，可写出不含头结点的中序线索二叉树的中序遍历的算法  

void Inorder(ThreadNode  $\star_{\mathrm{T}}$  for(ThreadNode ${}^{\star}\!\mathtt{p}^{=}$ Firstnode（T);p！ $=$ NULL; ${\tt p}{=}$ Nextnode(p))visit(p);  

# 4.先序线索二叉树和后序线索二叉树  

上面给出了建立中序线索二叉树的代码，建立先序线索二叉树和建立后序线索二叉树的代码类似，只需变动线索化改造的代码段与调用线索化左右子树递归函数的位置。  

以图5.20（a）的二叉树为例给出手动求先序线索二叉树的过程：先序序列为ABCDF，然后依次判断每个结点的左右链域，若为空，则将其改造为线索。结点 $A,B$ 均有左右孩子：结点 $C$ 无左孩子，将左链域指向前驱 $B$ ，无右孩子，将右链域指向后继 $D$ ：结点 $D$ 无左孩子，将左链域指尚前驱 $C$ ，无右孩子，将右链域指向后继 $F$ ：结点 $F$ 无左孩子，将左链域指向前驱 $D$ ，无右孩子，也无后继，所以置空，得到的先序线索二叉树如图5.20(b)所示。求后序线索二叉树的过程：后序序列为CDBFA，结点 $C$ 无左孩子，也无前驱，所以置空，无右孩子，将右链域指向后继 $D$ ：结点 $D$ 无左孩子，将左链域指向前驱 $C$ ，无右孩子，将右链域指向后继 $B$ ：结点 $F$ 无左孩子，将左链域指向前驱 $B$ ，无右孩子，将右链域指向后继 $A$ ，得到的后序线索二叉树如图5.20（c）所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0fd60e6474663a6b6e5925b13b2ab71bcb51d855371fd982a306b9a0b94e3169.jpg)  
图5.20先序线索二叉树和后序线索二叉树  

如何在先序线索二叉树中找结点的后继？若有左孩子，则左孩子就是其后继；若无左孩子但有右孩子，则右孩子就是其后继；若为叶结点，则右链域直接指示了结点的后继。  

>#### pro：后序线索二叉树中线索的指向（2013）  

在后序线索二叉树中找结点的后继较为复杂，可分三种情况： $\textcircled{\scriptsize{1}}$ 若结点 $x$ 是二叉树的根，则其后继为空： $\circledcirc$ 若结点 $x$ 是其双亲的右孩子，或是其双亲的左孩子且其双亲没有右子树，则其后继即为双亲： $\textcircled{3}$ 若结点 $x$ 是其双亲的左孩子，且其双亲有右子树，则其后继为双亲的右子树上按后序遍历列出的第一个结点。图5.20（c）中找结点 $B$ 的后继无法通过链域找到，可见在后序线索二叉树上找后继时需知道结点双亲，即需采用带标志域的三叉链表作为存储结构。  


# 5.4树、森林  

# 5.4.1树的存储结构  

树的存储方式有多种，既可采用顺序存储结构，又可采用链式存储结构，但无论采用何种存储方式，都要求能唯一地反映树中各结点之间的逻辑关系，这里介绍3种常用的存储结构。  

# 1.双亲表示法  

这种存储结构采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其双亲结点在数组中的位置。如图5.21所示，根结点下标为0，其伪指针域为-1。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a2e6b516fbf68e36a6730aff3150c9226473ea4cf4cbe0b6ac46cd04bc5e31e9.jpg)  
图5.21树的双亲表示法  

双亲表示法的存储结构描述如下：  

#define MAX TREE SIZE 100 typedef struct{ ElemType data;  

/树中最多结点数

/树的结点定义

//数据元素  
intparent;I/双亲位置域)PTNode; typedef structr /树的类型定义 PTNode nodes[MAX TREE SIZE];双亲表示intn;/结点数)PTree;  

双亲表示法利用了每个结点（根结点除外）只有唯一双亲的性质，可以很快地得到每个结点的双亲结点，但求结点的孩子时则需要遍历整个结构。  

# 注意  

区别树的顺序存储结构与二叉树的顺序存储结构。在树的顺序存储结构中，数组下标代表结点的编号，下标中所存的内容指示了结点之间的关系。而在二叉树的顺序存储结构中，数组下标既代表了结点的编号，又指示了二叉树中各结点之间的关系。当然，二叉树属于树，因此二叉树也可用树的存储结构来存储，但树却不都能用二叉树的存储结构来存储。  

# 2.孩子表示法  

孩子表示法是将每个结点的孩子结点视为一个线性表，且以单链表作为存储结构，则 $n$ 个结点就有 $n$ 个孩子链表（叶结点的孩子链表为空表）。而 $n$ 个头指针又组成一个线性表，为便于查找，可采用顺序存储结构。图5.22（a）是图5.21（a）中的树的孩子表示法。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/60e641d5bf1b6a3367c0a715896ea6200c65d1d47f135dad05b2de7cc643bbac.jpg)  
图5.22树的孩子表示法和孩子兄弟表示法  

与双亲表示法相反，孩子表示法寻找孩子的操作非常方便，而寻找双亲的操作则需要遍历 $n$ 个结点中孩子链表指针域所指向的 $n$ 个孩子链表。  

3.孩子兄弟表示法  

孩子兄弟表示法又称三叉树表示法，即以二叉链表作为树的存储结构。孩子兄弟表示法使每个结点包括三部分内容：结点值、指向结点第一个孩子结点的指针，以及指向结点下一个兄第结点的指针（沿此域可以找到结点的所有兄弟结点），如图5.22（b）所示。  

孩子兄弟表示法的存储结构描述如下：  

typedef struct CsNode{ El em Type data;struct CsNode \*firstchild,\*next sibling;  

/数据域川第一个孩子和右兄弟指针)CSNode,\*CSTree;  
孩子兄弟表示法比较灵活，其最大的优点是可以方便地实现树转换为二叉树的操作，易于查找结点的孩子等，但缺点是从当前结点查找其双亲结点比较麻烦。若为每个结点增设一个parent域指向其父结点，则查找结点的父结点也很方便。  

# 5.4.2 树、森林与二叉树的转换  

二义树和树都可以用二义链表作为存储结构。从物理结构上看，树的孩子兄第表示法与二义树的二叉链表表示法是相同的，因此可以用同一存储结构的不同解释将一棵树转换为二叉树。  

# 1.树转换为二叉树  

>#### pro：树和二叉树的转换及相关性质的推理（2009、2011）  

树转换为二叉树的规则：每个结点的左指针指向它的第一个孩子，右指针指向它在树中的相邻右兄弟，这个规则又称“左孩子右兄弟”。由于根结点没有兄弟，因此树转换得到的二叉树没有右子树，如图5.23所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6c83cdc39d25f3e1591f8d9edaa5c910296cb1e468eeeba38ac072864a44455f.jpg)  
图5.23树与二叉树的对应关系  

树转换为二叉树的画法：  

1）在兄弟结点之间加一连线：2）对每个结点，只保留它与第一个孩子的连线，而与其他孩子的连线全部抹掉；3）以树根为轴心，顺时针旋转  $45^{\circ}$  

# 2.森林转换为二叉树  

>#### pro：森林和二叉树的转换及相关性质的推理（2014）  

将森林转换为二叉树的规则与树类似。先将森林中的每棵树转换为二叉树，由于任意一棵树对应的二叉树的右子树必空，若把森林中第二棵树根视为第一棵树根的右兄弟，即将第二棵树对应的二叉树当作第一棵二叉树根的右子树，将第三棵树对应的二叉树当作第二棵二叉树根的右子树，以此类推，就可以将森林转换为二叉树。广  

森林转换为二叉树的画法：1）将森林中的每棵树转换成相应的二叉树：  
2）每棵树的根也可视为兄弟关系，在每棵树的根之间加一根连线：3）以第一棵树的根为轴心顺时针旋转 $45^{\circ}$  

# 3.二叉树转换为森林  

>#### pro：  

由遍历序列构造一棵二叉树并转换为对应的森林（2020、2021）  

二叉树转换为森林的规则：若二叉树非空，则二叉树的根及其左子树为第一棵树的二叉树形式，所以将根的右链断开。二叉树根的右子树又可视为一个由除第一棵树外的森林转换后的二叉树，应用同样的方法，直到最后只剩一棵没有右子树的二叉树为止，最后将每棵二叉树依次转换成树，就得到了原森林，如图5.24所示。二叉树转换为树或森林是唯一的。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/247436d1c407e375d4ea4ae286dd335ae4bf8469ec4ad1b3014b562aced6dfaa.jpg)  
图5.24森林与二叉树的对应关系  

# 5.4.3树和森林的遍历  

# 1.树的遍历  

>#### pro：树与二叉树遍历方法的对应关系（2019）  

树的遍历是指用某种方式访问树中的每个结点，且仅访问一次。主要有两种方式  

1）先根遍历。若树非空，则按如下规则遍历  

先访问根结点。  

再依次遍历根结点的每棵子树，遍历子树时仍遵循先根后子树的规则。  

其遍历序列与这棵树相应二叉树的先序序列相同  

2）后根遍历。若树非空，则按如下规则遍历：  

先依次遍历根结点的每棵子树，遍历子树时仍遵循先子树后根的规则  

再访问根结点。  

其遍历序列与这棵树相应二叉树的中序序列相同。  

图5.23的树的先根遍历序列为ABEFCDG，后根遍历序列为EFBCGDA。另外，树也有层次遍历，与二叉树的层次遍历思想基本相同，即按层序依次访问各结点。  

# 2.森林的遍历  

按照森林和树相互递归的定义，可得到森林的两种遍历方法。  

1）先序遍历森林。若森林为非空，则按如下规则遍历：访问森林中第一棵树的根结点。先序遍历第一棵树中根结点的子树森林  
先序遍历除去第一棵树之后剩余的树构成的森林。2）中序遍历森林。森林为非空时，按如下规则遍历：中序遍历森林中第一棵树的根结点的子树森林。访问第一棵树的根结点。中序遍历除去第一棵树之后剩余的树构成的森林。图5.24的森林的先序遍历序列为ABCDEFGHI，中序遍历序列为BCDAFEHIG。  

命题追踪森林与二叉树遍历方法的对应关系（2020）  

当森林转换成二叉树时，其第一棵树的子树森林转换成左子树，剩余树的森林转换成右子树，可知森林的先序和中序遍历即为其对应二叉树的先序和中序遍历。  

树和森林的遍历与二叉树的遍历关系见表5.1。  

表5.1树和森林的遍历与二叉树遍历的对应关系
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2e09d57af01729d539d610a7b2227fbf31fc318099d9e73cd036ab8262b4e34b.jpg)  

# 注意  

部分教材也将森林的中序遍历称为后序遍历，称中序遍历是相对其二叉树而言的，称后序遍历是因为根确实是最后才访问的，若遇到这两种称谓，则可理解为同一种遍历方法。  



# 5.5树与二叉树的应用  

# 5.5.1哈夫曼树和哈夫曼编码  

# 1.哈夫曼树的定义  

在介绍哈夫曼树之前，先介绍几个相关的概念：  

从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径。路径上的分支数目称为路径长度。  

在许多应用中，树中结点常常被赋予一个表示某种意义的数值，称为该结点的权。从树的根到一个结点的路径长度与该结点上权值的乘积，称为该结点的带权路径长度。树中所有叶结点的带权路径长度之和称为该树的带权路径长度，记为  

$$
\mathrm{WPL}=\sum_{i=1}^{n}w_{i}l_{i}
$$  

式中， $w_{i}$ 是第 $i$ 个叶结点所带的权值， $l_{i}$ 是该叶结点到根结点的路径长度。  

在含有 $n$ 个带权叶结点的二叉树中，其中带权路径长度（WPL）最小的二叉树称为哈夫曼树，也称最优二叉树。例如，图5.25中的3棵二叉树都有4个叶结点 $a,b,c,d,$ 分别带权7，5.2.4，它们的带权路径长度分别为  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a2d32313c261c37c12b5a28af99468dcb1c7b5e3580b6b57a99efff0cd38d3e9.jpg)  
图5.25具有不同带权长度的二叉树  

(a)  $\mathrm{WPL}=7\times2+5\times2+2\times2+4\times2=36\,\circ$  (b)  $\mathrm{WPL}=4{\times}2+7{\times}3+5{\times}3+2{\times}1=46{\circ}$  (C)  $\mathrm{WPL}=7\times1+5\times2+2\times3+4\times3=35\,\mathrm{s}$  

其中，图5.25（c）树的WPL最小。可以验证，它恰好为哈夫曼树。  

# 2.哈夫曼树的构造  

给定 $n$ 个权值分别为 $w_{1},w_{2},\cdots,w_{n}$ 的结点，构造哈夫曼树的算法描述如下：1）将这 $n$ 个结点分别作为 $n$ 棵仅含一个结点的二叉树，构成森林 $F$  

>#### pro：分析哈夫曼树的路径上权值序列的合法性（2010）  

2）构造一个新结点，从 $F$ 中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和。3从 $F$ 中删除刚才选出的两棵树，同时将新得到的树加入 $F$ 中。4）重复步骤2）和3），直至 $F$ 中只剩下一棵树为止。  

>#### pro：哈夫曼树的性质（2010、2019）  

从上述构造过程中可以看出哈夫曼树具有如下特点：  

1）每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大。2）构造过程中共新建了 $n\!-\!1$ 个结点（双分支结点），因此哈夫曼树的结点总数为2n-1。3）每次构造都选择2棵树作为新结点的孩子，因此哈夫曼树中不存在度为1的结点。例如，权值7.5.2.41的哈夫曼树的构造过程如图5.26所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/de9a695e33dd97c1c5ed46237ca55e6881724f902b983ec04e5940d6658f255e.jpg)  
图5.26哈夫曼树的构造过程  

# 3.哈夫曼编码  

在数据通信中，若对每个字符用相等长度的二进制位表示，称这种编码方式为固定长度编码。若充许对不同字符用不等长的二进制位表示，则这种编码方式称为可变长度编码。可变长度编码比固定长度编码要好得多，其特点是对频率高的字符赋以短编码，而对频率较低的字符则赋以较长一些的编码，从而可以使字符的平均编码长度减短，起到压缩数据的效果。  
>#### pro：根据哈夫曼编码对编码序列进行译码（2017）  

若没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码。举例：设计字符A，B和C对应的编码0.10和110是前缀编码。对前缀编码的解码很简单，因为没有一个编码是其他编码的前缀。所以识别出第一个编码，将它翻译为原字符，再对剩余的码串执行同样的解码操作。例如，码串0010110可被唯一地翻译为A，A，B和C。另举反例：若再将字符D的编码设计为11，此时11是110的前缀，则上述码串的后三位就无法唯一翻译。  

>#### pro：哈夫曼树的构造及相关的分析（2012、2018、2021、2023）  

>#### pro：前缀编码的分析及应用（2014、2020）  

可以利用二叉树来设计二进制前缀编码。假设为A，B，C，D四个字符设计前缀编码，可以用图5.27所示的二叉树来表示，4个叶结点分别表示4个字符，且约定左分支表示0，右分支表示1，从根到叶结点的路径上用分支标记组成的序列作为该叶结点字符的编码，可以证明如此得到的必为前缀编码。由图5.27得到字符A，B，C，D的前缀编码分别为0,10,110，111。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/530f7170ceac82b45e179b32785be7d95fda0363a9e6cd3d08e5994f85b9d240.jpg)  
图5.27前缀编码示例  

>#### pro：哈夫曼编码和定长编码的差异（2022）  

哈夫曼编码是一种非常有效的数据压缩编码。由哈夫曼树得到哈夫曼编码是很自然的过程。首先，将每个字符当作一个独立的结点，其权值为它出现的频度（或次数），构造出对应的哈夫曼树。然后，将从根到叶结点的路径上分支标记的字符串作为该字符的编码。图5.28所示为一个由哈夫曼树构造哈夫曼编码的示例，矩形方块表示字符及其出现的次数。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/72a3cdbcb2f74e6a103772e7474ffec4f31c43dfd93f72e47a7066a5d3c31e44.jpg)  
图5.28由哈夫曼树构造哈夫曼编码  

这棵哈夫曼树的WPL为  

$$
\mathrm{WPL}=1\times45+3\times(13+12+16)+4\times(5+9)=224
$$  

此处的WPL可视为最终编码得到二进制编码的长度，共224位。若采用3位固定长度编码，则得到的二进制编码长度为300位，因此哈夫曼编码共压缩了 $25\%$ 的数据。利用哈夫曼树可以设计出总长度最短的二进制前缀编码。  
# 注意  

左分支和右分支究竞是表示0还是表示1没有明确规定，因此构造出的哈夫曼树并不唯一，但各哈夫曼树的带权路径长度WPL相同且为最优。此外，如有若干权值相同的结点，则构造出的哈夫曼树更可能不同，但WPL必然相同且为最优。  

# 5.5.2并查集  

# 1.并查集的概念  

并查集是一种简单的集合表示，它支持以下3种操作：  

1）Initial（S）：将集合s中的每个元素都初始化为只有一个单元素的子集合。2）Union（S，Rootl，Root2）：s Root 2 Root l。要求Root1和Root2互不相交，否则不执行合并。3）Find $(\mathbf{S},\mathbf{x})$ ：查找集合S中单元素 $_\mathrm{x}$ 所在的子集合，并返回该子集合的根结点。  

# 2.并查集的存储结构  

通常用树的双亲表示作为并查集的存储结构，每个子集合以一棵树表示。所有表示子集合的树，构成表示全集合的森林，存放在双亲表示数组内。通常用数组元素的下标代表元素名，用根结点的下标代表子集合名，根结点的双亲域为负数（可设置为该子集合元素数量的相反数）。  

例如，若设有一个全集合为 $S=\{0,1,2,3,4,5,6,7,8,9\}$ ，初始化时每个元素自成一个单元素子集合，每个子集合的数组值为-1，如图5.29所示。  

$$
s(\odot\odot\odot)\odot(\odot)\odot(\odot)\odot(\odot)\odot(\odot)
$$  

$$
\begin{array}{c c c c c c}{{0}}&{{1}}&{{2}}&{{3}}&{{4}}&{{5}}&{{6}}&{{7}}&{{8}}&{{9}}\\ {{\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid}}\end{array}
$$  

经过一段时间的计算后，这些子集合合并为3个更大的子集合，即 $S_{1}=\{0,6,7,8\},\ S_{2}=\{1,4,9\}$  $S_{3}=\{2,3,5\}$ ，此时并查集的树形和存储结构如图5.30所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/976fcd63eca493385976fd301e1a61e3edcd3c536650dac7f9a30aab44ed41e1.jpg)  
图5.30用树表示并查集  

为了得到两个子集合的并，只需将其中一个子集合根结点的双亲指针指向另一个集合的根结点。因此， $S_{1}\cup S_{2}$ 可以具有如图5.31所示的表示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5aac5c13895f1d4c8124a715052fb3f5ae623c11d1fa4e7e3de6ae02a965ce4c.jpg)  
图5.31 $S_{1}\cup S_{2}$ 可能的表示方法  
在采用树的双亲指针数组表示作为并查集的存储表示时，集合元素的编号从0到SIZE-1。其中SIZE是最大元素的个数。  

# 3.并查集的基本实现  

并查集的结构定义如下：  

下面是并查集主要运算的实现  

（1）并查集的初始化操作  

void Initial(int S[l){I/s即为并查集for(int $\scriptstyle{\dot{\mathbf{1}}}=0$ ;i<SIZE; $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$ /每个自成单元素集合S  $:[\dot{\mathbf{\Delta}}]=-1$  

（2）并查集的Find操作  

在并查集S中查找并返回包含元素 $_\mathrm{x}$ 的树的根  

int Find（int S[l,int x）{ while( $\mathrm{~S~}[\mathrm{x}]\!>=\!0$ /循环寻找 $_\mathrm{x}$ 的根 $\scriptstyle{\mathrm{z=S}}\,[\mathrm{x}]$  return x; /根的S[]小于0  

判断两个元素是否属于同一集合，只需分别找到它们的根，再比较根是否相同即可。  

（3）并查集的Union操作  

求两个不相交子集合的并集。若将两个元素所在的集合合并为一个集合，则需要先找到两个元素的根，再令一棵子集树的根指向另一棵子集树的根。  

void Union（int S[],int Rootl，int Root2）{ if（Root1 $==$ Root2)return;//要求Root1与Root2是不同的集合S[Root2] $=$ Rootl;/将根Root2连接到另一根Root1下面  

Find操作和Union操作的时间复杂度分别为 $O(d)$ 和 $O(1)$ ，其中 $d$ 为树的深度。  

# 4.并查集实现的优化  

在极端情况下， $n$ 个元素构成的集合树的深度为 $n$ ，则Find操作的最坏时间复杂度为 $O(n)$ 改进的办法是：在做Union操作之前，首先判别子集中的成员数量，然后令成员少的根指向成员多的根，即把小树合并到大树，为此可令根结点的绝对值保存集合树中的成员数量。  

（1）改进的Union操作  

void Union（int S[],int Rootl,int Root2）{ if(Rootl  $==$  Root2)return; if(S[Root2]>S[Root1]){//Root2结点数更少S[Rootl] $+{=}\mathbb{S}$ [Root2];/累加集合树的结点总数S[Root2] $=$ Rootl;1/小树合并到大树elsel //Root1结点数更少 S[Root2] $\scriptstyle{+=S}$ [Rootl];/累加结点总数S[Root1] $=$ Root2;1小树合并到大树  

$\log_{2}\!n\!\left\rfloor+1$  随着子集逐对合并，集合树的深度越来越大，为了进一步减少确定元素所在集合的时间，还可进一步对上述Find操作进行优化，当所查元素 $_\mathrm{x}$ 不在树的第二层时，在算法中增加一个“压缩路径”的功能，即将从根到元素 $_\mathrm{x}$ 路径上的所有元素都变成根的孩子。  
（2）改进的Find操作  

int Find（int s[l,int x）int root  $=\times$  while(s[root] $>=0$ //循环找到根root  $=$  s[root]; while（x!=root){//压缩路径int $\scriptstyle{\mathrm{t}}=\mathrm{S}\,[\mathrm{x}\,]$ /指向 $_\mathrm{x}$ 的父结点S[x] $=$ root; $//\mathrm{x}$ 直接挂到根结点下面 $\scriptstyle{\mathrm{x}=\mathrm{t}}$  return root;/返回根结点编号  

通过Find操作的“压缩路径”优化后，可使集合树的深度不超过 $O(\alpha(n))$ ，其中 $\alpha(n)$ 是一个增长极其缓慢的函数，对于常见的正整数 $n$ ，通常 $\alpha(n){\leqslant}4$  


# 归纳总结  

本章的内容较多，其中二叉树是极其重要的考查点。关于二叉树的有关操作，在2014年的统考中首次出现了线性表以外的算法设计题，需要引起读者的注意。  

遍历是二叉树的各种操作的基础，统考时会考查遍历过程中对结点的各种其他操作，而且容易结合递归算法和利用栈或队列的非递归算法。读者需重点掌握各种遍历方法的代码书写，并学会在遍历的基础上，进行一些其他的相关操作。其中递归算法短小精悍，出现的概率较大，请读者不要掉以轻心，要做到对几种遍历方式的程序模板烂熟于心，并结合一定数量的习题，才可以在考试中快速地写出漂亮的代码。  

二叉树遍历算法的递归程序：  

void Track（BiTree \*p）{ if(p!  $=$  NULL)I (1) Track(p->lchild); 1/(2）Track(p->rchild); 1(3)  

访问函数visit（）位于（1）、（2）、（3）的位置，分别对应于先序、中序、后序遍历。但对于具体题目来说，设计算法时要灵活应用。请读者认真练习下面的例题。  

例题：设二叉树的存储结构为二叉链表，编写有关二叉树的递归算法。  

1）统计二叉树中度为1的结点个数。2）统计二叉树中度为2的结点个数。3）统计二叉树中度为0的结点个数。4）统计二叉树的高度。5）统计二叉树的宽度。6）从二叉树中删去所有叶结点。7）计算指定结点 ${}^{\star}\mathtt{P}$ 所在的层次。8）计算二叉树中各结点中的最大元素的值。  

9）交换二叉树中每个结点的两个子女。  

10）以先序次序输出一颗二叉树中所有结点的数据值及结点所在的层次。  

# 思维拓展  

输入一个整数data和一棵二元树。从树的根结点开始往下访问一直到叶结点，所经过的所有结点形成一条路径。打印出路径及与data相等的所有路径。例如，输入整数22和下图所示的二元树，则打印出两条路径1012和10，5，7。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/941f06790d07c3ba3849267e4edafa0ff0976cce9578e4bd627251e1fa3c5cf8.jpg)  

提示：使用数组或栈保存访问的路径，并记录当前路径上所有元素的和Sum。若当前结点为叶结点，且当前结点值与sum的和等于data，则满足条件，打印当前路径。然后递归返回到父结点，注意在递归返回之前要先减去当前结点元素的值。使用前序遍历操作的递归算法模板可以简化程序。  