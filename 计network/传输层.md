# 第5章传输层  

## 【考纲内容】  

（一）传输层提供的服务传输层的功能：传输层寻址与端口：无连接服务和面向连接服务（二）UDPUDP数据报：UDP检验（三）TCPTCP段：TCP连接管理：TCP可靠传输：TCP流量控制与拥塞控制  

## 【复习提示】  

传输层是整个网络体系结构中的关键层次。要求掌握传输层在计算机网络中的功能、工作方式及原理等，掌握UDP及TCP（如首部格式、可靠传输、流量控制、拥塞控制、连接管理等）。其中，TCP报文分析、连接管理、流量控制与拥塞控制机制，出选择题、综合题的概率均较大，因此要将其工作原理透彻掌握，以便能在具体的题目中灵活运用。  

# 传输层提供的服务  

## 传输层的功能  

数据链路层提供链路上相邻结点之间的逻辑通信，网络层提供主机之间的逻辑通信。传输层位于网络层之上、应用层之下，它为运行在不同主机上的进程之间提供逻辑通信。传输层属于面向通信部分的最高层，同时也是用户功能中的最低层。显然，即使网络层协议不可靠（网络层协议使分组去失、混乱或重复），传输层同样能为应用程序提供可靠的服务。  

从图5.1可看出，网络的边缘部分的两台主机使用网络的核心部分的功能进行端到端的通信时，只有主机的协议栈才有传输层，而路由器在转发分组时都只用到下三层的功能（即在通信子网中没有传输层，传输层只存在于通信子网以外的主机中）。传输层的功能如下。  

### 应用进程之间的逻辑通信  

从网络层来说，通信的双方是两台主机，IP数据报的首部给出了这两台主机的IP地址。但“两台主机之间的通信”实际上是两台主机中的应用进程之间的通信。应用进程之间的通信又称端到端的逻辑通信。IP协议虽然能把分组送到自的主机，但这个分组还停留在主机的网络层，而没有交付给主机中的进程。从传输层来看，通信的真正端点不是主机而是主机中的进程  
### 复用和分用  

复用是指发送方不同的应用进程都可以使用同一个传输层协议传送数据。分用是指接收方的传输层在剥去报文的首部后能够把这些数据正确交付到目的应用进程。  

>##### attention:  

网络层也有复用和分用的功能，但网络层的复用是指发送方不同协议的数据都可被封装成IP数据报发送出去，分用是指接收方的网络层在剥去首部后把数据交付给相应的协议。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/63d78670549561819a300f6b9fc62e30df373cce7e510de756f34b967bc87bb0.jpg)  
图5.1传输层为相互通信的进程提供逻辑通信  

### 检错检测  

传输层要对收到的报文（首部和数据部分）进行差错检测。对于TCP协议，若接收方发现报文段出错，则要求发送方重发该报文段。对于UDP协议，若接收方发现数据报出错，则直接丢弃。在网络层，IP数据报首部中的检验和字段只检验首部是否出错，而不检查数据部分。  

### 提供面向连接和无连接的传输协议  

传输层向高层用户屏蔽了低层网络核心的细节（如网络拓扑、路由协议等），它使应用进程看见的是在两个传输层实体之间好像有一条端到端的逻辑通信信道，这条逻辑通信信道对上层的表现却因传输层协议不同而有很大的差别。当传输层采用面向连接的TCP协议时，尽管下面的网络是不可靠的（只提供尽最大努力的服务），但这种逻辑通信信道就相当于一条全双工的可靠信道。但当传输层采用无连接的UDP协议时，这种逻辑通信信道仍然是一条不可靠信道。  

而网络层无法同时实现两种协议（即在网络层要么只提供面向连接的服务，如虚电路；要么只提供无连接服务，如数据报，而不可能在网络层同时存在这两种方式）。  

## 传输层的寻址与端口  

### 端口的作用  

端口能让应用层的各种进程将其数据通过端口向下交付给传输层，以及让传输层知道应当将其报文段中的数据向上通过端口交付给应用层相应的进程。端口在传输层的作用类似于IP地址在网络层的作用，只不过IP地址标识的是主机，而端口标识的是主机中的应用进程。  
数据链路层的服务访问点为顿的“类型”字段，网络层的服务访问点为IP数据报的“协议”字段，传输层的服务访问点为“端口号”字段，应用层的服务访问点为“用户界面”。  

在协议栈层间的抽象的协议端口是软件端口，它与路由器或交换机上的硬件端口是完全不同的概念。硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与传输实体进行层间交互的一种地址。传输层使用的是软件端口。  

### 端口号  

应用进程通过端口号进行标识，端口号长度为16比特，能够表示65536 $(2^{16}$ ）个不同的端口号。端口号只其有本地意义，即端口号只标识本计算机应用层中的各进程，在因特网中不同计算机的相同端口号是没有联系的。根据端口号范围可将端口分为两类：  

1）服务器端使用的端口号。它又分为两类，最重要的一类是熟知端口号，数值为 $\sim\!1023$ IANA（互联网地址指派机构）把这些端口号指派给了TCP/IP最重要的一些应用程序，让所有的用户都知道。另一类称为登记端口号，数值为 $1024\!\sim\!49151$ ，它是供没有熟知端口号的应用程序使用的，使用这类端口号必须在IANA登记，以防止重复。一些常用的熟知端口号如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e1544960964df4d9da3367ec224ca92c1bb3a1058ebde23539b5c5d0aa0c544a.jpg)  

2）客户端使用的端口号，数值为 $49152\!\sim\!65535$ 。因为这类端口号仅在客户进程运行时才动态地选择，所以又称短暂端口号。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的端口号，因而可以把数据发送给客户进程。通信结束后，刚用过的客户端口号就不复存在，这个端口号就可以供其他客户进程使用。  

### 套接字  

在网络中通过IP地址来标识和区别不同的主机，通过端口号来标识和区分一台主机中的不同应用进程，端口号拼接到IP地址即构成套接字（Socket）。在网络中采用发送方和接收方的套接字来识别端点。套接字，实际上是一个通信端点，即  

它唯一地标识网络中的一台主机上的一个应用进程。  

在网络通信中，主机A发给主机B的报文包含目的端口号和源端口号，源端口号是“返回地址”的一部分，即当主机B需要发回一个报文给主机A时，主机B到主机A的报文中的目的端口号便是主机A到主机B的报文中的源端口号（完全的返回地址是主机A的IP地址和源端口号）  

## 无连接服务与面向连接服务  

TCP/IP协议族在IP层之上使用了两个传输协议：一个是面向连接的传输控制协议（TCP），采用TCP时，传输层向上提供的是一条全双工的可靠逻辑信道；另一个是无连接的用户数据报协议（UDP），采用UDP时，传输层向上提供的是一条不可靠的逻辑信道。  

TCP提供面向连接的可靠服务，通信双方在传送数据之前必须先建立连接，然后基于此连接进行可靠数据传输，数据传输结束后要释放连接。TCP不提供广播或多播服务。TCP为了实现可靠数据传输，就必须增加许多措施，如确认、流量控制、计时器及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。因此TCP主要适用于可靠性更重要的场合，如文件传输协议（FTP）、超文本传输协议（HTTP）、远程登录（TELNET）等。  

UDP提供无连接的不可靠服务，通信双方在传送数据之前不需要建立连接，接收方的传输层在收到UDP用户数据报后，无须给发送方发回任何确认。UDP在IP层之上仅提供两个附加服务：多路复用和对数据的错误检查。IP层知道怎样把分组投递给一台主机，但不知道怎样把它们投递给主机上的具体应用。UDP在传送数据之前不需要先建立连接，远程主机的传输层收到UDP报文后，不需要给出任何确认。因为UDP比较简单，所以执行速度比较快、实时性好。使用UDP的应用主要包括小文件传送协议（TFTP）、DNS、SNIMP和实时传输协议（RTP）。  
表5.1所示为一些典型互联网应用所用的TCP/IP应用层协议和传输层协议。  

表5.1一些典型互联网应用所用的TCP/IP应用层协议和传输层协议
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/31e145544e04ef12547e4868bcdfac5ddf5c7a417aa2b6348a1ff3570218580d.jpg)  

>##### attention:  

I)IP数据报和UDP数据报的区别：IP数据报在网络层要经过路由器的存储转发；而UDP数据报在传输层的端到端的逻辑信道中传输，封装成IP数据报在网络层传输时，UDP数据报的信息对路由器是不可见的。  

2）TCP和网络层虚电路的区别：TCP报文段在传输层抽象的逻辑信道中传输，对路由器不可见；虚电路所经过的交换结点都必须保存虚电路状态信息。在网络层若采用虚电 路方式，则无法提供无连接服务；而传输层采用TCP不影响网络层提供无连接服务。  


# UDP 协议  

## UDP数据报  

1.UDP概述  

UDP仅在IP层的数据报服务之上增加了两个最基本的功能：复用和分用，以及差错检测。  
若应用开发者选择UDP而非TCP，则应用程序几乎直接与IP打交道。为什么应用开发者宁愿在UDP之上构建应用，也不选择TCP？既然TCP提供可靠的服务，而UDP不提供，则TCP总是首选吗？答案是否定的，因为有很多应用更适合用UDP，主要因为UDP具有如下优点：  

>#### pro：UDP协议的特点（2014）  

1）UDP无须建立连接。因此UDP不会引入建立连接的时延。试想若DNS运行在TCP而非UDP上，则DNS的速度会慢很多。HTTP使用TCP而非UDP，是因为对于基于文本数据的Web网页来说，可靠性是至关重要的。2）无连接状态。TCP需要在端系统中维护连接状态。此连接状态包括接收和发送缓存、拥塞控制参数和序号与确认号的参数。而UDP既不维护连接状态，也不跟踪这些参数。因此，当某些专用服务器使用UDP时，一般都能支持更多的活动客户机。3）UDP的首部开销小。TCP有20B的首部开销，而UDP仅有8B的开销。4）UDP没有拥塞控制，因此网络中的拥塞不会影响源主机的发送速率。某些实时应用要求源主机以稳定的速率发送数据，能容忍一些数据的丢失，但不允许有太大的时延。5）UDP支持一对一、一对多、多对一和多对多的交互通信。  

UDP常用于一次性传输较少数据的网络应用，如DNS、SNMP等，因为对于这些应用，若采用TCP，则将为连接创建、维护和拆除带来不小的开销。UDP也常用于多媒体应用（如IP电 话、实时视频会议、流媒体等），显然，可靠数据传输对这些应用来说并不是最重要的，但TCP的拥塞控制会导致数据出现较大的延迟，这是它们不可容忍的。  

UDP不保证可靠交付，但这并不意味着应用对数据的要求是不可靠的，所有维护可靠性的工作可由用户在应用层来完成。应用开发者可根据应用的需求来灵活设计自己的可靠性机制。  

UDP是面向报文的。发送方UDP对应用层交下来的报文，在添加首部后就向下交付给IP层，一次发送一个报文，既不合并，也不拆分，而是保留这些报文的边界；接收方UDP对IP层交上来UDP数据报，在去除首部后就原封不动地交付给上层应用进程，一次交付一个完整的报文。因此报文不可分割，是UDP数据报处理的最小单位。因此，应用程序必须选择合适大小的报文，若报文太长，UDP把它交给IP层后，可能会导致分片：若报文太短，UDP把它交给IP层后，会使IP数据报的首部的相对长度太大，两者都会降低IP层的效率。  

### UDP的首部格式  

UDP数据报包含两部分：首部字段和用户数据字段。UDP首部有8B，由4个字段组成，每个字段的长度都是2B，如图5.2所示。各字段意义如下：  

>#### pro：UDP首部格式及各字段意义（2018）  

1）源端口。源端口号。在需要对方回信时选用，不需要时可用全0。2）目的端口。目的端口号。这在终点交付报文时必须使用到，  

>#### pro： UDP首部的长度（2021)  

3）长度。UDP数据报的长度（包括首部和数据），其最小值是8（仅有首部）。4）检验和。检测UDP数据报在传输中是否有错。有错就丢弃。该字段是可选的，当源主机不想计算检验和时，则直接令该字段为全0。当传输层从IP层收到UDP数据报时，就根据首部中的目的端口，把UDP数据报通过应的端口，上交最后的终点一一应用进程，如图5.3所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/da63d7c9b93503146918383294c5c15589fdbdc37358c5de93970ddb49063021.jpg)  
图5.2UDP数据报格式  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a16cc2056a05a15b10c395b7339bc3ac5fd58814468389f9a0015024fd2be756.jpg)  
图5.3UDP基于端口的分用  

若接收方UDP发现收到的报文中的自的端口号不正确（即不存在对应于端口号的应用进程），则就丢弃该报文，并由ICMP发送“端口不可达”差错报文给发送方。  

## UDP检验  

在计算检验和时，要在UDP数据报之前增加12B的伪首部，伪首部并不是UDP的真正首部。只是在计算检验和时，临时添加在UDP数据报的前面，得到一个临时的UDP数据报。检验和就是按照这个临时的UDP数据报来计算的。伪首部既不向下传送又不向上递交，而只是为了计算检验和。图5.4给出了UDP数据报的伪首部各字段的内容。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/05fa857d9ae050353446295e04e96bef0c74167c8553e5cf4439dd5c06e12f8d.jpg)  
图5.4UDP数据报的首部和伪首部  

UDP计算检验和的方法和计算IP数据报首部检验和的方法相似。不同的是：IP数据报的检验和只检验IP数据报的首部，但UDP的检验和要将首部和数据部分一起检验。  

UDP计算检验和的方法：发送方首先把全O放入检验和字段并添加伪首部，然后把UDP数据报视为许多16位的字串接起来。若UDP数据报的数据部分不是偶数个字节，则要在末尾填入一个全0字节（但此字节不发送）。然后按二进制反码计算出这些16位字的和，将此和的二进制反码写人检验和字段，并发送。接收方把收到的UDP数据报加上伪首部（若不为偶数个学节，则还需要补上全0字节）后，按二进制反码求这些16位字的和。当无差错时其结果应为全1，否则就表明有差错出现，接收方就应该去弃这个UDP数据报。  

图5.5给出了一个计算UDP检验和的例子。本例中，UDP数据报的长度是15B（不含伪首部），因此需要添加一个全0字节。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9a474cc8b394cdcf814dda506d8775a8ef67f54081079a382c666e8607f4cb96.jpg)  
图5.5计算UDP检验和的例子  

>##### attention:  

1）检验时，若UDP数据报部分的长度不是偶数个字节，则需填入一个全0字节，如图5.5所示。但是此字节和伪首部一样，是不发送的。  

2）若UDP检验和检验出UDP数据报是错误的，则可以丢弃，也可以交付给上层，但是需要附上错误报告，即告诉上层这是错误的数据报  

3）通过伪首部，不仅可以检查源端口号、目的端口号和UDP用户数据报的数据部分，还可以检查IP数据报的源IP地址和目的地址。  

这种简单的差错检验方法的校错能力并不强，但它的好处是简单、处理速度快。  
  

# TCP协议  

## TCP协议的特点  

TCP是在不可靠的IP层之上实现的可靠的数据传输协议，它主要解决传输的可靠、有序、无丢失和不重复问题。TCP是TCP/IP体系中非常复杂的一个协议，主要特点如下：  

1）TCP是面向连接的传输层协议，TCP连接是一条逻辑连接。2）每一条TCP连接只能有两个端点，每一条TCP连接只能是一对一的。3）TCP提供可靠交付的服务，保证传送的数据无差错、不丢失、不重复且有序。4）TCP提供全双工通信，允许通信双方的应用进程在任何时候都能发送数据，为此TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。发送缓存用来暂时存放以下数据： $\textcircled{\scriptsize{1}}$ 发送应用程序传送给发送方TCP准备发送的数据： $\circledcirc$ TCP已发送但尚未收到确认的数据。接收缓存用来暂时存放以下数据： $\textcircled{\scriptsize{1}}$ 按序到达但尚未被接收应用程序读取的数据： $\circledcirc$ 不按序到达的数据。5）TCP是面向字节流的，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但  

TCP把应用程序交下来的数据仅视为一连串的无结构的字节流。  

TCP和UDP在发送报文时所采用的方式完全不同。UDP报文的长度由发送应用进程决定，而TCP报文的长度则根据接收方给出的窗口值和当前网络拥塞程度来决定。若应用进程传送到TCP缓存的数据块太长，则TCP就把它划分得短一些再传送；若太短，则TCP也可等到积累足够多的字节后再构成报文段发送出去。关于TCP报文的长度问题，后面会详细讨论。  

## TCP报文段  

TCP传送的数据单元称为报文段。TCP报文段既可以用来运载数据，又可以用来建立连接、释放连接和应答。一个TCP报文段分为首部和数据两部分，整个TCP报文段作为IP数据报的数据部分封装在IP数据报中，如图5.6所示。其首部的前20B是固定的。TCP首部最短为20B，后面有 $4N$ 字节是根据需要而增加的选项，长度为4B的整数倍。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4f25e5e7af600a926e06cfbeecdb4d247bc24f97f4e1b6d8267cb4459a094260.jpg)  
图5.6TCP报文段  

TCP的全部功能体现在其首部的各个字段中，各字段意义如下：  

>#### pro：TCP报文段首部中各字段的分析（2012）  

1）源端口和目的端口。各占2B。分别表示发送方和接收方使用的端口号。  

>#### pro：TCP首部中序号、确认号的含义（2009、2016）  

2）序号。占4B，范围为 $0{\sim}2^{32}\!-\!1$ ，共 $2^{32}$ 个序号。TCP连接中传送的字节流中的每个字节都要按顺序编号，序号字段值指的是本报文段所发送的数据的第一个字节的序号。例如，一报文段的序号字段值是301，而携带的数据共有100B，表明本报文段的数据的最后一个字节的序号是400，因此下一个报文段的数据序号应从401开始。  

3）确认号。占4B，是期望收到对方下一个报文段的第一个数据字节的序号。若确认号为 $N,$ 则表明到序号 $N\!-\!1$ 为止的所有数据都已正确收到。  

例如，B正确收到了A发送过来的一个报文段，其序号字段是501，而数据长度是200B（序号 $501{\sim}700)$ ，这表明B正确收到了A发送的到序号700为止的数据。因此B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701。  

>#### pro：TCP首部的最小长度（2021)  

4）数据偏移（即首部长度）。占4位，这里不是1IP数据报分片的那个数据偏移，而是表示首部长度（首部中还有长度不确定的选项字段），它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。“数据偏移”的单位是32位（以4B为计算单位）。因为4位二进制数能表示的最大值为15，所以TCP首部的最大长度为 $60\mathrm{B}$  

5）保留。占6位，保留为今后使用，但目前应置为0。  

6）紧急位URG。当 $\mathrm{{URG}}\!=\!1$ 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送（相当于高优先级的数据）。紧急数据被插入到报文段数据的最前面，而  
在紧急数据后面的数据仍是普通数据，因此要与首部中的紧急指针字段配合使用。  

7）确认位ACK。仅当 $\mathrm{ACK}\!=\!1$ 时确认号字段才有效。当 $\mathrm{ACK}\!=\!0$ 时，确认号无效。TCP规定，在连接建立后所有传送的报文段都必须把ACK置1。  

8）推送位PSH（Push）。两个应用进程进行交互式通信时，都希望在键入一个命令后立即就能收到对方的响应，此时发送方TCP把PSH置1，接收方TCP收到 $\mathrm{PSH}\!=\!1$ 的报文段后，就尽快交付给接收应用进程，而不再等到整个缓存都填满了后再向上交付。  

9）复位位RST（Reset）。当 $\mathrm{RST}\!=\!1$ 时，表示TCP连接中出现严重差错（如主机崩溃等），必须释放连接，然后重新建立传输连接。此外，它还可用于拒绝一个非法的报文段。  

IU）位DIIN。= $\mathrm{{SYN}}\!=\!1$ 时衣小达定一十迁按请水或迁按按文报义。  

当 $\mathrm{{SYN}}\!=\!1$ ， $\scriptstyle\mathrm{ACK}\,=\,0$ 时，表明这是一个连接请求报文，若对方同意建立连接，则应在响应报文中使用 $\mathrm{{SYN}}\!=\!1$ ， $\mathrm{ACK}\!=\!1$ 。关于连接的建立和释放，下一节会详细讨论。  

11）终止位FIN（Finish）。用来释放一个连接。当 $\mathrm{FIN}\!=\!1$ 时，表明此报文段的发送方的数据已发送完毕，并要求释放传输连接。  

12）窗口。占2B，范围为 $0{\sim}2^{16}\mathrm{-}1$ 。窗口值告诉对方，从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。接收方的数据缓存空间是有限的，因此窗口值作为接收方让发送方设置其发送窗口的依据。例如，设确认号是701，窗口字段是1000。这表明，从701号算起，发送此报文段的一方还有接收1000字节数据（字节序号为 $701\!\sim\!1700$ ）的接收缓存空间。  

13）检验和。占2B。检验和字段检验的范围包括首部和数据两部分。在计算检验和时，和UDP一样，要在TCP报文段的前面加上12B的伪首部（只需将UDP伪首部的协议字段的17改成6，UDP长度字段改成TCP长度，其他的和UDP一样）。  

14）紧急指针。占2B。紧急指针仅在 $\mathrm{{URG}}\!=\!1$ 时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据在报文段数据的最前面）。也就是说，使窗口为零也可以发送紧急数据。  

15）选项。长度可变，最长可达 $40\mathrm{B}$ 。当不使用选项时，TCP首部长度是20B。TCP最初只规定了一种选项，即最大报文段长度（Maximum Segment Size，MSS）。MSS是TCP报文段中的数据字段的最大长度（注意仅仅是数据字段）。  

16）填充。这是为了使整个首部长度是4B的整数倍。  

## TCP连接管理  

TCP是面向连接的协议，因此每个TCP连接都有三个阶段：连接建立、数据传送和连接释放。TCP连接的管理就是使运输连接的建立和释放都能正常进行。  

在TCP连接建立的过程中，要解决以下三个问题：  

1）要使每一方能够确知对方的存在。  

2）要允许双方协商一些参数（如最大窗口值、是否使用窗口扩大选项、时间戳选项等）。  

TCP把连接作为最基本的抽象，每条TCP连接有两个端点，TCP连接的端点不是主机，不是主机的IP地址，不是应用进程，也不是传输层的协议端口。TCP连接的端口即为套接字（Socket），每一条TCP连接唯一地被通信的两个端点（即两个套接字）所确定。还应注意：同一个IP地址可以有多个不同的TCP连接，而同一个端口号也可以出现在多个不同的TCP连接中。TCP连接的建立采用客户/服务器模式。主动发起连接建立的应用进程称为客户（Client），而被动等待连接建立的应用进程称为服务器（Server）。  
### TCP连接的建立  

连接的建立经历以下3个步骤，通常称为“三次握手”，如图5.7所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f3d6b28ee03e01ed9257ed21d0c6482a0056ae9c32f87658dd9c210a0ae313ca.jpg)  
图5.7用“三次握手”建立TCP连接  

连接建立前，服务器处于LISTEN（收听）状态，等待客户的连接请求。命题追踪TCP连接建立的报文段中各字段的分析（2011、2012、2016、2019）  

第一步：客户机的TCP首先向服务器的TCP发送连接请求报文段。这个报文段的首部中的同步位 $\mathrm{{SYN}}\!=\!1$ ，同时选择一个初始序号 ${\mathrm{secq}}\!=\!x$ TCP规定，SYN报文段不能携带数据，但要消耗掉一个序号。这时，客户机进入SYN-SENT（同步已发送）状态。  

第二步：服务器的TCP收到连接请求报文段后，如同意建立连接，则向客户机发回确认，并为该TCP连接分配缓存和变量。在确认报文段中，把SYN位和ACK位都置1，确认号是 $\operatorname{ack}\!=\!x\!+1$ 同时也为自己选择一个初始序号 ${\mathrm{setminus}}=y$ 。注意，确认报文段不能携带数据，但也要消耗掉一个序号。这时，服务器进入SYN-RCVD（同步收到）状态。  

第三步：当客户机收到确认报文段后，还要向服务器给出确认，并为该TCP连接分配缓存和变量。确认报文段的ACK位置1，确认号 $\mathsf{a c k}\!=\!y^{+}\,!$ ，序号 ${\mathrm{sep}}\!=\!x+1$ 。该报文段可以携带数据，若不携带数据则不消耗序号。这时，客户机进入ESTABLISHED（已建立连接）状态。  

当服务器收到来自客户机的确认后，也进入ESTABLISHED状态。  

成功进行以上三步后，就建立了TCP连接，接下来就可以传送应用层数据。TCP提供的是全双工通信，因此通信双方的应用进程在任何时候都能发送数据。  

### TCP连接的释放  

天下没有不散的筵席，TCP同样如此。参与TCP连接的两个进程中的任何一个都能终止该连接。TCP连接释放的过程通常称为“四次挥手”，如图5.8所示。  

第一步：客户机打算关闭连接时，向其TCP发送连接释放报文段，并停止发送数据，主动关闭TCP连接，该报文段的终止位FIN置1，序号 ${\mathrm{setminus}}\!=\!u$ ，它等于前面已传送过的数据的最后一个字节的序号加1，FIN报文段即使不携带数据，也要消耗掉一个序号。这时，客户机进入FIN-WAIT-1（终止等待1）状态。TCP是全双工的，即可以想象为一条TCP连接上有两条数据通路，发送FIN的一端不能再发送数据，即关闭了其中一条数据通路，但对方还可以发送数据。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/55b5809743209b4220cf1a6af47b8f0bad83f3d69d445b181caa5341bfaaae47.jpg)  
图5.8用“四次挥手”释放TCP连接  

第二步：服务器收到连接释放报文段后即发出确认，确认号a $\mathrm{z}\!\stackrel{}{_{=}}\!u+1$ ，序号 ${\mathfrak{s e q}}\!=\!v$ ，等于它前面已传送过的数据的最后一个字节的序号加1。然后服务器进入CLOSE-WAIT（关闭等待）状态。此时，从客户机到服务器这个方向的连接就释放了，TCP连接处于半关闭状态。但服务器若发送数据，客户机仍要接收，即从服务器到客户机这个方向的连接并未关闭。客户机收到来自服务器的确认后，进入FIN-WAIT-2（终正等待2）状态，等待服务器发出的连接释放报文段。  

>#### pro：TCP连接释放过程中状态的变化（2021）  

第三步：若服务器已经没有要向客户机发送的数据，就通知TCP释放连接，此时，其发出 $\mathrm{FIN}\!=\!1$ 的连接释放报文段。设该报文段的序号为 $w$ （处于半关闭状态的服务器可能又发送了一些数据），还必须重复发送上次已发送的确认号 $\operatorname{ack}\!=\!u\!+1$ 。这时服务器进入LAST-ACK（最后确认）状态。  

>#### pro：TCP连接释放的过程及状态变化的时间分析（2016、2022）  

第四步：客户机收到连接释放报文段后，必须发出确认，之后进入TIME-WAIT（时间等待）状态。该报文段的确认位ACK置1，确认号 $\operatorname{ack}\!=\!w+1$ ，序号 $\scriptstyle{\mathrm{seq}}\,=\,u\,+\,1$ 。服务器收到该确认报文段后就进入CLOSED（连接关闭）状态。客户机进入TIME-WAIT状态后，还要经过时间等待计 2 MSL（Maximum Segment Lifetime，最长报文段寿命）后，才进入CLOSED状态。若服务器收到连接释放请求后不再发送数据，则从客户机发出FIN报文段时刻算起，客户机释放连接的最短时间为 $1\,\mathrm{RTT}+2\,\mathrm{MSL}$ ，服务器释放连接的最短时间为1.5RTT。  

除时间等待计时器外，TCP还设有一个保活计时器。设想TCP双方已建立连接，但后来客户主机突然出现故障。显然，服务器以后就不能再收到客户发来的数据。因此，应当有措施使服务器不要再白白等待下去，这个问题就可以使用保活计时器来解决。  
对上述TCP连接建立和释放的总结如下：  

1）建立连接。分为3步： $\textcircled{\scriptsize{1}}$   $)\,\mathrm{{SYMN}}\!=\!1$   ${\mathrm{secq}}\!=\!x$   $\begin{array}{r}{\mathrm{(\mathcal{Q})\;S Y N=1,\;\;A C K=1,\;\;s e q=}y,\;\;\mathrm{ack}=x+1\;\mathrm{s}}\end{array}$   $(\!)\operatorname{ACK}\,{=}\,1\,,\,\,\,\operatorname{neq}\,{=}\,x\,{+}\,1\,,\,\,\,\operatorname{ack}\,{=}\,y\,{+}\,1\,.$  

2）释放连接。分为4步  

$\begin{array}{r}{\mathrm{\bf(\mathbb{D})\;F I N}\!=\!1\,,\;\;\mathrm{seq}\!=\!u\!\circ}\end{array}$   $\operatorname{(2)ACK}=1\,,\;\;\operatorname{neq}=\nu\,,\;\;\operatorname{ack}=u+1\,.$   $(\!)\operatorname{FIN}\,{=}\,1\,,\,\,\,\operatorname{ACK}\,{=}\,1\,,\,\,\,\operatorname{sq}\,{=}\,w\,,\,\,\,\operatorname{ack}\,{=}\,u\,{+}\,1\,.$   $(\!4\!)\operatorname{ACK}\,{=}\,1\,,\,\,\,\operatorname{neq}\,{=}\,u\,{+}\,1\,,\,\,\,\operatorname{ack}\,{=}\,w\,{+}\,1\,.$  

选择题喜欢考查（关于连接建立和释放的题目，ACK、SYN、FIN都等于1），请牢记。  

## TCP可靠传输  

TCP在不可靠的IP层之上建立一种可靠数据传输服务。TCP提供的可靠数据传输服务保证接收方从缓存区读出的字节流与发送方发出的字节流完全一样。TCP使用了检验、序号、确认和重传等机制来达到这一目的。其中，TCP的检验机制与UDP一样，这里不再赘述。  

命题追踪TCP的确认机制，序号和确认号的含义（2011、2012、2013）  

1.序号  

TCP首部的序号字段用来保证数据能有序提交给应用层，TCP把数据视为一个无结构但有序的字节流，序号建立在传送的字节流之上，而不建立在报文段之上。  

TCP连接传送的数据流中的每个字节都编上一个序号。序号字段的值是指本报文段所发送的数据的第一个字节的序号。如图5.9所示，假设A和B之间建立了一条TCP连接，A的发送缓存区中共有10B，序号从0开始标号，第一个报文段包含第 $_{0\sim2}$ 个字节，则该TCP报文段的序号是0，第二个报文段的序号是3。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c26ac704f59eca3c51a2c5c371f1336b60b64260c34e4d2227d63e9f9712d1c8.jpg)  
图5.9A的发送缓存区中的数据划分成TCP段  

2.确认  

TCP首部的确认号是期望收到对方的下一个报文段的数据的第一个字节的序号。在图5.9中，若接收方B已收到第一个报文段的数据，此时B希望收到的下一个报文段的数据是从第3个字节开始的，则B发送给A的报文段中的确认号字段应为3。发送方缓存区会继续存储那些已发送但未收到确认的报文段，以便在需要时重传。  

TCP默认使用累积确认，即TCP只确认数据流中至第一个丢失字节为止的字节。例如，在图5.9中，接收方B收到了A发送的包含字节 $_{0\sim2}$ 及字节 $6\!\sim\!7$ 的报文段。由于某种原因，B还未收到字节3～5的报文段，此时B仍在等待字节3（和其后面的字节），因此B到A的下一个报文段将确认号字段置为3。  

### 重传  

有两种事件会导致TCP对报文段进行重传：超时和余ACK。  
#### （1）超时  

TCP每发送一个报文段，就对这个报文段设置一个超时计时器。计时器设置的重传时间到期但还未收到确认时，就要重传这一报文段。  

因为TCP的下层是互联网环境，IP数据报所选择的路由变化很大，所以传输层的往返时延的方差也很大。为了计算超时计时器的重传时间，TCP采用一种自适应算法，它记录一个报文段发出的时间，以及收到相应确认的时间，这两个时间之差称为报文段的往返时间（Round-TripTime，RTT）。TCP维护了RTT的一个加权平均往返时间RTTS，它会随新测量RTT样本值的变化而变化。显然，超时计时器设置的超时重传时间（RetransmissionTime-Out，RTO）应略大于RTTS，但也不能大太多，否则当报文段丢失时，TCP不能很快重传，导致数据传输时延大。  

#### （2）冗余ACK（冗余确认）  

超时触发重传存在的一个问题是超时周期往往太长。所幸的是，发送方通常可在超时事件发生之前通过注意所谓的冗余ACK来较好地检测丢包情况。冗余ACK就是再次确认某个报文段的ACK，而发送方先前已经收到过该报文段的确认。例如，发送方A发送了序号为1、2、3、4、5的TCP报文段，其中2号报文段在链路中丢失，它无法到达接收方B。因此3、4、5号报文段对于B来说就成了失序报文段。TCP规定每当比期望序号大的失序报文段到达时，就发送一个究余ACK，指明下一个期待字节的序号。在本例中，3、4、5号报文段到达B，但它们不是B所期望收到的下一个报文段，于是B就发送3个对1号报文段的余ACK，表示自己期望接收2号报文段。TCP规定当发送方收到对同一个报文段的3个究余ACK时，就可以认为跟在这个被确认报文段之后的报文段已经丢失。就前面的例子而言，当A收到对于1号报文段的3个究余ACK时，它可以认为2号报文段已经去失，这时发送方A可以立即对2号报文段执行重传，这种技术通常称为快速重传。当然，余ACK还被用在拥塞控制中，这将在后面的内容中讨论。  

## TCP流量控制  

流量控制的功能就是让发送方的发送速率不要太快，以便让接收方来得及接收，因此可以说流量控制是一个速度匹配服务（匹配发送方的发送速率与接收方的读取速率）。  

TCP利用滑动窗口机制来实现流量控制，滑动窗口的基本原理已在第3章中介绍过，这里要介绍的是TCP如何使用窗口机制来实现流量控制。TCP要求发送方维持一个接收窗口（rwnd），接收方根据当前接收缓存的大小，动态地调整接收窗口的大小，其大小反映了接收方的容量。接收方将其放在TCP报文段首部中的“窗口”字段，以通知发送方。发送方的发送窗口不能超过接收方给出的接收窗口值，以限制发送方向网络注入报文的速率。  

>#### pro：利用接收窗口实现流量控制的过程（2016、2021）  

图5.10说明了如何利用滑动窗口机制进行流量控制。假设数据只从A发往B，而B仅向A发送确认报文段，则B可通过设置确认报文段首部中的窗口字段来将rwnd通知给A。rwnd即接收方允许连续接收的能力，单位是字节。发送方A总是根据最新收到的rwnd值来限制自己发送窗口的大小，从而将未确认的数据量控制在rwnd大小之内，保证A不会使B的接收缓存溢出。设A向B发送数据，在连接建立时，B告诉A：“我的接收窗口rwnd $=400^{\circ}$ ”。接收方B进行了三次流量控制，这三个报文段都设置了 $\mathrm{ACK}\!=\!1$ ，只有在 $\mathrm{ACK}\!=\!1$ 时确认号字段才有意义。第一次把窗口减到rwnd $=300$ ，第二次又减到rwnd $=100$ ，最后减到rwnd $=\!0$ ，即不允许发送方再发送数据。这使得发送方暂停发送的状态将持续到B重新发出一个新的窗口值为止。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2ea4a8c799f964a7e96572594c00ed4f1536d705a7e0ede4d1ac19178b9e9412.jpg)  
图5.10利用可变窗口进行流量控制举例  

TCP为每个连接设有一个持续计时器，只要发送方收到对方的零窗口通知，就启动持续计时器。若计时器超时，就发送一个零窗口探测报文段，而对方就在确认这个探测报文段时给出现在的窗口值。若窗口仍然为零，则发送方收到确认报文段后就重新设置持续计时器。  

传输层和数据链路层的流量控制的区别是：传输层实现的是端到端，即两个进程之间的流量控制；数据链路层实现的是两个中间的相邻结点之间的流量控制。此外，数据链路层的滑动窗口协议的窗口大小不能动态变化，传输层的窗口大小则可以动态变化。  

## TCP拥塞控制  

拥塞控制是指防止过多的数据注入网络，保证网络中的路由器或链路不致过载。出现拥塞时，端点并不了解拥塞发生的细节，对通信的端点来说，拥塞往往表现为通信时延的增加。  

拥塞控制与流量控制的区别：拥塞控制是让网络能够承受现有的网络负荷，是一个全局性的过程，涉及所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是指点对点的通信量的控制，是个端到端的问题（接收端控制发送端），它所要做的是抑制发送端发送数据的速率，以便使接收端来得及接收。当然，拥塞控制和流量控制也有相似的地方，即它们都通过控制发送方发送数据的速率来达到控制效果。  

例如，某个链路的传输速率为 $10\mathrm{{Gb}}/s$ ，某大型机向一台PC以1Gb/s的速率传送文件，显然网络的带宽是足够大的，因而不存在拥塞问题，但如此高的发送速率将导致PC可能来不及接收，因此必须进行流量控制。但若有100万台PC在此链路上以1Mb/s的速率传送文件，则现在的问题就变为网络的负载是否超过了现有网络所能承受的范围。  

TCP进行拥塞控制的算法有四种：慢开始、拥塞避免、快重传和快恢复。  

发送方在确定发送报文段的速率时，既要考虑接收方的接收能力，又要从全局考虑不要使网络发生拥塞。因此，除了上节介绍的接收窗口，TCP还要求发送方维持一个拥塞窗口（cwnd），其大小取决于网络的拥塞程度，并且动态地变化。发送方控制拥塞窗口的原则：只要网络未出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去，以提高网络的利用率。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络的分组数，以缓解网络出现的拥塞。  

发送窗口的上限值应取接收窗口rwnd和拥塞窗口cwnd中较小的一个，即  
# 发送窗口的上限值  $=$  min[rwnd, cwnd]  

接收窗口的大小可根据TCP报文首部的窗口字段通知发送方，而发送方如何维护拥塞窗口呢？这就是下面讲解的慢开始和拥塞避免算法。这里假设：数据为单方向传送，对方只传送确认报文；接收方总是有足够大的缓存空间，因而发送窗口的大小由网络的拥塞程度决定。  

为了便于理解，下面采用最大报文段长度MSS作为拥塞窗口大小的单位。  

### 慢开始和拥塞避免  

#### （1）慢开始算法  

慢开始算法的思路是当发送方刚开始发送数据时，因为并不清楚网络的负荷情况，若立即把大量数据注入网络，则有可能引发网络拥塞。具体方法是：先发送少量数据探测一下，若没有发生拥塞，则适当增大拥塞窗口，即由小到大逐渐增大拥塞窗口（即发送窗口）。  

>#### pro：慢开始算法的实现过程（2014、2015）  

例如，A向B发送数据，发送方先令cwnd $=1$ ，即一个MSS。A发送第一个报文段，A收到B对第一个报文段的确认后，把cwnd从1增大到2。于是A接着发送两个报文段，A收到B对这两个报文段的确认后，把cwnd从2增大到4，下次就可一次发送4个报文段。  

慢开始的“慢”并不是指拥塞窗口cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd $=1$ ，使得发送方一开始向网络注入的报文段少（目的是试探一下网络的拥塞情况），然后逐渐增大cwnd，这对防止网络出现拥塞是一个非常有力的措施。使用慢开始算法后，每经过一个传输轮次（即往返时延RTT），cwnd就会加倍，即cwnd的值随传输轮次指数增长。为了防止cwnd增长过大而引起网络拥塞，还需要设置一个慢开始门限ssthresh（网值）。这样，当慢开始一直把cwnd增大到一个规定的ssthresh时，然后改用拥塞避免算法。  

#### （2）拥塞避免算法  

>#### pro：慢开始和拥塞避免算法的实现过程/慢开始门限的作用（2017、2020、2023）  

拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，具体做法是：每经过一个往返时延RTT就 把发送方的拥塞窗口cwnd加1，而不是加倍，使拥塞窗口cwnd按线性规律缓慢增长（即加法增大），这比慢升始算法的拥塞窗口增长速率要缓慢得多。  

根据cwnd的大小执行不同的算法，可归纳如下：  

当cwnd<ssthresh时，使用慢开始算法。当cwnd $>$ ssthresh时，停止使用慢开始算法而改用拥塞避免算法。当cwnd $=$ ssthresh时，既可使用慢开始算法，又可使用拥塞避免算法（通常做法）。  

（3）网络拥塞的处理  

无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（未按时收到确认），就要首先把慢开始门限ssthresh设置为出现拥塞时的发送方的cwnd值的一半（但不能小于2），然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的是迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完。  

>#### pro：慢开始和拥塞避免阶段的平均传输速率分析（2016、2023）  

慢开始和拥塞避免算法的实现过程举例如图5.11所示。初始时，拥塞窗口置为1，即cwnd $=1$ ，慢开始门限置为16，即ssthresh $=16$  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a1450fb7a0a2a7cbc01c8a1dcf0c026c45cb4c81db6c5a4ba5ff6ac97202f4bd.jpg)  
图5.11慢开始和拥塞避免算法的实现过程  

>#### pro：  

# 慢开始/拥塞避免阶段拥塞窗口的变化分析（2016、2023）  

慢开始阶段，发送方每收到一个对新报文段的确认ACK，就把拥塞窗口cwnd值加1，也即经过每个传输轮次（RTT），cwnd呈指数规律增长。当cwnd增长到慢开始门限ssthresh时（即当cwnd $=16$ 时），就改用拥塞避免算法，cwnd按线性规律增长。  

>#### pro：当网络超时时，慢开始和拥塞避免算法的实现过程（2009、2022）  

）当cwnd $=24$ 时，网络出现超时，调整ssthresh值为12（即为超时时cwnd值的一半），同时cwnd置为1，并执行慢开始算法，当cwnd $=12$ 时，改为执行拥塞避免算法。  

>##### attention:  

在慢开始阶段，若2cwnd $>$ ssthresh，RT T cw nd s s thresh,而不等于2cwnd。第16个轮次时cwnd $=8$ 、ssthresh $=12$ ，则第17个轮次时cwnd $=12$ ，而不等于16。  

在慢开始和拥塞避免算法中使用了“乘法减小”和“加法增大”方法。“乘法减小”是指不论是在慢开始阶段还是在拥塞避免阶段，只要出现超时（即很可能出现了网络拥塞），就把慢开始门限值ssthresh设置为当前拥塞窗口的一半（并执行慢开始算法）。当网络频繁出现拥塞时，ssthresh值就下降得很快，以大大减少注入网络的分组数。而“加法增大”是指执行拥塞避免算法后，在收到对所有报文段的确认后（即经过一个RTT），就把拥塞窗口cwnd增加一个MSS大小，使拥塞窗口缓慢增大，以防止网络过早出现拥塞。  

拥塞避免并不能完全避免拥塞。利用以上措施要完全避免网络拥塞是不可能的。拥塞避免是指在拥塞避免阶段把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。  

### 快重传和快恢复  

有时个别报文段会在网络中丢失，但实际上网络并未发生拥塞。若发送方迟迟收不到确认，就会产生超时，并误认为网络发生了拥塞，这就导致发送方错误地启动慢开始算法，从而降低传输效率。采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。  

#### （1）快重传  

>#### pro：快重传算法的原理、重传的时机（2019）  

快重传算法是使发送方尽快（尽早）进行重传，而不等超时计时器超时再重传。这就要求接收方不要等待自已发送数据时才进行捐带确认，而要立即发送确认，即使收到了失序的报文段也要立即发出对已收到报文段的重复确认。发送方一旦连续收到3个冗余ACK（即重复确认），就立即重传相应的报文段，而不等该报文段的超时计时器超时再重传。  
#### （2）快恢复  

快恢复算法的原理如下：当发送方连续收到3个允余ACK（重复确认）时，执行“乘法减小”方法，把慢开始门限ssthresh调整为当前cwnd的一半。这是为了预防网络发生拥塞。但发送方现在认为网络很可能没有发生（严重）拥塞，否则就不会有几个报文段连续到达接收方，也不会连续收到重复确认。因此与慢开始算法的不同之处是，它把cwnd值也调整为当前cwnd的一半（即等于ssthresh值），然后开始执行拥塞避免算法（“加法增大"），使拥塞窗口缓慢地线性增大。  

因为跳过了拥塞窗口cwnd从1起始的慢开始过程，所以被称为快恢复。快恢复算法的实现过程如图5.12所示，作为对比，虚线为慢开始的处理过程。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/62dd33f004450128a3f441728d804d8b3a69264acb169f32cceb123861070b61.jpg)  
图5.12快恢复算法的实现过程  

实际上，这四种算法同时应用在TCP拥塞控制机制中，它们使用的总结：在TCP连接建立和网络出现超时时，采用慢开始和拥塞避免算法（ssthresh $\b=$ cwnd/2，cwnd $=1$ )；当发送方收到3个冗余ACK时，采用快重传和快恢复算法（ssthresh $=$ cwnd/2，cwnd $=$ ssthresh)。  

在流量控制中，发送方发送数据的量由接收方决定；而在拥塞控制中，则由发送方自己通过检测网络状况来决定。再次提醒读者：接收方的缓存空间总是有限的。因此，发送方发送窗口的大小由流量控制和拥塞控制共同决定。当题目中同时出现接收窗口（rwnd）和拥塞窗口（cwnd）时，发送方发送窗口的实际大小是由rwnd和cwnd中较小的那一个确定的。  

 

# 本章小结及疑难点  

1.MSS设置得太大或太小会有什么影响？  

规定最大报文段长度MSS，并不是考虑接收方的缓存可能放不下TCP报文段中的数据。实际上，MSS与接收窗口没有关系。TCP报文段的数据部分，至少要加上4OB的首部（TCP首部至少20B和IP首部至少20B），才能组装成一个IP数据报。若选择较小的MSS值，网络的利用率就很低。设想在极端情况下，当TCP报文段只含有1B的数据时，在IP层传输的数据报的开销至少有40B（包括TCP首部和IP首部）。这样，网络的利用率就不会超过1/41。到了数据链路层还要加上一些开销，网络的利用率还会进一步降低。但反过来，若TCP报文段很长，则在IP层传输时有可能要分解成多个短数据报片。在终点还要把收到的各个短数据报片装配成原来的TCP报文段。当传输出错时，还要进行重传。这些也都会使开销增大。  

因此，MSS应尽可能大一些，只要在IP层传输时不要再分片就行。因为IP数据报所经历的路径是动态变化的，所以在一条路径上确定的不需要分片的MSS，若改走另一条路径，则可能需要进行分片。因此最佳的MSS是很难确定的。MSS的默认值为536B，因此在互联网上的所有主机都应能接受的报文段长度是 $536+20$ （TCP固定首部长度） $=556\mathrm{B}$  

2.TCP使用的是GBN还是选择重传？  

这是一个有必要弄清的问题。前面讲过，TCP使用累积确认，这看起来像是GBN的风格。但是，正确收到但失序的报文并不会丢弃，而是缓存起来，并且发送允余ACK指明期望收到的下一个报文段，这是TCP方式和GBN的显著区别。例如，A发送了 $N$ 个报文段，其中第 $k~(k<~N)$ 个报文段丢失，其余 $N{-}1$ 个报文段正确地按序到达接收方B。使用GBN时，A需要重传分组 $k$ ，以及所有后继分组 $k+1,k+2,\cdots,N$ 。相反，TCP却至多重传一个报文段，即报文段 $k$ 。另外，TCP中提供一个SACK（SelectiveACK）选项，即选择确认选项。使用选择确认选项时，TCP看起来就和SR非常相似。因此，TCP的差错恢复机制可视为GBN和SR协议的混合体。  
3.为什么超时事件发生时cwnd被置为1，而收到3个冗余ACK时cwnd减半？  

大家可以从如下角度考虑。超时事件发生和收到3个究余ACK，哪个意味看网络拥塞程度更严重？通过分析不难发现，在收到3个冗余ACK的情况下，网络虽然拥塞，但至少还有ACK报文段能被正确交付。而当超时发生时，说明网络可能已经拥塞得连ACK报文段都传输不了，发送方只能等待超时后重传数据。因此，超时事件发生时，网络拥塞更严重，发送方就应该最大限度地抑制数据发送量，所以cwnd置为1：收到3个冗余ACK时，网络拥塞不是很严重，发送方稍微抑制一下发送的数据量即可，所以cwnd减半。  

4.为什么不采用“两次握手”建立连接呢？  

这主要是为了防止两次握手情况下已失效的连接请求报文段突然又传送到服务器而产生错误。考虑下面这种情况。客户A向服务器B发出TCP连接请求，第一个连接请求报文在网络的某个结点长时间滞留，A超时后认为报文丢失，于是再重传一次连接请求，B收到后建立连接。数据传输完毕后双方断开连接。而此时，前一个滞留在网络中的连接请求到达服务器B，而B认为A又发来连接请求，此时若使用“三次握手”，则B向A返回确认报文段，因为是一个失效的请求，所以A不予理踩，建立连接失败。若采用的是“两次握手”，则这种情况下B认为传输连接已经建立，并一直等待A传输数据，而A此时并无连接请求，因此不予理踩，这样就造成了B的资源白白浪费。  

5.为什么TCP在建立连接时不能每次都选择相同的、固定的初始序号？  

1）假定主机A和B频繁地建立连接，传送一些TCP报文段后，再释放连接，然后又不断地建立新的连接、传送报文段和释放连接。2）假定每次建立连接时，主机A都选择相同的、固定的初始序号，如选择1。3）假定主机A发出的某些TCP报文段在网络中会滞留较长时间，以致主机A超时重传这些TCP报文段。4）假定有一些在网络中滞留时间较长的TCP报文段最后终于到达主机B，但这时传送该报文段的那个连接早已释放，而在到达主机B时的TCP连接是一条新的TCP连接。  

这样，工作在新的TCP连接的主机B就有可能会接收在旧的连接传送的、已无意义的、过时的TCP报文段（因为这个TCP报文段的序号有可能正好处在当前新连接所用的序号范围之中），结果产生错误。因此，必须使得迟到的TCP报文段的序号不处在新连接所用的序号范围之中。  

这样，TCP在建立新的连接时所选择的初始序号一定要和前面的一些连接所用过的序号不同。因此，不同的TCP连接不能使用相同的初始序号。  

6.假定在一个互联网中，所有链路的传输都不出现差错，所有结点也都不会发生故障。试问在这种情况下，TCP的“可靠交付”功能是否就是多余的？  

不是多余的。TCP的“可靠交付”功能在互联网中起着至关重要的作用。至少在以下的情况下，TCP的“可靠交付”功能是必不可少的。  
1）每个IP数据报独立地选择路由，因此在到达目的主机时有可能出现失序。2）由于路由选择的计算出现错误，导致IP数据报在互联网中转圈。最后数据报首部中的生存时间（TTL）的数值下降到零。这个数据报在中途就被丢失。3）某个路由器突然出现很大的通信量，以致路由器来不及处理到达的数据报。因此有的数据报被丢弃。以上列举的问题表明：必须依靠TCP的“可靠交付”功能才能保证在目的主机的目的进程中收到正确的报文。  