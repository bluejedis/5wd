# above 

## 【考纲内容】  

（一）数制与编码进位计数制及其相互转换；定点数的编码表示  

（二）运算方法和运算电路  

基本运算部件：加法器：算术逻辑单元（ALU）加/减运算：补码加/减运算器：标志位的生成乘/除运算：乘/除法运算的基本原理：乘法电路和除法电路的基本结构  

（三）整数的表示和运算  

无符号整数的表示和运算：有符号整数的表示和运算  

（四）浮点数的表示和运算  

浮点数的表示：IEEE754标准：浮点数的加/减运算  

## 【复习提示】  

本章内容较为繁杂，由于计算机中数的表示和运算方法与人们日常生活中的表示和运算方法不同，因此理解也较为困难。纵观历年统考真题，unsigned、short、int、long、float、double等在C语言中的表示、运算、溢出判断、隐式类型转换、强制类型转换、IEEE754浮点数的表示以及浮点数的运算，都是考研考查的重点，需要牢固掌握。  

在学习本章时，请读者思考以下问题：  

1）在计算机中，为什么要采用二进制来表示数据？2）计算机在字长足够的情况下能够精确地表示每个数吗？若不能，请举例说明3）字长相同的情况下，浮点数和定点数的表示范围与精度有什么区别？  

请读者在本章的学习过程中寻找答案，本章末尾会给出参考答案。  

# 0数制与编码  

## 进位计数制及其相互转换  

>#### pro：采用二进制编码的原因（2018）  

在计算机系统内部，所有信息都是用二进制进行编码的，这样做的原因有以下几点。1）二进制只有两种状态，使用有两个稳定状态的物理器件就可以表示二进制数的每一位，  
制造成本比较低，例如用高低电乎或电荷的正负极性都可以很方便地表示0和1。  

2）二进制位1和0正好与逻辑值“真”和“假”相对应，为计算机实现逻辑运算和程序中的逻辑判断提供了便利条件。3）二进制的编码和运算规则都很简单，通过逻辑门电路能方便地实现算术运算。  

##### 进位计数法  

常用的进位计数法有十进制、二进制、八进制、十六进制等。十进制数是日常生活中最常使用的，而计算机中通常使用二进制数、八进制数和十六进制数。  

在进位计数法中，每个数位所用到的不同数码的个数称为基数。十进制的基数为 $10\ (0{\sim}9)$ 每个数位计满10就向高位进位，即“逢十进一”。十进制数101，其个位的1显然与百位的1所表示的数值是不同的。每个数码所表示的数值等于该数码本身乘以一个与它所在数位有关的常数，这个常数称为位权。一个进位数的数值大小就是它的各位数码按权相加。  

一个 $r$ 进制数（ $K_{n}K_{n-1}...K_{0}K_{-1}...K_{-m}$ ）的数值可表示为  

$$
K_{n}r^{n}+K_{n-1}r^{n-1}+\dots+K_{0}r^{0}+K_{-1}r^{-1}+\dots+K_{-m}r^{-m}=\sum_{i=n}^{-m}K_{i}r^{i}
$$  

式中， $r$ 是基数； $r^{j}$ 是第 $i$ 位的位权； $K_{i}$ 的取值可以是 $0,1,\cdots,r-1$ 共 $r$ 个数码中的任意一个。  

1）二进制。计算机中用得最多的是基数为2的计数制，即二进制。二进制只有0和1两种数码，计数“逢二进一”。它的任意数位的权为 $2^{i},\textit{i}$ 为所在位数。2）八进制。基数为8，有 $_{0\sim7}$ 共8个不同的数码。计数逢八进一。因为 $r\!=\!8\!=\!2^{3}$ ，所以把二进制中的3位数码编为一组就是1位八进制数码，两者之间的转换极为方便。3）十六进制。基数为16，有 $_{0\sim9}$ 、A～F共16个不同的数码，其中 $\scriptstyle\mathrm{A}\sim\operatorname{F}$ 分别表示 $10{\sim}15$ 计数逢十六进一。因为 $r\!=\!16\!=\!2^{4}$ ，所以4位二进制数码与1位十六进制数码相对应。  

可以用后缀字母标识一个数的进位计数制，用B表示二进制，用O表示八进制，用D表示十进制（通常直接省略），用H表示十六进制，有时也用前缀0x表示十六进制数。  

##### 不同进制数之间的相互转换  

（1）二进制数转换为八进制数和十六进制数  

对于一个二进制混合数（既包含整数部分，又包含小数部分），在转换时应以小数点为界。其整数部分，从小数点开始往左数，将一串二进制数分为3位（八进制）一组或4位（十六进制）一组，在数的最左边可根据需要加“0”补齐；对于小数部分，从小数点开始往右数，也将一串二进制数分为3位一组或4位一组，在数的最右边也可根据需要加“0”补齐。最终使总的位数为3或4的整数倍，然后分别用对应的八进制数或十六进制数取代。  

【例2.1】将二进制数1111000010.01101分别转换为八进制数和十六进制数。  

解：  

高位补0，凑足3位分界点低位补0，凑足3位↓ ↓ ↓ 001 111 000 010 011 010  

所以，对应的八进制数为 $(1702.32)_{8}\!=\!(1111000010.01101)_{2}\!\circ$  

所以，对应的十六进制数为 $(3C2.68)_{16}\!=\!(1111000010.01101)_{2}.$  
同样，由八进制数或十六进制数转换为二进制数，只需将每位改为3位或4位二进制数即可（必要时去掉整数最高位或小数最低位的0）。八进制数和十六进制数之间的转换也能方便地实现，十六进制数转换为八进制数（或八进制数转换为十六进制数）时，先将十六进制（八进制）数转换为二进制数，然后由二进制数转换为八进制（十六进制）数较方便。  

（2）任意进制数转换为十进制数  

将任意进制数的各位数码与它们的权值相乘，再把乘积相加，就得到了一个十进制数。这种方法称为按权展开相加法。例如， $(11011.1)_{2}\!=\!1\!\times\!2^{4}+1\!\times\!2^{3}+0\!\times\!2^{2}+1\!\times\!2^{1}+1\!\times\!2^{0}+1\!\times\!2^{-1}\!=\!27.5.$  

（3）十进制数转换为任意进制数  

>#### pro：十进制小数转换为二进制小数（2021、2022）  

一个十进制数转换为任意进制数，通常采用基数乘除法。这种转换方法对十进制数的整数部分和小数部分将分别进行处理，对整数部分采用除基取余法，对小数部分采用乘基取整法，最后将整数部分与小数部分的转换结果拼接起来。  

>#### 【例2.2】将十进制数123.6875转换成二制数。  

解：  

除基取余法（整数部分）：整数部分除基取余，最先取得的余数为数的最低位，最后取得的余数为数的最高位（即除基取余，先余为低，后余为高），商为0时结束。  

整数部分：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/196d6836af60c957474613cc5ddd3a50ef583549c205aab5dacf92ff151c2a8d.jpg)  

因此整数部分 $123\,{=}\,(1111011)_{2},$  

乘基取整法（小数部分）：小数部分乘基取整，最先取得的整数为数的最高位，最后取得的整数为数的最低位（即乘基取整，先整为高，后整为低），乘积为1.0（或满足精度要求）时结束。  

小数部分：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/54b7b8f03f6b150f058aee1bb6d9ab852907ade2d8ae065083cd2a78b401736d.jpg)  

因此小数部分 $0.6875\!=\!(0.1011)_{2}$ ，所以 $123.6875\!=\!(1111011.1011)_{2}.$  

>#### 注意  

关于十进制数转换为任意进制数为何采用除基取余法和乘基取整法，以及所取之数放置位置的原理，请结合 $r$ 进制数的数值表示公式思考，而不应死记硬背。  
>#### 注意  

在计算机中，小数和整数不一样，整数可以连续表示，但小数是离散的，所以并不是每个十进制小数都可以准确地用二进制表示。例如0.3，无论经过多少次乘二取整转换都无法得到精确的结果。但任意一个二进制小数都可以用十进制小数表示，希望读者引起重视。  

## 定点数的编码表示  

### 真值和机器数  

在日常生活中，通常用正号、负号来分别表示正数（正号可省略）和负数，如+15、 $^{-8}$ 等。这种带“ $^+$ ”或“-”符号的数称为真值。真值是机器数所代表的实际值。  

在计算机中，通常将数的符号和数值部分一起编码，将数据的符号数字化，通常用“0”表示“正”，用“1”表示“负”。这种把符号“数字化”的数称为机器数。常用的有原码、补码和反码表示法。如0,101（这里的逗号“”仅为区分符号位与数值位）表示 $^{+5}$  

### 机器数的定点表示  

根据小数点的位置是否固定，在计算机中有两种数据格式：定点表示和浮点表示。在现代计算机中，通常用补码整数表示整数，用原码小数表示浮点数的尾数部分，用移码表示浮点数的阶码部分，历年统考真题的命题信息也主要落在这个范畴之内。  

定点表示法用来表示定点小数和定点整数。  

1）定点小数。定点小数是纯小数，约定小数点位置在符号位之后、有效数值部分最高位之前。若数据 $X$ 的形式为 $X=x_{0}.x_{1}x_{2}...x_{n}$ （其中 $x_{0}$ 为符号位， $x_{1}{\sim}x_{n}$ 是数值的有效部分，也称尾数， $x_{1}$ 为最高有效位），则在计算机中的表示形式如图2.1所示。  

2）定点整数。定点整数是纯整数，约定小数点位置在有效数值部分最低位之后。若数据 $X$ 的形式为 $X\,=\,x_{0}x_{1}x_{2}...x_{n}$ （其中 $x_{0}$ 为符号位， $x_{1}{\sim}x_{n}$ 是尾数， $x_{n}$ 为最低有效位)，则在计算机中的表示形式如图2.2所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4dd1fb5972f1ed936d1fc0ddfb38f8f045ee71a4c4d74334f59f8240e1e90456.jpg)  
图2.2定点整数表示  

事实上，在机器内部并没有小数点，只是人为约定了小数点的位置。因此，在定点数的编码和运算中不用考虑对应的定点数是小数还是整数，而只需关心它们的符号位和数值位即可。  

定点数的编码表示法主要有以下4种：原码、补码、反码和移码。  

### 原码、补码、反码、移码  

（1）原码表示法  

用机器数的最高位表示数的符号，其余各位表示数的绝对值。原码的定义如下。  

O,x, 0≤x<2" [x]原 =  $\cdot_{x}$  是真值，字长为  $n+1$  [2"-x=2"+[x], -2"<x≤0  

例如，若 $x_{1}\!=\!+1110$ ， $x_{2}\,{=}\,{-}1110$ ，字长为8位，则其原码表示为 $[x_{1}]_{\mathbb{R}}=\mathbf{0},$ 0001110, $[x_{2}]_{\mathbb{R}}=2^{7}+$  $1110=1,0001110$ ，其中最高位是符号位。  

若字长为 $n+1$ ，则原码整数的表示范围为- $\scriptstyle\cdot(2^{n}-1)\leqslant x\leqslant2^{n}-1$ （关于原点对称）。  
>#### 注意  

零的原码表示有正零和负零两种形式，即 $[+0]_{\#}=\mathbf{0}0000000$ 和[ $-0]_{\#}=10000000.$  

原码表示的优点： $\textcircled{\scriptsize{1}}$ 与真值的对应关系简单、直观，与真值的转换简单； $\circledcirc$ 用原码实现乘除运算比较简便。缺点： $_{\odot0}$ 的表示不唯一，有 $\pm0$ 两个编码； $\circledcirc$ 原码加减运算比较复杂。在原码加减运算中，对于两个不同符号数的加法（或同符号数的减法），先要比较两个数的绝对值大小，然后用绝对值大的数减去绝对值小的数，最后还要为结果选择合适的符号。  

（2）补码表示法  

补码表示法中的加减运算统一采用加法操作实现。正数的补码和原码相同，负数的补码等于模 $(n+1$ 位补码的模为 $2^{n+1}$ ）与该负数绝对值之差。补码的定义如下：  

$$
[x]_{\#}={\binom{0,x}{2^{n+1}+x=2^{n+1}-\left|x\right|}},\ \ -2^{n}\leqslant x<2^{n}{\pmod{2^{n+1}}}
$$  

综合上述定义可知，无论是正数还是负数， $[x]_{*}\!=\!2^{n+1}\!+x$  $-2^{n}\!\leqslant\!x\!<\!2^{n}$ ，mod $2^{n+1}$ )  

例如，若 $x_{1}\,{=}\,{+}1010$  $x_{2}\!=\!-1101$ ，字长为8位，则其补码表示为 $[x_{1}]_{*}\!=\!\mathbf{0}{,}0001010$ ， $[x_{2}]_{*}=2^{8}$  $0{,}0001101=1{,}1110011$  

>#### pro：补码的表示范围（2010、2013、2014、2022）若字长为 $n+1$ ，则补码整数的表示范围为 $-2^{n}\!\leqslant\!x\!\leqslant\!2^{n}\!-1$ （比原码多表示“ $"-2"$ ”）。  

·几个特殊数据的补码表示1) $[+0]_{*}\!=[-0]_{*}\!=0,\!00...0$ （含符号位共 $n+1$ 个0），说明0的补码表示是唯一的。2) $[-1]_{"}=2^{n+1}\!-\!1=1,\!11...1$ （含符号位共 $n+1$ 个1)。3） $[2^{n}\!-\!\!1]_{*}\!=0,11\dots1$ (n个1)，即 $n+1$ 位补码能表示的最大整数。4） $[-2^{\prime\prime}]_{*}\!=1,\!00...0$  $_{,n}$ 个0)，即 $n+1$ 位补码能表示的最小整数。  

·模运算  

在模运算中，一个数与它除以“模”后得到的余数是等价的，如A、B、 $M$ 满足 $A=B+K{\times}M$  $.K$ 为整数），则记为 $A\!\equiv\!B$ (mod $M)$ ，即 $A,\ B$ 各除以 $M$ 后的余数相同。在补码运算中， $[A]_{\#}-$  $[B]_{*}=[A]_{*}+M-[B]_{*}$ ，而 $M-[B]_{*}=[-B]_{*}$ ，因此补码可以借助加法运算来实现减法运算。  

补码与真值之间的转换  

>#### pro：补码和真值的相互转换（2020、2023）  

真值转换为补码：对于正数，与原码的方式一样。对于负数，符号位取1，其余各位由真值“各位取反，末位加1”得到。补码转换为真值：若符号位为0，与原码的方式一样。若符号位为1，真值的符号为负，数值部分各位由补码“各位取反，末位加1”得到。  

，变形补码  

变形补码是一种采用双符号位的补码表示，也称模4补码。假定变形补码的位数为 $n+1$ (其中符号位占2位，数值位占 $n-1$ 位），则整数变形补码的表示为  

$$
[x]_{\#\#}=\left\{\begin{array}{l l}{00,x,\qquad\qquad\qquad\qquad\quad0\leqslant x<2^{n-1}}\\ {2^{n+1}+x=2^{n+1}-\big|x\big|,\quad\;-2^{n-1}\leqslant x<0}\end{array}\;(\,\mathrm{mod}\,\,\,2^{n+1}\,)\right.
$$  

模4补码双符号位00表示正，11表示负，用在执行算术运算的ALU中。  
（3）反码表示法（了解）  

负数的补码可采用“各位取反，末位加1”的方法得到，若仅各位求反而末尾不加1，则是负数的反码表示，因此负数反码的定义就是在相应的补码表示中再末位减1。  

正数反码的定义和相应的补码（或原码）表示相同。  

反码表示存在以下几个方面的不足： $\textcircled{\scriptsize{1}}$ 0的表示不唯一（即存在 $\pm0$ )； $\circledcirc$ 表示范围比补码少一个最小负数。反码在计算机中很少使用，通常用作数码变换的中间表示形式。  

（4）移码表示法  

移码常用来表示浮点数的阶码，它只能表示整数。  

移码就是在真值 $X$ 上加上一个常数（偏置值），通常这个常数取 $2^{n}$ ，相当于 $X$ 在数轴上向正方向偏移了若干单位，这就是“移码”一词的由来。移码的定义如下。  

$[x]_{\#}\,=2^{n}+x$  $-2^{n}\leqslant x<2^{n}$ ，其中机器字长为 $n+1$  

例如，若正数 $x_{1}\,{=}\,{+}10101$  $x_{2}\!=\!-10101$ ，字长为8位，则其移码表示为 $[x_{1}]_{\#}\!=2^{7}\,+\,10101\!=1,$ 0010101; $[x_{2}]_{\mathrm{i}\mathrm{g}}\,{=}\,2^{7}\,{+}\,(-10101)\,{=}\,0$ ,1101011。  

移码具有以下特点：  

$\textcircled{\scriptsize{1}}$ 移码中零的表示唯一， $[+0]_{\#}=2^{n}+0=[-0]_{\#}=2^{n}-0=100...0$ （n个 $"0")$  

$\circledcirc$ 一个真值的移码和补码仅差一个符号位， $[x]_{\#}$ 的符号位取反即得 $[x]_{\theta}$ （“1”表示正，“ $0$  

表示负，这与其他机器数的符号位取值正好相反），反之亦然。  

$\circledast$ 移码全0时，对应真值的最小值 $-2^{n}$ ：移码全1时，对应真值的最大值 $2^{n}{-}1$  

$^{(4)}$ 移码保持了数据原有的大小顺序，移码大真值就大，移码小真值就小。  

原码、补码、反码和移码这4种编码表示的总结如下：  

>#### pro：补码大小的判断（2015）  

$\textcircled{\scriptsize{1}}$ 原码、补码、反码的符号位相同，正数的机器码相同。  

$\circledcirc$ 原码、反码的表示在数轴上对称，二者都存在 $_{+0}$ 和-0两个0。  

$\textcircled{3}$ 补码、移码的表示在数轴上不对称，零的表示唯一，它们比原码、反码多表示一个数。  

$\textcircled{4}$  整数的补码、移码的符号位相反，数值位相同。  

$\circledast$ 负数的补码、反码末位相差1。  

$^\mathrm{\textregistered}$ 原码很容易判断大小。而负数的补码、反码很难直接判断大小，可采用如下规则快速判  

断：对于负数，数值位部分越小，其绝对值越大，即负得越多。  

## 整数的表示  

### 无符号整数的表示  

>#### pro：机器码与补码、无符号数之间的转换（2021）  

当一个编码的全部二进制位均为数值位而没有符号位时，该编码表示就是无符号整数，简称无符号数。此时，默认数的符号为正。因为无符号整数省略了一位符号位，所以在字长相同的情况下，它能表示的最大数比有符号整数能表示的大。一般在全部是正数运算且不出现负值结果的场合下，使用无符号整数表示。例如，可用无符号整数进行地址运算，或用它来表示指针。  

例如，对于8位无符号整数，最小数为00000000（值为0），最大数为11111111（值为 $2^{8}\!-1\!=$ 255），即表示范围为 $_{0\sim255}$ ：而对于8位有符号整数，最小数为 $1000\ 0000$ （值为 $-2^{7}\!=-128)$ ，最大数为01111111（值为 $2^{7}\!-1=127)$ ），即表示范围为- $\cdot128\!\sim\!127$  
### 有符号整数的表示  

将符号数值化，并将符号位放在有效数字的前面，就组成了有符号整数。虽然前面介绍的原码、补码、反码和移码都可以用来表示有符号整数，但补码表示有其明显的优势：  

$\textcircled{\scriptsize{1}}$ 与原码和反码相比，0的补码表示唯一。  

$\textcircled{2}$ 与原码和移码相比，补码运算规则比较简单，且符号位可以和数值位一起参加运算。  

$\textcircled{3}$ 与原码和反码相比，补码比原码和反码多表示一个最小负数。  

计算机中的有符号整数都用补码表示，故 $n$ 位有符号整数的表示范围是 $-2^{n-1}{\sim}2^{n-1}$ -1。  

## C语言中的整数类型及类型转换  

统考大纲要求考生具有对高级程序设计语言（如C语言）中相关问题进行分析的能力，而C语言变量之间的类型转换是统考中经常出现的题目，需要读者深入掌握这一内容。  

### C语言中的整型数据类型  

>#### pro：int型数据的表示范围（2017、2019）  

C语言中的整型数据就是定点整数，根据位数的不同，可分为字符型（char，8位）、短整型（short或shortint，16位）、整型（int，32位）、长整型（long或longint，在32位机器中为32位，在64位机器中为64位）。char是整型数据中比较特殊的一种，其他如short/int/long等不指定signed/unsigned时都默认是有符号整数，但char默认是无符号整数。无符号整数（unsignedshort/int/long）的全部二进制位均为数值位，没有符号位，相当于数的绝对值。  

signed/unsigned整型数据都是按补码形式存储的，只是signed型的最高位代表符号位，而在unsigned型中表示数值位，因此这两者所表示的数据范围也有所不同。  

### 有符号数和无符号数的转换  

>#### pro：有符号数与无符号数的相互转换（2011、2016、2019）  

C语言允许在不同的数据类型之间做类型转换。强制类型转换格式为“TYPE $\boldsymbol{\mathrm{b}}\!=\!(\mathrm{TPE})$ a”，强制类型转换后，返回一个具有TYPE类型的数值，这种操作并不会改变操作数本身。  

先看由short型转换到unsignedshort型的情况。考虑如下代码片段：  

int main(){ short  $\mathrm{x}{=}{-}\,4321$  unsigned short  $\mathbb{Y}^{=}$  (unsigned short)x; printf(' $\scriptstyle{\mathrm{'}}_{\mathrm{X}}=\frac{9}{8}\mathrm{d}$ ， $\tt y=\tt S$ u\n"，x，y);  

有符号数 $_\mathrm{x}$ 是一个负数，而无符号数y的表示范围显然不包括x的值。  

在采用补码的机器上，上述程序会输出如下结果： $\texttt{x}=\,-4321$ ， $\texttt{y}=\ 61215$  

输出的结果中，得到的y值似乎与原来的x没有一点关系。不过将这两个数转换为二进制表示时，我们就会发现其中的规律，如表2.1所示。  

表2.1y与x的对比
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ea75c374ba8836e0e20e1d2fbf17389368b80728623490a6848a5ac33303d2d0.jpg)  
观察可知，将short型强制转换为unsignedshort型只改变数值，而两个变量对应的每位都是 一样的。通过本例可知，强制类型转换的结果是保持位值不变，仅改变了解释这些位的方式。  

再看由unsignedshort型转换到short型的情况。考虑如下代码片段：  

int main(）{ unsigned short  $\scriptstyle{\mathrm{x}=65535}$  short  $\mathtt{y}^{=}$  (short)x; printf $("x=\S u$ ， $\mathtt{y}{=}\mathtt{\frac{3}{6}}$ d\n"，x，y）；  

同样在采用补码的机器上，上述程序会输出如下结果：X=65535， $\texttt{y}=\texttt{-1}$  

把这两个数转换为二进制表示，同样可以证实之前的结论。因此，有符号数转换为等长的无符号数时，符号位解释为数值的一部分，负数转换为无符号数时数值将发生变化。同理，无符号数转换为有符号数时最高位解释为符号位，也可能发生数值的变化。  

>#### 注意  

若同时有无符号数和有符号数参与运算，则C语言标准规定按无符号数进行运算。  

### 不同字长整数之间的转换  

>#### pro：无符号数的零扩展（2012）  

另一种常见的运算是在不同字长的整数之间进行类型转换。  

先看大字长变量向小字长变量转换的情况。考虑如下代码片段：  

int main(）{ int  $_\mathrm{x=165537}$  ，  $\mathrm{u}{=}{-}34991$  //int型占用4B short  $\mathtt{y}^{=}$  (short)x,  $\scriptstyle{\mathbb{T}}=$  (short)u; //short型占用2B printf $("x=\S\,\mathrm{d}$ y=8d\n"，x，y）；printf $\scriptstyle{\mathcal{C}}^{\bullet}\cup=\mathrm{{s}}\,\mathrm{{d}}$  $\uptau=$ d\n”，u，v）;  

运行结果如下：  

$\texttt{x}=\texttt{165537}$ ， $\texttt{Y}=\,-31071$  $\mathrm{~u~}=\ -34991$ ， $\texttt{v}=\,30545$  

其中x,y，u,v的十六进制表示分别为0x000286al，0x86a1，0xfmf7751，0x7751，观察上述数字很容易得出结论，当大字长变量向小字长变量强制类型转换时，系统把多余的高位部分直接截断，低位部分直接赋值，因此也是一种保持位值的处理方法。  

再看小字长变量向大字长变量转换的情况。考虑如下代码片段：  

int main(){ short  $\mathrm{x}{=}{-}\,4321$  int  $\mathtt{y}^{=\mathtt{x}}$  unsigned short  $\mathrm{u}{=}$  (unsigned short)x; unsigned int  $\scriptstyle{\mathrm{even}}$  printf  $("x=\S\,\mathrm{d}$   $\mathtt{y}{=}\mathtt{\xi}$  d\n"，x，y）; printf  $\scriptstyle{"{\mathfrak{u}}={\mathfrak{s}}{\mathfrak{u}}}$   $\mathrm{v}{=}$  u\n",u，v）;  

运行结果如下：  

$\textsl{x}=\textsl{-4321}$ ， $\texttt{Y}=\texttt{--}4321$  $\mathrm{~u~}=~61215$ ， $\textsuperscript{v}=~61215$  
>#### pro：无符号数的零扩展（2012），补码的符号扩展（2021）  

x，y，u,v的十六进制表示分别为0xef1f0xffffeflf0xeflf0x0000ef1f。由本例可知，小字长到大字长的转换时，不仅要使相应的位值相等，还要对高位部分进行扩展。若原数字是无符号整数，则进行零扩展，扩展后的高位部分用0填充。否则进行符号扩展，扩展后的高位部分用原数字符号位填充。其实两种方式扩展的高位部分都可理解为原数字的符号位。这与之前的三个例子都不一样，从位值与数值的角度看，前三个例子的转换规则都是保证相应的位值相等，而小字长向大字长的转换，在位值相等的条件下还要补充高位的符号位，可以理解为数值的相等。注意，char型为8位无符号整数，其在转换为int型时高位补0即可。  


# 1运算方法和运算电路  

## 基本运算部件  

在计算机中，运算器由算术逻辑单元（ArithmeticLogicUnit，ALU）、移位器、状态寄存器（PSW）和通用寄存器组等组成。运算器的基本功能包括加、减、乘、除四则运算，与、或、非、异或等逻辑运算，以及移位、求补等操作。ALU的核心部件是加法器。  
### 带标志加法器  

无符号数加法器只能用于两个无符号数相加，不能进行有符号整数的加/减运算。为了能进行有符号整数的加/减运算，还需要在无符号数加法器的基础上增加相应的逻辑门电路，使得加法器不仅能计算和/差，还要能生成相应的标志信息。图23是带标志加法器的实现电路。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b08b1b2e0864197bdd1d72ef2052e0df883af964dc46d02ed1cabeaf47084dfc.jpg)  
图2.3用全加器实现 $n$ 位带标志加法器的电路  

在图2.3中，溢出标志的逻辑表达式为 ${\mathrm{OF}}=C_{n}\oplus C_{n-1}$ ：符号标志就是和的符号，即 $\mathrm{SF}=F_{n-1}$ 零标志 $\mathrm{ZF}=1$ 当且仅当 $F\!=\!0$ ：进位/借位标志 $\mathrm{CF}=C_{\mathrm{out}}\oplus C_{\mathrm{in}^{\mathrm{c}}}$  

### 算术逻辑单元（ALU）  

ALU是一种功能较强的组合逻辑电路，它能进行多种算术运算和逻辑运算。由于加、减、乘、除运算最终都能归结为加法运算，因此ALU的核心是带标志加法器，同时也能执行“与”“或”“非”等逻辑运算。ALU的基本结构如图2.4所示，其中 $A$ 和 $B$ 是两个 $n$ 位操作数输入端， $C_{\mathrm{in}}$ 是进位输入端，ALUop是操作控制端（发出控制信号），用来决定ALU所执行的处理功能。例如，ALUop选择Add运算，ALU就执行加法运算，输出的结果就是 $A$ 加 $B$ 之和。ALUop的位数决定了操作的种类。例如，当位数为3时，ALU最多只有8种操作。  

图2.5给出了能够完成3种运算“与”“或”和“加法”的一位ALU结构图。其中，一位加法用一个全加器实现，在ALUop的控制下，由一个多路选择器（MUX）选择输出3种操作结果之一。这里有3种操作，所以ALUop至少要有两位。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9cdde373a0e9aac54e8a3252d040b0625dc2982eaa7ffb7b834dd4a5f48a2d34.jpg)  
图2.4ALU的基本结构  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/446801d26dabb23d19fea7dea7846e8892b38051dc1408e8f16cf0921912b209.jpg)  
图2.5一位ALU的结构  

同时，ALU也可以实现左移或右移的移位操作。  
## 定点数的移位运算  

当计算机中没有乘/除法运算电路时，可以通过加法和移位相结合的方法来实现乘/除法运算。对于任意二进制整数，左移一位，若不产生溢出，相当于乘以2（与十进制数的左移一位相当于乘以10类似)；右移一位，若不考虑因移出而舍去的末位尾数，相当于除以2。  

根据操作数的类型不同，移位运算可以分为逻辑移位和算术移位。  

1.逻辑移位  

>#### pro：逻辑移位运算（2018）  

逻辑移位将操作数视为无符号整数。逻辑移位的规则：左移时，高位移出，低位补0；右移时，低位移出，高位补0。对于无符号整数的逻辑左移，若高位的1移出，则发生溢出。  

### 算术移位  

>#### pro：算术移位运算（2012、2017、2018）  

算术移位需要考虑符号位的问题，即将操作数视为有符号整数。  

计算机中的有符号整数都是用补码表示的，因此对于有符号整数的移位操作应采用补码算术移位方式。算术移位的规则：左移时，高位移出，低位补0，若移出的高位不同于移位后的符号位，即左移前后的符号位不同，则发生溢出；右移时，低位移出，高位补符号位，若低位的1移出，则影响精度。例如，补码1001和0101左移时会发生溢出，右移时会丢失精度。  

## 定点数的加减运算  

### 补码的加减法运算  

>#### pro：不同字长补码的加法运算（2009）、补码和无符号数的减法运算（2011、2017）  

补码加减运算规则简单，易于实现。补码加减运算的公式如下（设机器字长为 $n+1)$  $\begin{array}{r l}&{[A+B]_{*}=[A]_{*}+[B]_{*}\ (\bmod2^{n+1})}\\ &{[A-B]_{*}=[A]_{*}+[-B]_{*}\ (\bmod2^{n+1})}\end{array}$  

补码运算的特点如下。  

1）按二进制运算规则运算，逢二进一。2）若做加法，两个数的补码直接相加；若做减法，则将被减数与减数的负数补码相加。3）符号位与数值位一起参与运算，加、减运算结果的符号位也在运算中直接得出。4）最终运算结果的高位丢弃，保留 $_{n+1}$ 位，运算结果亦为补码。  

【例2.3】设字长为8位（含1位符号位）， $A=15$  $B=24$ ，求 $[A+B]*$ 和 $[A-B]*$ 解：  

$A=+15=+0001111$ ， $B=+24=+0011000$ ：得 $[A]_{*}\,{=}\,00001111$ ， $[B]_{*}\,{=}\,00011000$  

求得  $[-B]_{*}=11101000$  。所以  

$[A+B]_{*}=00001111+00011000=00100111$ 符号位为0，对应真值为 $+39$  $[A-B]_{*}=[A]_{*}+[-B]_{*}=00001111+1110\,1000=11110\,1111$ ，符号位为1，对应真值为-9。  

2.溢出判别方法  

>#### pro：补码加减运算后的溢出判断（2010、2011、2014、2018、2021）  

仅当两个符号相同的数相加或两个符号相异的数相减才可能产生溢出，如两个正数相加，而结果的符号位却为1（结果为负）；一个负数减去一个正数，结果的符号位却为0（结果为正）。  
补码定点数加减运算溢出判断的方法有3种。  

（1）采用一位符号位  

由于减法运算在机器中是用加法器实现的，因此无论是加法还是减法，只要参加操作的两个数的符号相同，结果又与原操作数的符号不同，则表示结果溢出。  

设 $A$ 的符号为 $A_{s}$ ， $B$ 的符号为 $B_{s}$ ，运算结果的符号为 $S_{s}$ ，则溢出逻辑表达式为  

$$
V=A_{\mathrm{s}}B_{\mathrm{s}}\overline{{S_{\mathrm{s}}}}+\overline{{A_{\mathrm{s}}B_{\mathrm{s}}}}S_{\mathrm{s}}
$$  

若 $V\!=\!0$ ，表示无溢出；若 $V\!=\!1$ ，表示有溢出。  

（2）采用双符号位  

双符号位法也称模4补码。运算结果的两个符号位 $S_{s1}S_{s2}$ 相同，表示未溢出：运算结果的两个符号位 $S_{s1}S_{s2}$ 不同，表示溢出，此时最高位符号位代表真正的符号。  

符号位 $S_{s1}S_{s2}$ 的各种情况如下  

$\textcircled{\scriptsize{1}}$  $S_{s1}S_{s2}=00$ ：表示结果为正数，无溢出。 $\circledcirc$  $S_{s1}S_{s2}=01$ ：表示结果正溢出。 $\textcircled{3}$  $S_{s1}S_{s2}=10$ ：表示结果负溢出。 $\textcircled{4}$  $S_{s1}S_{s2}=11$ ：表示结果为负数，无溢出。  

溢出逻辑判断表达式为 $V\!=\!S_{s1}\oplus S_{s2}$ ，若 $V\!=\!0$ ，表示无溢出：若 $V\!=\!1$ ，表示有溢出。  

（3）采用一位符号位根据数值位的进位情况判断溢出  

若符号位（最高位）的进位 $C_{n}$ 与最高数位（次高位）的进位 $C_{n-1}$ 相同，说明无溢出，否则说明有溢出。溢出逻辑判断表达式为 $V=C_{n}\oplus C_{n-1}$ ，若 $V=0$ ，表示无溢出； $V=1$ ，表示有溢出。  

### 加减运算电路  

>#### pro：无符号数与有符号数加/减运算能用同一个加法器实现的理由（2011）  

已知一个数的补码表示为Y，则这个数的负数的补码为 $\overrightharpoon{Y}+1$ ，因此，只要在原加法器的Y输入端加 $n$ 个反向器以实现各位取反的功能，然后加一个2选1多路选择器，用一个控制端Sub来控制，以选择是将 $Y$ 输入加法器还是将 $\overrightharpoon{Y}$ 输入加法器，并将Sub同时作为低位进位送到加法器（做减法时实现末位加1），如图2.6所示。该电路可实现模 $2^{n}$ 补码加减运算。当Sub为1时，做减法，实现 $X+\overline{{{Y}}}+1=[x]_{*}+[-y]_{*}$ ：当Sub为O时，做加法，实现 $X+Y=[x]_{*}+[y]_{*}$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ca2c5205d971573b48f8360dfee06c31fc7050362e076fdddeb45c514b1d2093.jpg)  
图2.6加减运算部件  

无符号整数相当于正整数的补码表示，因此图2.6的电路同时也能实现无符号数的加/减运算，对于有符号数 $x$ 和 $y$ ，图中 $X$ 和 $Y$ 分别是 $x$ 和 $y$ 的补码表示：对于无符号数 $x$ 和 $y$ ，图中 $X$ 和 $Y$ 分别是 $x$ 和 $y$ 的二进制表示。不论是补码减法还是无符号数减法，都是用被减数加上减数的负数的补码（即 $\overrightharpoon{Y}+1$ ）来实现的。  
>#### 注意  

运算器本身无法识别所处理的二进制串是有符号数还是无符号数。例如， $0-1=\,00...0+$  $11\ldots1\!=\!11\ldots1,$ 若解释为有符号数，对应值为-1，结果正确；若解释为无符号数，对应值为 $2^{n}{-}1$  $n$ 位无符号数的最大值），结果出错。此类易混点是统考极易考查的内容。  

可通过标志信息来区分有符号整数运算结果和无符号整数运算结果。  

>#### pro：  

无符号数、有符号数加减运算后CF和OF的值（2011、2018、2023）；SF和OF的逻辑表达式（2022）  

零标志ZF： $Z\mathrm{F}=1$ 表示结果F为O。对于无符号数和有符号数的运算，ZF都有意义。  

溢出标志OF：判断有符号数运算是否溢出，它是符号位进位与最高数位进位的异或结果即 ${\mathrm{OF}}=C_{n}\oplus C_{n-1}$ 。对于无符号数运算，OF没有意义，通俗地说，就是根据OF无法判断无符号数运算是否溢出。例如，无符号数加法 $010+011=101$ ，此时 $\mathrm{OF}=1$ ，但结果未溢出。  

符号标志SF：表示结果的符号，即F的最高位。对于无符号数运算，SF没有意义。  

进/借位标志CF：表示无符号数运算时的进位/借位，判断是否发生溢出。加法时， $\mathrm{CF}{=}1$ 表示结果溢出，因此CF等于进位输出 $C_{\mathrm{out}}$ 。减法时， $\mathrm{CF}=1$ 表示有借位，即不够减，故CF等于进位输出 $C_{\mathrm{out}}$ 取反。综合可得 $\mathrm{CF}\,{=}\,\mathrm{Sub}\oplus C_{\mathrm{out}}.$ 。例如，无符号数加法 $110+011$ 最高位产生进位，无符号数减法  $000-111$  最高位产生借位，结果均发生溢出（即  $\mathrm{CF}\,=\,1)$  。对于有符号数运算，CF 没有意义，也就是说，根据CF无法判断有符号数运算是否溢出。  

（1）无符号数大小的比较  

对于无符号数的运算，零标志ZF、进/借位标志CF才有意义。假设有两个无符号数 $A$ 和 $B$ 下面以执行 $A-B$ 为例来说明ZF、CF标志的几种可能情况。  

若 $A^{=}B$ ，如 $A-B=011-011=000$ ，此时结果为零 $Z\mathrm{F}=1$ ，无借位 $\mathrm{CF}=0$  

若 $A>B$ ，如 $A-B=010-001=001$ ，此时结果非零 $Z\mathrm{F}=0$ ，无借位 $\mathrm{CF}=0$  

若 $A<B$ ，如 $A-B=000-001=(1)000-001=111$ ，此时 $\mathrm{ZF}\!=0$ ，有借位 $\mathrm{CF}=1$  

当ZF=1时，说明 $\scriptstyle\mathcal{A}\equiv\mathcal{B}$ 。当ZF $\underline{{\underline{{\mathbf{\Pi}}}}}\,\underline{{\underline{{\mathbf{\delta\pi}}}}}\,\underline{{\underline{{\mathbf{\delta\pi}}}}}$ 且CF $\l_{\infty}^{\prime}0$ 时，说明 $\scriptstyle\mathcal{A}\geq\mathcal{B}\mathfrak{c}$ 当CF $=1$ 时，说明 $\underline{{A}}\le\underline{{B}}$  

（2）有符号数大小的比较  

对于有符号数的运算，零标志ZF、溢出标志OF、符号标志SF才有意义。假设两个有符号数 $A$ 和 $B$ ，用补码表示，以执行 $[A]_{*}-[B]_{*}$ 为例来说明ZF、OF、SF标志的几种可能情况。  

若 $A\,{=}\,B$ ，如 $![A]_{*}-[B]_{*}=011-011=[A]_{*}+[-B]_{*}=011+101=(1)000,$ ，此时结果为零 $\mathrm{ZF}=1$ 最高位进位与次高位进位的异或结果 $\mathrm{OF}=C_{3}\oplus C_{2}=0$ ，结果的最高位 $\mathrm{SF}=0$  

若  $A\!>B$   $l!\!\!1[A]_{*}-[B]_{*}=010-001=010+111=(1)001$  ，此时  $\mathrm{ZF}=0,~\mathrm{OF}=0,~\mathrm{SF}=0$  ；又  $999[A]*-[B]*=011-101=011+011=110$ ，此时 $\mathrm{{ZF}=0,\,\ O F=1,\,\ S F=1}\,.$  

若 $A<B$ ，如 $[A]_{*}-[B]_{*}\,=000-001=000+111=111$ ，此时 $\mathrm{ZF}=0,~\mathrm{OF}=0,~\mathrm{SF}=1$ 。又 $991[A]_{*}-[B]_{*}\ =101-011=101+101=(1)010$ ，此时 $\mathrm{{ZF}}=0,\;\;\mathrm{{OF}}=1,\;\;\mathrm{{SF}}=0.$  

当ZF $=$ 1时，说明 $\scriptstyle{\mathcal{A}}={\mathcal{B}}$ 。当 $Z\mathrm{F}=0$ 且未发生溢出时，即 $\mathrm{OF}\,{=}\,0$ 时，若 $\mathrm{SF}=0$ ，则表示结果非负，说明 $A>B$ ：当发生溢出时，即 $\mathrm{OF}=1$ 时，若 $\mathrm{SF}=1$ ，则必然是正数减去负数发生溢出导致结果为负，因此，当OF $=$ SF（或OFSF $\lneq0$ ）且ZF $=\!0$ 时，说明 $\scriptstyle\mathcal{A}\geq\mathcal{B}$ 。当 $Z\mathrm{F}=0$ 且未发生溢出时，即 $\mathrm{OF}=0$ 时，若 $\mathrm{SF}=1$ ，则表示结果为负，说明 $A<B$ ；当发生溢出时，即 $\mathrm{OF}=1$ 时，若 $\mathrm{SF}=0$ ，则必然是负数减去正数发生溢出导致结果为正，因此，当OFSF（或OFSF=1）HZF $=\!0$ 时，说明 $\scriptstyle A\leq B$  
### 原码的加减法运算（了解）  

在原码加减运算中，将符号位和数值位分开处理，具体的规则如下。  

加法规则：遵循“同号求和，异号求差”的原则，先判断两个操作数的符号位。具体来说，符号位相同，则数值位相加，结果符号位不变，若最高数值位相加产生进位，则发生溢出；符号位不同，则做减法，绝对值大的数减去绝对值小的数，结果符号位与绝对值大的数相同。  

减法规则：先将减数的符号取反，然后将被减数与符号取反后的减数按原码加法进行运算。  

>#### 注意  

原码的加减运算规则比较复杂，因此计算机采用的大多是补码加减运算。  

## 定点数的乘除运算  

### 乘法  

#### （1）基本原理  

>#### pro：如何用加、减、移位指令实现乘法指令（2020）；用软/硬件实现乘法指令的速度对比（2020）  

原码乘法的特点是符号位与数值位是分开求的，原码乘法运算分为两步： $\textcircled{\scriptsize{1}}$ 乘积的符号位由两个乘数的符号位“异或”得到： $\circledcirc$ 乘积的数值位是两个乘数的绝对值之积。两个定点数的数值部分之积可视为两个无符号数的乘积。下面是两个无符号数相乘的手算过程。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e9db16b99b4414f5ea84bd89e7c11ec1810c2c66dcab7d40d3de91283d2f650b.jpg)  

上述过程可写成数学推导过程：  

$$
\begin{array}{r l}&{X{\times}Y{=}X{\times}y_{4}{\times}2^{-4}+X{\times}y_{3}{\times}2^{-3}+X{\times}y_{2}{\times}2^{-2}+X{\times}y_{1}{\times}2^{-1}}\\ &{\qquad=2^{-1}\{2^{-1}[\ 2^{-1}(2^{-1}(0+X{\times}y_{4})+X{\times}y_{3})+X{\times}y_{2}]+X{\times}y_{1}\}}\end{array}
$$  

更普遍地， $n$ 位无符号数乘法 $X{\times}Y$ 可递归地定义如下。  

$$
\begin{array}{l}{{P_{1}=2^{-1}(P_{0}+X\times y_{n})}}\\ {{P_{2}=2^{-1}(P_{1}+X\times y_{n-1})}}\\ {{{}}}\\ {{P_{n}=2^{-1}(P_{n-1}+X\times y_{1})}}\end{array}
$$  

其递推公式为  

$$
P_{i+1}=2^{-1}(P_{i}+X\times y_{n-i}\ )\quad(\,i=0,\,1,\,2,\cdots,\,n-1\,)
$$  

最终乘积为  
$$
P_{n}{=}X{\times}Y
$$  

由上述分析可知，乘法运算可用加法和移位运算来实现（乘以 $2^{-1}$ 相当于做一次右移），两个 $n$ 位无符号数相乘共需进行 $n$ 次加法和 $n$ 次移位运算。原码乘法运算的过程可归纳如下：  

$\textcircled{\scriptsize{1}}$ 被乘数和乘数均取绝对值参加运算，视为无符号数，符号位为 $x_{s}\oplus y_{s}$  

$\circledcirc$ 部分积 $P_{i}$ 是乘法运算的中间结果，初值 $P_{0}\!=\!0$ 。从乘数的最低位 $y_{n}$ 开始，将前面所得的部分积 $P_{i}$ 加上 $X{\times}y_{n-i}$ ，然后右移一位，此步骤重复 $n$ 次。  

>#### 注意  

由于参与运算的是两个数的数值位，因此运算过程中的右移操作均为逻辑右移，  

#### （2）运算电路  

>#### pro：乘法电路中控制逻辑的作用（2020）  

图2.7是32位无符号数乘法运算的逻辑结构图。部分积和被乘数 $X$ 做无符号数加法时，可能产生进位，因此设置一个专门的进位位 $C$ 。乘积寄存器 $P$ 初始置0。计数器 $C_{n}$ 初值为32，每循环一次减1。ALU是乘法器的核心部件，对乘积寄存器 $P$ 和被乘数寄存器 $X$ 的内容做“无符号加法”运算，结果送回寄存器 $P$ ，进位存放在 $C$ 中。每次循环都对进位位 $C_{\backprime}$ 寄存器 $P$ 和寄存器Y实现同步“逻辑右移”，此时，进位位 $C$ 移人寄存器 $P$ 的最高位，寄存器 $Y$ 的最低位移出。每次从寄存器Y移出的最低位都被送到控制逻辑，以决定被乘数是否“加”到部分积上。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8b2f2efb8fb8e06dba5d1e1515aadb7d8ddaed5027b92202ab8b99fb2db85ef1.jpg)  
图2.732位无符号数乘法运算的逻辑结构图  

>#### pro：无符号数和有符号数乘法指令的溢出判断（2019、2020、2021）  

在字长为32位的计算机中，对于两个int型变量 $x$ 和 $y$ 的乘积，若乘积高32位的每一位都相同，且都等于乘积低32位的符号，则表示不溢出，否则表示溢出。当 $x$ 和 $y$ unsigned in t型变量时，若乘积的高32位全为0，则表示不溢出，否则表示溢出。  

### 除法运算  

#### （1）除法运算的基本原理  

原码的除法运算与乘法运算很相似，都是一种移位和加减运算迭代的过程，但比乘法运算更复杂。 $n$ 位定点数的除法运算，需统一为：一个 $2n$ 位的数除以一个 $n$ 位的数，得到一个 $n$ 位的商，因此需要对被除数进行扩展。对于定点正小数（即原码小数），只需在被除数低位添 $n$ 个0即可。对于定点正整数（即无符号数），只需在被除数高位添 $n$ 个0即可。做整数除法时，若除数为0，则发生“除数为0”异常，此时需调出操作系统相应的异常处理程序进行处理。  

下面以两个无符号数为例说明手算除法步骤。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b22578c8487627eb2d6a4c43646e4c36db3f32c45ffb58d5a241672596cd920b.jpg)  

上述除法运算的过程可归纳如下：  

$\textcircled{\scriptsize{1}}$ 被除数与除数相减，够减则上商为1，不够减则上商为0  

$\circledcirc$ 每次得到的差为中间余数，将除数右移后与上次的中间余数比较。用中间余数减除数，  

够减则上商为1，不够减则上商为0。如此重复，直到商的位数满足要求为止。  

若是 $2n$ 位除以 $n$ 位的无符号数，商的位数为 $n+1$ 位，当第一次试商为1时，则表示结果溢出（即无法用 $n$ 位表示商），如 $1111\ 1111/1111=1\ 0001$ 。若是两个 $n$ 位的无符号数相除，则第一位商为0，且结果肯定不会溢出，如两个4位数相除的最大商为 $0000\;1111/0001=1111.$ 对于浮点数尾数的原码小数相除，第一次试商为1，则说明尾数部分有溢出，可通过右规消除。  

计算机内部的除法运算与手算除法一样，通过被除数（中间余数）减除数来得到每一位商，够减上商1，不够减上商0。原码除法运算也要将符号位和数值位分开处理，商的符号位是两个数的符号位的“异或”结果，商的数值位是两个数的绝对值之商。  

#### （2）除法运算电路  

图2.8是一个32位除法逻辑结构图。寄存器 $Y$ 存放除数：寄存器 $R$ 初始时存放扩展被除数的高32位，运算过程中存放中间余数的高位部分，结束时存放的是余数；寄存器 $\mathcal{Q}$ 初始时存放扩展被除数的低32位，运算过程中部分存放中间余数的低位部分、部分存放商，结束时存放的是32位商。ALU是除法器的核心部件，对寄存器 $R$ 和Y的内容做加/减运算，运算结果被送回寄存器 $R$ 。计数器 $C_{n}$ 初值为32，每循环一次减1。每次循环，寄存器 $R$ 和 $\mathcal{Q}$ 实现同步左移，左移时， $\mathcal{Q}$ 的最高位移入R的最低位， $\mathcal{Q}$ 中空出的最低位被上商。从低位开始，遂次把商的各个数位左移到 $\mathcal{Q}$ 中。每次由控制逻辑根据ALU运算结果的符号来决定上商是0还是1。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/99e080eafaeaa56c6e3b0cb75bcae35c36ab081b32783fa2a18c159d18a06bda.jpg)  
图2.832位除法运算的逻辑结构图  

若是两个32位int型整数相除，则除了 $-2^{31}/{-1}$ 会溢出，其余情况都不会溢出。  


# 2浮点数的表示与运算  

## 表示  

浮点数表示法是指以适当的形式将比例因子表示在数据中，让小数点的位置根据需要而浮动。这样，在位数有限的情况下，既扩大了数的表示范围，又保持了数的有效精度。例如，用定点数表示电子的质量 $(9{\times}10^{-28}\mathrm{g})$ ）或太阳的质量（ $(2\!\times\!10^{33}\mathrm{g})$ ）是非常不方便的。  

### 表示格式  

通常，浮点数表示为  

$$
N{=}(-1)^{S}{\times}M{\times}R^{E}
$$  

式中， $S$ 取值0或1，用来决定浮点数的符号； $M$ 是一个二进制定点小数，称为尾数，一般用定点原码小数表示： $E$ 是一个二进制定点整数，称为阶码或指数，用移码表示。 $R$ 是基数（隐含），可以药定为2、4、16等。可见浮点数由符号、尾数和阶码三部分组成。  

图2.9是一个32位短浮点数格式的例子。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a1b7a71d10d028b99f2e5658ea6e33dcdc0d30ea436288f4013315ca9d3ac5ff.jpg)  
图2.9浮点数格式的例子  

其中，第0位为符号 $S$ ：第 $1\!\sim\!7$ 位为移码表示的阶码 $E$ （偏置值为64）；第 $8\!\sim\!31$ 位为24位二进制原码小数表示的尾数 $M$ ：基数 $R$ 为2。阶码的值反映浮点数的小数点的实际位置：阶码的位数反映浮点数的表示范围：尾数的位数反映浮点数的精度。  
### 表示范围  

原码是关于原点对称的，敌浮点数的范围也是关于原点对称的，如图2.10所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b69c0bc872d03974bb8a0faff59a9536bc3766b1475dc6f2288fb16f9676567b.jpg)  
图2.10浮点数的表示范围  

运算结果大于最大正数时称为正上溢，小于绝对值最大负数时称为负上溢，正上溢和负上溢统称上溢。数据一旦产生上溢，计算机必须中断运算操作，进行溢出处理。当运算结果在0至最小正数之间时称为正下溢，在0至绝对值最小负数之间时称为负下溢，正下溢和负下溢统称下溢。数据下溢时，浮点数值趋于零，计算机将其当作机器零处理。  

### 规格化  

为了在浮点数运算过程中尽可能多地保留有效数字的位数，使有效数字尽量占满尾数数位必须在运算过程中对浮点数进行规格化操作。所谓规格化操作，是指通过调整一个非规格化浮点数的尾数和阶码的大小，使非零浮点数在尾数的最高数位上保证是一个有效值。  

左规：当运算结果的尾数的最高数位不是有效位，即出现 $^{\pm0.0...0\times...\times}$ 的形式时，需要进行左规。左规时，尾数每左移一位、阶码减1（基数为2时）。左规可能要进行多次。  

右规：当运算结果的尾数的有效位进到小数点前面时，需要进行右规，右规只需进行一次。将尾数右移一位、阶码加1（基数为2时）。右规时，阶码增加可能导致溢出。  

基数为2的原码规格化尾数 $M$ 应满足 $1/2\!\leqslant\!|M|<1$ ，形式如下： $\textcircled{\scriptsize{1}}$ 正数为 $0.1\times...\times$ 的形式，最大值为0.11...1，最小值为0.100...0，表示范围为 $1/2\!\leqslant\!M\!\leqslant\!(1-2^{-n})$ ： $\textcircled{2}$ 负数为 $1.1\times...\times$ 的形式，最大值为1.10...0，最小值为1.11..1，表示范围为一 $(1-2^{-n}){\leqslant}M{\leqslant}-1/2$  

基数不同，浮点数的规格化形式也不同。当浮点数尾数的基数为2时，原码规格化数的尾数最高位一定是1。当基数为4时，原码规格化数的尾数最高两位不全为0。  

### IEEE754标准  

>#### pro：IEEE754单精度数大小的比较（2014）  

按照IEEE754标准，常用的浮点数的格式如图2.11所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3b05317cc38d69e199cbfe63befd2efce159619079739354914b91a50fa5ab65.jpg)  
图2.11IEEE754标准浮点数的格式  

IEEE754标准规定常用的浮点数格式有32位单精度浮点数（短浮点数、float型）和64位双精度浮点数（长浮点数、double型），其基数隐含为2，见表2.2。  
表2.2IEEE754浮点数的格式
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0ca31a6a712a028a5cadc8997f2d0ee5e30453ac3a0d7a755db034c662d63b9a.jpg)  

单精度格式中包含1位符号 $s,\ 8$ 位阶码 $e$ 和23位尾数 $f_{1}$ ：双精度格式包含1位符号 $s$ 、11位阶码 $e$ 和52位尾数 $f_{\circ}$ 基数隐含为2；尾数用原码表示。对于规格化的二进制浮点数，尾数的最高位总是1，为了能使尾数多表示一位有效位，将这个1隐藏，称为隐藏位，因此23位尾数实际表示了24位有效数字。IEEE754规定隐藏位1的位置在小数点之前，例如， $(12)_{10}\!=\!(1100)_{2}$ 将它规格化后结果为 $1.1\!\times\!2^{3}$ ，其中整数部分的“1”将不存储在23位尾数内。  

>#### 注意  

单精度与双精度浮点数都采用隐藏尾数最高位的方法，因而使浮点数的精度更高。  

在IEEE754标准中，指数用移码表示，但偏置值并不是通常 $n$ 位移码所用的 $2^{n-1}$ ，而是 $2^{n-1}{-1}$ ，因此，单精度和双精度浮点数的偏置值分别为127和1023。在存储浮点数阶码之前，偏置值要先加到阶码真值上。上例中，阶码值为3，因此在单精度浮点数中，移码表示的阶码为 $127+3=130(82\mathrm{H})$ 在双精度浮点数中，阶码为 $1023+3=1026$ (402H)。  

IEEE754标准中，规格化单精度浮点数的真值为  

$$
(-1)^{s}{\times}1.f{\times}2^{e-127}
$$  

规格化双精度浮点数的真值为  

$$
(-1)^{s}{\times}1.f{\times}2^{e{-}1023}
$$  

式中，规格化单精度浮点数的阶码 $e$ 的取值范围为 $1\!\sim\!254$ （8位）：规格化双精度浮点数的阶码 $e$ 的取值范围为 $1\!\sim\!2046$ （11位）。1EEE754规格化浮点数的表示范围见表2.3。  

>#### pro：IEEE754单精度数的表示范围和有效位（2017、2018）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0e09dbec5860d7cec7c801ef49119346c4db36645552b736a3f51caead1e3a23.jpg)  

对于EEE754格式的浮点数，阶码全为0或全为1时，有其特别的解释，如表2.4所示。>#### pro：IEEE754标准中阶码全为0或全为1时的特殊意义（2017、2023）  

表2.4阶码全为0或全为1时IEEE754浮点数的解释
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5cab272967bd8b58b3d1903235f5ed69c303bb77df5afa2deea36e8c30238b4d.jpg)  
(续表) 
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a466833be1246442271c1562278ccba92a69b86a821388a52a08a2ecffff59b4.jpg)  

1）全0阶码全0尾数： $+0/-0$ 。零的符号取决于符号 $s$ ，一般情况下 $+0$ 和-0是等效的。  

2）全1阶码全0尾数： $+\infty/-\infty$ 。 $+\infty$ 在数值上大于所有有限数， $-\infty$ 则小于所有有限数。引入无穷大数的目的是，在计算过程出现异常的情况下使得程序能继续进行下去。  

3）全1阶码非0尾数：NaN（NotaNumber）。表示一个没有定义的数，称为非数。  

4）全0阶码非0尾数：非规格化数。非规格化数的特点是阶码为全0，尾数高位有一个或几个连续的0，但不全为0。因此，非规格化数的隐藏位为0，且单精度和双精度浮点数的指数分别为-126或-1022。非规格化数可以用于处理阶码下溢。  

>#### pro：实数与1EEE754单精度数的相互转换（2011、2013、2020、2022、2023）  

【例2.5】将十进制数-8.25转换为IEEE754单精度浮点数格式表示。  

解：  

IEEE754规定：单精度浮点数的偏置值是127；尾数最高位的“1”是被隐藏的。  

先将-8.25转换成二进制数，即 $-1000.01\!=\!-1.000\:01\!\times\!2^{3}$ ，再计算阶码 $E$  $E-127=3$ ，因此 $E\!=$ 130，转换成二进制数为10000010。  

IEEE754单精度浮点数格式：符号（1位） $^+$ 阶码（8位） $^+$ 尾数（23位)。因此，单精度格式表示为  

即  

【例2.6】求IEEE754单精度浮点数 $\mathrm{C640\,\,0000H}$ 的值是多少。  

解：  

先将 $\mathrm{C640\,0000H}$ 按二进制展开为  

11000110010000000000000000000000  

其对应IEEE754单精度浮点数的格式如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d7a584d8be78918f4c203a6b65fcbebbfc1fbd6fb5150e3de3722237aab3bc05.jpg)  

因此，符号 $=1$ 表示负数；阶码值为 $1000\ 1100-0111\ 1111=0000\ 1101=13$ ：尾数值为1.5（注意其有隐藏位，要加1)。因此，浮点数的值为一 $\cdot1.5\!\times\!2^{13}$  

### 定点、浮点表示的区别  

（1）数值的表示范围若定点数和浮点数的字长相同，则浮点表示法所能表示的数值范围远大于定点表示法  

(2) 精度对于字长相同的定点数和浮点数来说，浮点数虽然扩大了数的表示范围，但精度降低了。  

（3）数的运算浮点数包括阶码和尾数两部分，运算时不仅要做尾数的运算，还要做阶码的运算，而且运算结果要求规格化，所以浮点运算比定点运算复杂。  
（4）溢出问题  

在定点运算中，当运算结果超出数的表示范围时，发生溢出；在浮点运算中，运算结果超出尾数表示范围却不一定溢出，只有规格化后阶码超出所能表示的范围时，才发生溢出。  

### 浮点数的加减运算  

浮点数运算的特点是阶码运算和尾数运算分开进行，浮点数加减运算分为以下几步。>#### pro：float型能否通过左移实现乘以2运算（2017）；浮点数的加减运算（2009）  

#### 对阶  

对阶的目的是使两个操作数的小数点位置对齐，即使得两个数的阶码相等。为此，先求阶码差，然后以小阶码向大阶码看齐的原则，将阶码小的尾数右移一位（基数为2），阶码加1，直到两个数的阶码相等为止。尾数右移时，若舍弃有效位会产生误差，影响精度。为了保证运算的精度，尾数石移时，低位移出的位不要去掉，应保留并参加尾数部分的运算。  

>#### 注意  

若采用大阶码向小阶码看齐的原则，则尾数需要左移，最高有效位被移出，导致结果出错。  

2.尾数加减  

将对阶后的尾数按定点原码小数的加（减）运算规则进行运算。因为IEEE754浮点数尾数中有一个隐藏位，因此在进行尾数加减时，必须将隐藏位还原到尾数部分。运算后的尾数不一定是规格化的，因此，浮点数的加减运算需要进一步进行规格化处理。  

#### 尾数规格化  

IEEE754规格化尾数的形式为 $\pm1.\times...\times_{\circ}$ 尾数相加减后会得到各种可能结果，例如：  

$$
1.\times...\times+1.\times...\times=\pm1\times...\times...\times
$$  

$$
1.\times_{...}\times-1.\times_{...}\times=\pm0.0...01\times_{...}\times
$$  

1）右规：当结果为 $|\pm1\times.\times\ldots\times$ 时，需要进行右规。尾数右移一位，阶码加1。尾数右移时，最高位1被移到小数点前一位作为隐藏位，最后一位移出时，要考虑舍入。2）左规：当结果为 $\pm0.0...01\times...\times$ 时，需要进行左规。尾数每左移一位，阶码减1。可能需要左规多次，直到将第一位1移到小数点左边。  

>#### 注意  

$\textcircled{\scriptsize{1}}$ 左规一次相当于乘以2，右规一次相当于除以2； $\textcircled{2}$ 需要右规时，只需进行一次。  

#### 舍入  

在对阶和尾数右规时，可能会对尾数进行右移，为保证运算精度，一般将移出的部分低位保留下来，参加中间过程的运算，最后再将运算结果进行舍入，还原表示成IEEE754格式。  

IEEE754提供了以下4种可选的舍入模式。  

1）就近舍入：舍人为最近的可表示数。当运算结果是两个可表示数的非中间值时，实际上是“0舍1入”方式（类似于十进制的“四舍五入”法）：当运算结果正好在两个可表示数的中间时，则选择结果为偶数。例如，计算 $1.24{\times}10^{5}+5.04{\times}10^{2}$ （假定科学记数法的精度保留两位小数），若只采用2位保留位，则结果是 $1.2400{\times}10^{5}+0.0050{\times}10^{5}=1.2450{\times}10^{5}$  
这个结果在两个可表示数 $1.24\!\times\!10^{5}$ 和 $1.25\!\times\!10^{5}$ 的中间，采用就近舍入方式到偶数，则结果应该是 $1.24\!\times\!10^{5}$ ：若采用3位保留位，则结果是 $1.24000{\times}10^{5}+\ 0.00504{\times}10^{5}\ =$  $1.24504{\times}10^{5}$ ，这个结果就不在 $1.24\!\times\!10^{5}$ 和 $1.25\!\times\!10^{5}$ 的中间，而更接近于 $1.25\!\times\!10^{5}$ ，采用就近舍入方式，则结果应该是 $1.25\!\times\!10^{5}$ 。显然，后者更为精确。  

2）正向舍入：朝数轴 $+\infty$ 方向舍入，即取右边最近的可表示数。3）负向舍入：朝数轴-方向舍入，即取左边最近的可表示数。  

4）截断法：直接截取所需位数，丢弃后面的所有位，这种舍入处理最简单。对正数或负数来说，都是取更接近原点的那个可表示数，是一种趋向原点的舍入。  

#### 溢出判断  

>#### pro：浮点数运算时的溢出判断（2015）  

在尾数规格化和尾数舍入时，可能会对结果的阶码执行加/减运算。因此，必须考虑指数溢出问题。若一个正指数超过了最大允许值（127或1023），则发生指数上溢，产生异常。若一个负指数超过了最小充许值（-149或-1074）°，则发生指数下溢，通常把结果按机器零处理。  

1）右规和尾数舍入。数值很大的尾数舍入时，可能因为末位加1而发生尾数溢出，此时需要通过右规来调整尾数和阶码。右规时阶码加1，导致阶码增大，因此需要判断是否发生了指数上溢。当调整前的阶码为11111110时，加1后，会变成11111111而发生指数上溢。2）左规。左规时阶码减1，导致阶码减小，因此需要判断是否发生了指数下溢。其判断规则与指数上溢类似，左规一次，阶码减1，然后判断阶码是否为全0来确定指数是否下溢。由此可见，浮点数的溢出并不是以尾数溢出来判断的，尾数溢出可以通过右规操作得到纠正。  

管结里县不送出主亚丢结里的指数县不发生了上送，因此县中指数上送来判断的  

>#### 注意  

某些题目中可能会指定尾数或阶码采用补码表示。通常可以采用双符号位，当尾数求和结果溢出（如尾数为 $10.\times\times...\times...$ 或 $01.\times\times...\times$ ）时，需右规一次；当结果出现 $00.0\times\times_{...}\times$ 或 $11.1\times\times_{...}\times$ 时，需要左规，直到尾数变为 $00.1\times\times...\times$ 或 $11.0\times\times_{...}\times_{i}$  

### C语言中：浮点数类型  

>#### pro：不同类型数据转换后数值的变化（2010）  

C语言中的float型和double 型分别对应于IEEE754单精度浮点数和双精度浮点数。longdouble型对应于扩展双精度浮点数，但longdouble型的长度和格式随编译器和处理器类型的不同而有所不同。在C程序中，等式的赋值和判断会导致强制类型转换，以char→int→long→double和float一double最为常见，从前到后范围和精度都从小到大，转换过程没有损失。  

不同类型数的混合运算时，遵循的原则是“类型提升”，即较低类型转换为较高类型。如long型与int型一起运算时，需先将int型转换为long型，然后进行运算，结果为long型。若float型和double型一起运算，虽然两者同为浮点型，但精度不同，则仍需先将float型转换为double型后再进行运算，结果亦为double型。所有这些转换都是系统自动进行的，这种转换称为隐式类型转换。  

>#### pro：int型和float型的精度和范围的分析（2017）  

1）int型转换为float型时，虽然不会发生溢出，但float型尾数连隐藏位共24位，当int型  
数的第 $24\!\sim\!31$ 位非0时，无法精确转换成24位浮点数的尾数，需舍入处理，影响精度。2）int型或float型转换为double型时，因double型的有效位数更多，因此能保留精确值。3）double型转换为float型时，因float型的表示范围更小，因此大数转换时可能会发生溢出。此外，由于尾数有效位数变少，因此高精度数转换时会发生舍入。4）float型或double型转换为int型时，因int型没有小数部分，因此数据会向O方向截断（仅  

保留救数部分）发生全入，另外、因int型的表示范围更小，因业大数桂换时可能会送出在不同数据类型之间转换时，往往隐藏着一些不容易察觉的错误，编程时要非常小心。  

### 数据的大小端和对齐存储  

#### 数据的“大端方式”和“小端方式”存储  

在存储数据时，数据从低位到高位可以按从左到右排列，也可以按从右到左排列。因此，无法用最左或最右来表征数据的最高位或最低位，通常用最低有效字节（LSB）和最高有效字节（MSB）来分别表示数据的低位和高位。例如，在32位计算机中，一个int型变量i的机器数为01234567H，其最高有效字节 $\mathrm{MSB}=01\mathrm{H}$ ，最低有效字节 $\mathrm{LSB}=67\mathrm{H}$  

>#### pro：数据的大小端存储（2016、2018、2019）  

现代计算机基本都采用字节编址，即每个地址编号中存放1字节。不同类型的数据占用的字节数不同，如int型和float型占4字节，double型占8字节等，而程序中对每个数据只给定一个地址。假设变量i的地址为 $08\ \mathrm{~00H}$ ，字节01H、 $^{23\mathrm{H}}$ 、45H、67H应各有一个内存地址，那么4字节在内存中应如何排列呢？根据数据中各字节在连续字节序列中的排列顺序不同，可以采用两种排列方式：大端方式（bigendian）和小端方式（lileendian），如图2.12所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/84b38180f8e3e94007c8d5d059202ea50bd801817d21a778faa66e4c344005dc.jpg)  
图2.12采用大端方式和小端方式存储数据  

>#### pro：根据存放顺序判断大小端方式（2019、2023）  

1）大端方式：先存储高位字节，后存储低位字节。字中的字节顺序和原序列的相同。2）小端方式：先存储低位字节，后存储高位字节。字中的字节顺序和原序列的相反。  

在检查底层机器级代码时，需要分清各类型数据字节序列的顺序，例如，以下是由反汇编器（汇编的逆过程，即将机器代码转换为汇编代码）生成的一行机器级代码的文本表示：  

4004d3:010564940408 addeax,0x8049464  

其中，“4004d3”是十六进制数表示的地址，‘ $\lceil01\;05\;64\;94\;04\;08$ ”是指令的机器代码，“addeax,0x8049464”是指令的汇编形式，该指令的第二个操作数是一个立即数 $0{\mathrm{x}}8049464$ 。执行指令时，从指令代码的后4字节中取出该立即数，立即数存放的字节序列为 $64\mathrm{H}$ 、94H、04H、08H，正好与操作数的字节顺序相反，即采用的是小端方式存储，得到08049464H，去掉开头的0，得到值0x8049464，在阅读以小端方式存储的机器代码时，要注意字节是按相反顺序显示的。  

#### 数据按“边界对齐”方式存储  

现代计算机都是按字节编址的，假设字长为32位，数据按边界对齐方式存放要求其存储地址是自身大小的整数倍，半字地址一定是2的整数倍，字地址一定是4的整数倍，这样无论所取 的数据是字节、半字还是字，均可一次访存取出。当所存数据不满足上述要求时，可通过填充空白字节使其符合要求。这样做虽然会浪费一些存储空间，但可以提高存取数据的速度。当数据不按边界对齐方式存储时，半字长或字长的数据可能在两个存储字中，此时需要两次访存，并对高低字节的位置进行调整后才能得到所需数据，从而影响了系统的效率。  
例如，“字节1、字节2、字节3、半字1、半字2、半字3、字1”的数据按序存放在存储器中，按边界对齐方式和按边界不对齐方式存储时，格式分别如图2.13和图2.14所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/67830ff4aa95539687716a65b4721775d480669d1061978c1db29d559d02a9d6.jpg)  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d1d6304976238bbf3f89570e9a0865f42e06a2cef809c11fe4381efd07032597.jpg)  
图2.14按边界不对齐方式存储  

>#### pro：结构体的小端、边界对齐存储（2012、2020）  

在C语言的struct类型中，“边界对齐”有两个重要要求： $\textcircled{\scriptsize{1}}$ 每个成员按其类型的大小对齐，char型的对齐值为1，short型的对齐值为2，int型的对齐值为4，单位为字节；  $\circledcirc$  struct的长度 必须是成员中最大对齐值的整数倍（不够就补空字节）。这样就能保证struct数组的每项都满足边界对齐的条件。  

先来看两个例子（32位，x86环境，GCC编译器）：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a106cd6e73c0cca59a16d1068d7eab6ca420beac8d815b1685e0a3f75e177bd6.jpg)  

结果却是：  $\mathrm{sizeof}\mathrm{(A)}=8$  ，  $\mathrm{sizeof}(\mathrm{B})=12$  

之所以出现上面的结果，是因为编译器要使结构体成员在空间上对齐。为此必须满足： $\textcircled{\scriptsize{1}}$ 每个成员存储的“起始地址 $.\%$ 该成员的长度 $=0$ ”，而结构体中的成员都是按定义的先后顺序排放的。 $\textcircled{2}$ 结构体的长度也必须是最大成员长度的整数倍，即结构体也要对齐排放。  

设B从地址 $0x0000$ 开始，第一个成员b的对齐值是1，其存放地址符合 $0\mathrm{x}0000\%1=0$ ：第二个成员a的对齐值是4，只能存放在从0x0004到 $\mathrm{0x0007}$ 这四个字节中，满足 $0\X{000}{4\%{4=0}}$ 且紧邻第一个成员；第三个成员c的对齐值是2，可以存放在从 $\mathrm{0x0008}$ 到 $0{\bf x}0009$ 这两个字节中。此外，结构体长度必须是最大对齐值的整数倍，故 $\mathrm{0x000A}$ 到 $\mathrm{0x000B}$ 也为B所占用，共12字节。  

设A也从地址 $0x0000$ 开始，第一个成员a的对齐值是4，存放在从 $0x0000$ 到 $0\mathbf{x}0003$ 这四个字节中；第二个成员b的对齐值是1，存放在 $0x0004$ 中；第三个成员c的对齐值是2，为满足“起始地址 $\%N\!=\!0$ ”的条件，只能存放在从 $0x0006$ 到 $0x0007$ 这两个字节中，结构体共占用8字节。  

边界对齐方式相对边界不对齐方式是一种空间换时间的思想。精简指令系统计算机RISC通常采用边界对齐方式，因为边界对齐方式取指令时间相同，因此能适应指令流水。  


## 本章小结  

本章开头提出的问题的参考答案如下：  

1）在计算机中，为什么要采用二进制来表示数据？答案已在本章开头说明。  
2）计算机在字长足够的情况下能够精确地表示每个数吗？若不能，请举例说明  

计算机采用二进制来表示数据，在字长足够时，可以表示任何一个整数。而二进制表示小数时只能够用 $1/(2^{n})$ 的和的任意组合表示，即使字长很长，也不可能精确表示出所有小数，只能无限接近。例如0.1就无法用二进制精确地表示。  

3）字长相同的情况下，浮点数和定点数的表示范围与精度有什么区别？  

字长相同时，浮点数取字长的一部分作为阶码，所以表示范围比定点数要大，而取一部分作为阶码也就代表着尾数部位的有效位数减少，而定点数字长的全部位都用来表示数值本身，精度要比同字长的浮点数更大。  

4）用移码表示浮点数的阶码有什么好处？  

移码的两个好处：  

$\textcircled{\scriptsize{1}}$ 浮点数进行加减运算时，要比较阶码的大小，移码比较大小更方便。  

$\circledcirc$ 检验移码的特殊值（0和max）时比较容易。阶码以移码编码时的特殊值如下。0：表示指数为负无穷大，相当于分数分母无穷大，整个数无穷接近0，在尾数也为0时可用来表示0：尾数不为零表示未规格化的数。max：表示指数正无穷大，若尾数为0，则表示浮点数超出表示范围（正负无穷大）：尾数不为0，则表示浮点数运算错误。  

### 5常见问题和易混淆知识点  

1.如何表示一个数值数据？计算机中的数值数据都是二进制数吗？在计算机内部，数值数据的表示方法有以下两大类。  

$\textcircled{\scriptsize{1}}$ 直接用二进制数表示。分为有符号数和无符号数，有符号数又分为定点数表示和浮点数表示。无符号数用来表示无符号整数（如地址等信息）。  

$\circledcirc$ 二进制编码的十进制数，一般采用BCD码表示，用来表示整数。  

所以，计算机中的数值数据虽然都用二进制表示，但不全是二进制，也有用十进制表示的。例如在指令类型中，就分别有二进制加法指令和十进制加法指令。  

### 什么称为无符号整数的“溢出”？  

对于无符号定点整数来说，若寄存器位数不够，则计算机运算过程中一般保留低 $n$ 位，舍弃高位。这样，会产生以下两种结果。  

$\textcircled{\scriptsize{1}}$ 保留的低 $n$ 位数不能正确表示运算结果。在这种情况下，意味着运算的结果超出了计算机所能表达的范围，有效数值进到了第 $n+1$ 位，称此时发生了“溢出”现象。  

$\circledcirc$ 保留的低 $n$ 位数能正确表达计算结果，即高位的舍去并不影响其运算结果，  

3.如何判断一个浮点数是否是规格化数？  

为了使浮点数能尽量多地表示有效位数，一般要求运算结果用规格化数形式表示。规格化浮点数的尾数小数点后的第一位一定是个非零数。因此，对于原码编码的尾数来说，只要看尾数的第一位是否为1就行；对于补码表示的尾数，只要看符号位和尾数最高位是否相反。需要注意的是，IEEE754标准的浮点数尾数是用原码编码的。  

4.对于位数相同的定点数和浮点数，可表示的浮点数个数比定点数个数多吗？  

不是，可表示的数据个数取决于编码所采用的位数。编码位数一定，编码出来的数据个数就是一定的。 $n$ 位编码只能表示 $2^{n}$ 个数，所以对于相同位数的定点数和浮点数来说，可表示的数据个数应该一样多（有时可能因为一个值有两个或多个编码对应，编码个数会有少量差异）。  
5.现代计算机中是否要考虑原码加减运算？如何实现？现代计算机中的浮点数采用IEEE754标准，所以在进行两个浮点数的加减运算时，必须考虑原码的加减运算，因为IEEE754标准的浮点数尾数都采用原码表示。  

原码的加减运算可以有以下两种实现方式  

1）转换为补码后，用补码加减法实现，结果再转换为原码。2）直接用原码进行加减运算，符号位和数值位分开处理（见原码加减运算部分）。  