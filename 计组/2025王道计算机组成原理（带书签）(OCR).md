
# 第1章计算机系统概述  

# 【考纲内容】  

（一）计算机系统层次结构  

计算机系统的基本组成计算机硬件的基本组成计算机软件和硬件的关系  

计算机系统的工作原理：“存储程序”方式：高级语言程序与机器语言程序的转换；程序和指令的执行过程  

（二）计算机性能指标  

吞吐量；响应时间：CPU时钟周期：主频：CPI；CPU执行时间；MIPS:MFLOPS:GFLOPS:TFLOPS:PFLOPS:EFLOPS:ZFLOPS  

# 【复习提示】  

本章是组成原理的概述，考查时易针对有关概念或性能指标出选择题，也可能综合后续章节的内容出有关性能分析的综合题。掌握本章的基本概念，是学好后续章节的基础。部分知识点在初学时理解不深刻也无须担忧，相信随着后续章节的学习，一定会有更为深入的理解。  

学习本章时，请读者思考以下问题：  

1）计算机由哪几部分组成？以哪部分为中心？2）主频高的CPU一定比主频低的CPU快吗？为什么？3）翻译程序、汇编程序、编译程序、解释程序有什么差别？各自的特性是什么？4）不同级别的语言编写的程序有什么区别？哪种语言编写的程序能被硬件直接执行？请读者在学习本章的过程中寻找答案，本章末尾会给出参考答案。  

#  $^{*1.1}$ 计算机发展历程  

# \*1.1.1计算机硬件的发展  

1.计算机的四代变化  

1946（Electronic Numerical Integrator And Computer，ENIAC）问世以来，计算机的发展已经经历了四代。  

1）第一代计算机（1946一1957年）一电子管时代。特点：逻辑元件采用电子管；使用机  
器语言进行编程：主存储器用延迟线或磁鼓存储信息，容量极小：体积庞大，成本高：运算速度较低，一般只有几千次到几万次每秒。  

2）第二代计算机（1958一1964年）一一晶体管时代。特点：逻辑元件采用晶体管；运算速度提高到几万次到几十万次每秒；主存储器使用磁芯存储器；计算机软件也得到了发展，开始出现了高级语言及其编译程序，有了操作系统的雏形。  

3）第三代计算机（1965一1971年）一中小规模集成电路时代。特点：逻辑元件采用中小规模集成电路：半导体存储器开始取代磁芯存储器；高级语言发展迅速，操作系统也进一步发展，开始有了分时操作系统。  

4）第四代计算机（1972年至今）一超大规模集成电路时代。特点：逻辑元件采用大规模集成电路和超大规模集成电路，产生了微处理器；诸如并行、流水线、高速缓存和虚拟存储器等概念用在了这代计算机中。  

# 2.计算机元件的更新换代  

1）摩尔定律。当价格不变时，集成电路上可容纳的晶体管数目，约每隔18个月便会增加一倍，性能也将提升一倍。也就是说，我们现在和18个月后花同样的钱买到的CPU，后者的性能是前者的两倍。这一定律揭示了信息技术进步的速度。  

2）半导体存储器的发展。1970年，美国仙童半导体公司生产出第一个较大容量的半导体存储器，至今，半导体存储器经历了11代：单芯片1KB、4KB、16KB、64KB、256KB、1MB、4MB、16MB、64MB、256MB和现在的1GB。  

3）微处理器的发展。自1971年Intel公司开发出第一个微处理器Intel4004至今，微处理器经历了Intel8008（8位）、Intel8086（16位）、Intel80386（32位）、Pentium（32位）、PentiumIll（64位）、Pentium4（64位）、Corei7（64位）等。这里的32位、64位指的是机器字长，是指计算机进行一次整数运算所能处理的二进制数据的位数。  

#  $^{*1.1.2}$ 计算机软件的发展  

计算机软件技术的蓬勃发展，也为计算机系统的发展做出了很大的贡献。  

计算机语言的发展经历了面向机器的机器语言和汇编语言、面向问题的高级语言。其中高级语言的发展真正促进了软件的发展，它经历了从科学计算和工程计算的FORTRAN、结构化程序设计的PASCAL到面向对象的 $\mathrm{C++}$ 和适应网络环境的Java。  

与此同时，直接影响计算机系统性能提升的各种系统软件也有了长足的发展，特别是操作系统，如Windows、UNIX、Linux等。  

# 1.2计算机系统层次结构  

# 1.2.1计算机系统的组成  

硬件系统和软件系统共同构成了一个完整的计算机系统。硬件是指有形的物理设备，是计算机系统中实际物理装置的总称。软件是指在硬件上运行的程序和相关的数据及文档。  

计算机系统性能的好坏，很大程度上是由软件的效率和作用来表征的，而软件性能的发挥又离不开硬件的支持。对某一功能来说，若其既可以用软件实现，又可以用硬件实现，则称为软/硬件在逻辑功能上是等价的。在设计计算机系统时，要进行软/硬件的功能分配。通常来说，一个功能若使用较为频繁且用硬件实现的成本较为理想，则使用硬件解决可以提高效率。  
# 1.2.2计算机硬件  

# 1.冯·诺依曼机基本思想  

>#### pro： 冯·诺依曼计算机的特点（2019）  

冯·诺依曼在研究EDVAC机时提出了“存储程序”的概念，“存储程序”的思想奠定了现代计算机的基本结构，以此概念为基础的各类计算机统称冯·诺依曼机，其特点如下：  

1）采用“存储程序”的工作方式。  

2）计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备5大部件组成3）指令和数据以同等地位存储在存储器中，形式上没有区别，但计算机应能区分它们。  

4）指令和数据均用二进制代码表示。  

5）指令由操作码和地址码组成，操作码指出操作的类型，地址码指出操作数的地址。  

“存储程序”的基本思想是：将事先编制好的程序和原始数据送入主存储器后才能执行，一旦程序被启动执行，就无须操作人员的干预，计算机会自动逐条执行指令，直至程序执行结束。  

# 2.计算机的功能部件  

>#### pro：  

# MAR和MDR位数的概念和计算（2010、2011）  

（1）输入设备  

输入设备的主要功能是将程序和数据以机器所能识别和接受的信息形式输入计算机。最常用也最基本的输入设备是键盘，此外还有鼠标、扫描仪、摄像机等。  

# （2）输出设备  

输出设备的任务是将计算机处理的结果以人们所能接受的形式或其他系统所要求的信息形式输出。最常用、最基本的输出设备是显示器、打印机。输入/输出设备（简称1/O设备）是计算机与外界联系的桥梁，是计算机中不可缺少的重要组成部分。  

# （3）存储器  

存储器分为主存储器（也称内存储器或主存）和辅助存储器（也称外存储器或外存）。CPU能够直接访问的存储器是主存储器。辅助存储器用于帮助主存储器记忆更多的信息，辅助存储器中的信息必须调入主存储器后，才能为CPU所访问。主存储器的工作方式是按存储单元的地址进行存取，这种存取方式称为按地址存取方式。  

主存储器的最基本组成如图1.1所示。存储体存放二进制信息，存储器地址寄存器（MAR）存放访存地址，经过地址译码后找到所选的存储单元。存储器数据寄存器（MDR）用于暂存要从存储器中读或写的信息，时序控制逻辑用于产生存储器操作所需的各种时序信号。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/36517a18494fdeb8a07395f328a28abdfbd453d9dab3e6d2c9c8c828b2a23076.jpg)  
图1.1主存储器逻辑图  
存储体由许多存储单元组成，每个存储单元包含若干存储元件，每个存储元件存储一位二进 制代码“0”或“1”。因此存储单元可存储一串二进制代码，称这事代码为存储字，称这事代码的位数为存储字长，存储字长可以是1B（8bit）或是字节的偶数倍。  

MAR用于寻址，其位数反映最多可寻址的存储单元的个数，如MAR为10位，则最多有 $2^{10}\!=\!1024$ 个存储单元，记为1K。MAR的长度与PC的长度相等。  

MDR的位数通常等于存储字长，一般为字节的2次幂的整数倍。  

# 注意  

MAR与MDR虽然是存储器的一部分，但在现代计算机中却是存在于CPU中的；另外，后文提到的高速缓存（Cache）也存在于CPU中。  

# (4）运算器  

运算器是计算机的执行部件，用于进行算术运算和逻辑运算。算术运算是按算术运算规则进行的运算，如加、减、乘、除；逻辑运算包括与、或、非、异或、比较、移位等运算。  

运算器的核心是算术逻辑单元（ArithmeticandLogicUnit，ALU）。运算器包含若干通用寄存器，用于暂存操作数和中间结果，如累加器（ACC）、乘商寄存器（MQ）、操作数寄存器（X）、变址寄存器（IX）、基址寄存器（BR）等，其中前三个寄存器是必须具备的。  

运算器内还有程序状态寄存器（PSW），也称标志寄存器，用于存放ALU运算得到的一些标志信息或处理机的状态信息，如结果是否溢出、有无产生进位或借位、结果是否为负等。  

# （5）控制器  

控制器是计算机的指挥中心，由其“指挥”各部件自动协调地进行工作。控制器由程序计数器（PC）、指令寄存器（IR）和控制单元（CU）组成。  

PC用来存放当前欲执行指令的地址，具有自动加1的功能（这里的“1”指一条指令的长度），即可自动形成下一条指令的地址，它与主存储器的MAR之间有一条直接通路。  

IR用来存放当前的指令，其内容来自主存储器的MDR。指令中的操作码OP（IR)送至CU，用以分析指令并发出各种微操作命令序列：而地址码Ad（IR)送往MAR，用以取操作数。  

一般将运算器和控制器集成到同一个芯片上，称为中央处理器（CPU)。CPU和主存储器共同构成主机，而除主机外的其他硬件装置（外存、I/O设备等）统称外部设备，简称外设。  

图1.2所示为冯·诺依曼结构的模型机。CPU包含ALU、通用寄存器组GPRs、标志寄存器、控制器、指令寄存器IR、程序计数器PC、存储器地址寄存器MAR和存储器数据寄存器MDR。图中从控制器送出的虚线就是控制信号，可以控制如何修改PC以得到下一条指令的地址，可以控制ALU执行什么运算，可以控制主存储器是进行读操作还是写操作（读/写控制信号）。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e5599c11147c84255a3bcb6e68a0e63ecce4c3c670d01ea80490c4c98da2c745.jpg)  
图1.2冯·诺依曼结构的模型机  
CPU和主存储器之间通过一组总线相连，总线中有地址、控制和数据3组信号线。MAR中的地址信息会直接送到地址线上，用于指向读/写操作的主存储器存储单元；控制线中有读/写信号线，指出数据是从CPU写入主存储器还是从主存储器读出到CPU，根据是读操作还是写操作来控制将MDR中的数据是直接送到数据线上还是将数据线上的数据接收到MIDR中。  

# 1.2.3计算机软件  

# 1.系统软件和应用软件  

软件按其功能分类，可分为系统软件和应用软件。  

系统软件是一组保证计算机系统高效、正确运行的基础软件，通常作为系统资源提供给用户使用。系统软件主要有操作系统（OS）、数据库管理系统（DBMS）、语言处理程序、分布式软件系统、网络软件系统、标准库程序、服务性程序等。  

应用软件是指用户为解决某个应用领域中的各类问题而编制的程序，如各种科学计算类程序、工程设计类程序、数据统计与处理程序等。  

在本学科范畴内，编写诸如操作系统、编译程序等各种系统软件的人员称为系统程序员；利用计算机及所支持的系统软件来编写解决具体应用问题的人员称为应用程序员。  

# 2.三个级别的语言  

>#### pro：三种机器语言的特点（2015）  

1）机器语言。也称二进制代码语言，需要编程人员记忆每条指令的二进制编码。机器语言是计算机唯一可以直接识别和执行的语言。2）汇编语言。汇编语言用英文单词或其缩写代替二进制的指令代码，更容易为人们记忆和理解。使用汇编语言编辑的程序，必须经过一个称为汇编程序的系统软件的翻译，将其转换为机器语言程序后，才能在计算机的硬件系统上执行。3）高级语言。高级语言（如C、 $C++$ 、Java等）是为方便程序设计人员写出解决问题的处理方案和解题过程的程序。通常高级语言需要经过编译程序编译成汇编语言程序，然后经过汇编操作得到机器语言程序，或直接由高级语言程序翻译成机器语言程序。  

>#### pro：各种翻译程序的概念（2016）  

因此计算机无法直接理解和执行高级语言程序，所以需要将高级语言程序转换为机器语言程序，通常把进行这种转换的软件系统称翻译程序。翻译程序有以下三类：  

1）汇编程序（汇编器）。将汇编语言程序翻译成机器语言程序。2）解释程序（解释器）。将源程序中的语句按执行顺序逐条翻译成机器指令并立即执行。3）编译程序（编译器）。将高级语言程序翻译成汇编语言或机器语言程序。  

# 3.软件和硬件的逻辑功能等价性  

硬件实现的往往是最基本的算术和逻辑运算功能，而其他功能大多通过软件的扩充得以实现。对某一功能来说，既可以由硬件实现，又可以由软件实现，从用户的角度来看，它们在功能上是等价的。这一等价性被称为软/硬件逻辑功能的等价性。例如，浮点数运算既可以用专门的浮点运算器硬件实现，又可以通过一段子程序实现，这两种方法在功能上完全等效，不同的只是执行时间的长短而已，显然硬件实现的性能要优于软件实现的性能。  

软件和硬件逻辑功能的等价性是计算机系统设计的重要依据，软件和硬件的功能分配及其界面的确定是计算机系统结构研究的重要内容。当研制一台计算机时，设计者必须明确分配每一级的任务，确定哪些功能使用硬件实现，哪些功能使用软件实现。软件和硬件功能界面的划分是由设计目标、性能价格比、技术水平等综合因素决定的。  
# 1.2.4计算机系统的层次结构  

计算机是一个硬软件组成的综合体。因为面对的应用范围越来越广，所以必须有复杂的系统软件和硬件的支持。由于软/硬件的设计者和使用者从不同的角度、用不同的语言来对待同个计算机系统，因此他们看到的计算机系统的属性对计算机系统提出的要求也就各不相同。  

计算机系统的多级层次结构的作用，就是针对上述情况，根据从各种角度所看到的机器之间的有机联系，来分清彼此之间的界面，明确各自的功能，以便构成合理、高效的计算机系统。  

关于计算机系统层次结构的分层方式，目前尚无统一的标准，这里采用如图1.3所示的层次结构。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ba10a968e6fa79eefcc9bdc76353183bb076480dd94dd122497668c14bb47a43.jpg)  
图1.3计算机系统的多级层次结构  

第1级是微程序机器层，这是一个实在的硬件层，它由机器硬件直接执行微指令。第2级是传统机器语言层，它也是一个实际的机器层，由微程序解释机器指令系统  

第3级是操作系统层，它由操作系统程序实现。操作系统程序是由机器指令和广义指令组成的，这些广义指令是为了扩展机器功能而设置的，是由操作系统定义和解释的软件指令，所以这一层也称混合层。  

第4级是汇编语言层，这一层由汇编程序支持和执行，借此可编写汇编语言源程序。  

第5级是高级语言层，它是面向用户的，是为方便用户编写应用程序而设置的。该层由各种高级语言编译程序支持和执行。在高级语言层之上，还可以有应用程序层，它由解决实际问题的处理程序组成，如文字处理软件、多媒体处理软件和办公自动化软件等。  

没有配备软件的纯硬件系统称裸机。第3层～第5层称为虚拟机，简单来说就是软件实现的机器。虚拟机器只对该层的观察者存在，这里的分层和计算机网络的分层类似，对于某层的观察者来说，只能通过该层的语言来了解和使用计算机，而不必关心下层是如何工作的。  

层次之间的关系紧密，下层是上层的基础，上层是下层的扩展。  

软件和硬件之间的界面就是指令集体系结构（ISA），ISA定义了一台计算机可以执行的所有指令的集合，每条指令规定了计算机执行什么操作，以及所处理的操作数存放的地址空间和操作数类型。可以看出，ISA是指软件能感知到的部分，也称软件可见部分。  

本门课程主要讨论传统机器M1和微程序机器M0的组成原理及设计思想。  
# 1.2.5计算机系统的工作原理  

# 1.“存储程序”工作方式  

“存储程序”工作方式规定，程序执行前，需要将程序所含的指令和数据送入主存储器，一旦程序被启动执行，就无须操作人员的干预，自动逐条完成指令的取出和执行任务。如图1.4所示，一个程序的执行就是周而复始地执行一条一条指令的过程。每条指令的执行过程包括：从主存储器中取指令、对指令进行译码、计算下条指令地址、取操作数并执行、将结果送回存储器。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/92147f3b866cf96839105ec932140b0e4ff184d56cbe32653f7a5a310837bacb.jpg)  
图1.4程序执行过程  

程序执行前，先将程序第一条指令的地址存放到PC中，取指令时，将PC的内容作为地址访问主存储器。在每条指令执行过程中，都需要计算下条将执行指令的地址，并送至PC。若当前指令为顺序型指令，则下条指令地址为PC的内容加上当前指令的长度；若当前指令为转跳型指令，则下条指令地址为指令中指定的目标地址。当前指令执行完后，根据PC的内容到主存储器中取出的是下一条将要执行的指令，因而计算机能周而复始地自动取出并执行一条一条的指令。  

# 2.从源程序到可执行文件  

>#### pro：翻译过程的四个阶段（2022）  

在计算机中编写的C语言程序，都必须被转换为一系列的低级机器指令，这些指令按照一种称为可执行目标文件的格式打好包，并以二进制磁盘文件的形式存放起来。  

以UNIX系统中的GCC编译器程序为例，读取源程序文件hello.c，并把它翻译成一个可执行自标文件hello，整个翻译过程可分为四个阶段完成，如图1.5所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/32b38423c35a842f0ba819ce89774db99c0a25717ce5fb9005ae757f21a9a38b.jpg)  
图1.5源程序转换为可执行文件的过程  

1）预处理阶段：预处理器（cpp）对源程序中以字符#开头的命令进行处理，例如将#include命令后面的.h文件内容插入程序文件。输出结果是一个以i为扩展名的源文件hello.i。  

2）编译阶段：编译器（cc1）对预处理后的源程序进行编译，生成一个汇编语言源程序hello.s。汇编语言源程序中的每条语句都以一种文本格式描述了一条低级机器语言指令。  
3）汇编阶段：汇编器（as）将hello.s翻译成机器语言指令，把这些指令打包成一个称为可重定位自标文件hello.o，它是一种二进制文件，因此用文本编辑器打开会显示乱码。  

4）链接阶段：链接器（ld）将多个可重定位目标文件和标准库函数合并为一个可执行目标文件，简称可执行文件。本例中，链接器将hello.o和标准库函数printf所在的可重定位目标模块printf.o合并，生成可执行文件hello。最终生成的可执行文件被保存在磁盘上。  

# 3.指令执行过程的描述  

可执行文件代码段是由一条一条机器指令构成的，指令是用0和1表示的一串0/1序列，用来指示CPU完成一个特定的原子操作。例如，取数指令从存储单元中取出一个数据送到CPU的寄存器中，存数指令将CPU寄存器的内容写入一个存储单元，ALU指令将两个寄存器的内容进行某种算术或逻辑运算后送到一个CPU寄存器中，等等。指令的执行过程在第5章中详细描述。下面以取数指令（送至运算器的ACC中）为例来说明，其信息流程如下：  

# 1）取指令：PC→MAR→M→MDR-IR  

根据PC取指令到IR。将PC的内容送MAR，MAR中的内容直接送地址线，同时控制器将读信号送读/写信号线，主存储器根据地址线上的地址和读信号，从指定存储单元读出指令，送到数据线上，MDR从数据线接收指令信息，并传送到IR中。  

2）分析指令：OP(IR)→CU  

指令译码并送出控制信号。控制器根据IR中指令的操作码，生成相应的控制信号，送到不同的执行部件。在本例中，IR中是取数指令，因此读控制信号被送到总线的控制线上。  

3）执行指令：Ad(IR)→MAR→M→MDR→ACC  

取数操作。将IR中指令的地址码送MAR，MAR中的内容送地址线，同时控制器将读信号送读/写信号线，从主存储器中读出操作数，并通过数据线送至MIDR，再传送到ACC中。  

每取完一条指令，还须为取下条指令做准备，计算下条指令的地址，即 $(\mathrm{PC})+1{\rightarrow}\mathrm{PC}$  

# 注意  

(PC)指程序计数器PC中存放的内容。 $\mathsf{P C}\!\to\!\mathsf{M A R}$ 应理解为 $(\mathrm{PC}){\rightarrow}\mathrm{MAR}$ ，即程序计数器中的值经过数据通路送到MAR，也即表示数据通路时括号可省略（因为只是表示数据流经的途径，而不强调数据本身的流动）。但运算时括号不能省略，即 $(\mathrm{PC})+1{\rightarrow}\mathrm{PC}$ 不能写为 $\mathrm{PC}+1{\rightarrow}\mathrm{PC}.$ 当题目中(PC)→MAR的括号未省略时，考生最好也不要省略。  

# 1.3计算机的性能指标  

# 1.3.1计算机的主要性能指标  

1.机器字长  

>#### pro：与机器字长位数相同的部件（2020、2021）  

通常所说的“某16位或32位机器”，其中的16、32指的是机器字长，简称字长。字长是指计算机进行一次整数运算（即定点整数运算）所能处理的二进制数据的位数，通常与CPU的寄存器位数、ALU有关。因此，字长一般等于通用寄存器的位数或ALU的宽度，字长越长，数的表示范围越大，计算精度越高。计算机字长通常选定为字节（8位）的整数倍。  

# 注意  

机器字长、指令字长和存储字长的关系（见章末的常见问题3）  
2.数据通路带宽  

数据通路带宽是指数据总线一次所能并行传送信息的位数。这里所说的数据通路宽度是指外部数据总线的宽度，它与CPU内部的数据总线宽度（内部寄存器的大小）有可能不同。  

# 注意  

各个子系统通过数据总线连接形成的数据传送路径称为数据通路。  

3.主存容量  

主存容量是指主存储器所能存储信息的最大容量，通常以字节来衡量，也可用字数 $\times$ 字长（如 $512\mathrm{K}{\times}16$ 位）来表示存储容量。其中，MAR的位数反映了存储单元的个数，MDR的位数反映了存储单元的字长。例如，MAR为16位，表示 $2^{16}\!=\!65536$ ，即此存储体内有65536个存储单元（可称为64K内存， $1\mathrm{K}=1024$ ），若MDR为32位，则表示存储容量为 $64\mathrm{K}\!\times\!32$ 位。  

# 4.运算速度  

>#### pro：提高系统性能的综合措施（2010）  

（1）吞吐量和响应时间。  

·吞吐量。指系统在单位时间内处理请求的数量。它取决于信息能多快地输入内存，CPU能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备。几乎每步都关系到主存储器，因此系统吞吐量主要取决于主存储器的存取周期。·响应时间。指从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结果的等待时间。通常包括CPU时间（运行一个程序所花费的时间）与等待时间（用于磁盘访问、存储器访问、I/0操作、操作系统开销等的时间）。（2）主频和CPU时钟周期。  

>#### pro：时钟脉冲信号和时钟周期的相关概念（2019）  

）CPU时钟周期。机器内部主时钟脉冲信号的宽度，它是CPU工作的最小时间单位  

时钟脉冲信号由机器脉冲源发出的脉冲信号经整形和分频后形成。时钟周期以相邻状态单元间组合逻辑电路的最大延迟为基准确定。时钟周期也以指令流水线的每个流水段的最大延迟时间确定。  

>#### pro：主频和时钟周期的转换计算（2013）  

·主频（CPU时钟频率）。机器内部主时钟的频率，即时钟周期的倒数，它是衡量机器速度的重要参数。对于同一个型号的计算机，其主频越高，完成指令的一个执行步骤所用的时间越短，执行指令的速度越快。主频最直观的理解就是每秒有多少个时钟周期。  

# 注意  

CPU时钟周期 $=1/$ 主频，主频通常以Hz（赫兹）为单位， $10\mathrm{Hz}$ 表示每秒10次。（3）CPI（Cycle Per Instruction），。  

>#### pro：IPS的相关计算（2023）  

不同指令的时钟周期数可能不同，因此对于一个程序或一台机器来说，其CPI指该程序或该机器指令集中的所有指令执行所需的平均时钟周期数，此时CPI是一个平均值。  
·IPS（Instructions Per Second），即每秒执行多少条指令， ${\mathrm{IPS}}=$ 主频/平均CPI。（4）CPU执行时间。指运行一个程序所花费的时间。  

>#### pro：CPU执行时间的相关计算（2012、2013、2014、2017、2022、2023）CPU执行时间 $=$ CPU时钟周期数/主频 $=$ （指令条数 $\times\mathrm{CPI}$ 主频  

上式表明，CPU的性能（CPU执行时间）取决于三个要素：主频、CPI和指令条数。主频、CPI和指令条数是相互制约的。例如，更改指令集可以减少程序所含的指令条数，但同时可能引起CPU结构的调整，从而可能会增加时钟周期的宽度（降低主频）。  

【例1.1】假定计算机M1和M2具有相同的指令集体系结构，M1的主频为 $2\mathrm{GHz}$ ，程序P在M1上的运行时间为 $10s$ 。M2采用新技术可使主频大幅提升，但平均CPI也增加到M1的1.5倍。则M2的主频至少提升到多少才能使程序P在M2上的运行时间缩短为6s？  

# 解：  

程序P在M1上的时钟周期数 $=$ 指令条数 $\times\mathrm{CPI}=$ CPU执行时间 $\times$ 主频 $=10\mathrm{s}{\times}2\mathrm{GHz}=2{\times}10^{10}$ M2的平均CPI为M1的1.5倍，因此程序P在M2上的时钟周期数 $=1.5{\times}2{\times}10^{10}\!=3{\times}10^{10}$  

要使程序P在M2上的运行时间缩短到6s，则M2的主频至少应为程序P所含时钟周期数-CPU执行时间 $=3{\times}10^{10}{\div}6\mathrm{s}=5\mathrm{GHz}$ 由此可见，M2的主频是M1的2.5倍，但M2的速度却只是M1的1.67倍。（5）MIPS（Million Instructions Per Second），。  

>#### pro：MIPS相关的计算（2012、2013）  

$\mathrm{{MIPS}=}$  指令条数÷(执行时间  $\times10^{6})=$  主频  $_\div(\mathbf{CPI}\times10^{6})$  

MIPS对不同机器进行性能比较是有缺陷的，因为不同机器的指令集不同，指令的功能也就不同，比如在机器M1上某条指令的功能也许在机器M2上要用多条指令来完成；不同机器的CPI和时钟周期也不同，因而同一条指令在不同机器上所用的时间也不同。  

（6）FLOPS（Floating-point Operations Per Second），。>#### pro：浮点数运算指标的概念（2011、2021）  

·MFLOPS（Million FLOPS），即每秒执行多少百万（ $10^{6}$ ）次浮点运算。·GFLOPS（GigaFLOPS），即每秒执行多少十亿（ $10^{9}$ ）次浮点运算。·TFLOPS（TeraFLOPS），即每秒执行多少万亿（ $10^{12}$ ）次浮点运算。·PFLOPS（PetaFLOPS），即每秒执行多少千万亿（ $10^{15}$ ）次浮点运算。·EFLOPS（ExaFLOPS），即每秒执行多少百京（ $(10^{18}$ ）次浮点运算（1京 $=1$ 亿亿 $=10^{16}$ )。·ZFLOPS（ZettaFLOPS），即每秒执行多少十万京（ $10^{21}$ ）次浮点运算。  

# 注意  

在描述存储容量、文件大小等时，K、M、G、T通常用2的幂次表示，如 $1\mathrm{Kb}=2^{10}\mathrm{b}$ 在描述速率、频率等时，k、M、G、T通常用10的幂次表示，如 $1\,\mathrm{{kb}/\mathrm{{s}=10^{3}\mathrm{{b}/\mathrm{{s}.}}}}$ 通常前者用大写的K，后者用小写的k，但其他前缀均为大写，表示的含义取决于所用的场景。  

# 5.基准程序  

基准程序（Benchmarks）是专门用来进行性能评价的一组程序，能够很好地反映机器在运行实际负载时的性能，可以通过在不同机器上运行相同的基准程序来比较在不同机器上的运行时间，从而评测其性能。对于不同的应用场合，应该选择不同的基准程序。  
使用基准程序进行计算机性能评测也存在一些缺陷，因为基准程序的性能可能与某一小段的短代码密切相关，而硬件系统设计人员或编译器开发者可能会针对这些代码片段进行特殊的优化，使得执行这段代码的速度非常快，以至于得不到准确的性能评测结果。  

# 1.3.2几个专业术语  

1）系列机。具有基本相同的体系结构，使用相同基本指令系统的多个不同型号的计算机组成的一个产品系列。2）兼容。指软件或硬件的通用性，即运行在某个型号的计算机系统中的硬/软件也能应用于另一个型号的计算机系统时，称这两台计算机在硬件或软件上存在兼容性。3）固件。将程序固化在ROM中组成的部件称为固件。固件是一种具有软件特性的硬件，吸收了软件/硬件各自的优点，其执行速度快于软件，灵活性优于硬件，是软/硬件结合的产物。例如，目前操作系统已实现了部分固化（把软件永恒地存储于ROM中）。  



# 1.4 本章小结  

本章开头提出的问题的参考答案如下。  

1）计算机由哪几部分组成？以哪部分为中心？  

计算机由运算器、控制器、存储器、输入设备及输出设备五大部分构成，现代计算机通常把运算器和控制器集成在一个芯片上，合称中央处理器。  

在微处理器面世之前，运算器和控制器分离，而且存储器的容量很小，因此设计成以运算器为中心的结构，其他部件都通过运算器完成信息的传递。随着微电子技术的发展，同时计算机需要处理、加工的信息量也与日俱增，大量I/O设备的速度和CPU的速度差距悬殊，因此以运算器为中心的结构不能满足计算机发展的要求。现代计算机已发展为以存储器为中心，使I/O操作尽可能地绕过CPU，直接在I/O设备和存储器之间完成，以提高系统的整体运行效率。  

2）主频高的CPU一定比主频低的CPU快吗？为什么？  

衡量CPU运算速度的指标有很多，不能以单独的某个指标来判断CPU的好坏。CPU的主频表示CPU内数字脉冲信号振荡的速度，主频和实际的运算速度存在一定的关系，但目前还没有一个确定的公式能够定量两者的数值关系，因为CPU的运算速度还要看CPU的流水线的各方面的性能指标（架构、缓存、指令集、CPU的位数、Cache大小等）。由于主频并不直接代表运算速度，因此在一定情况下很可能会出现主频较高的CPU实际运算速度较低的现象。  

3）翻译程序、汇编程序、编译程序、解释程序有什么差别？各自的特性是什么？  

见常见问题和易混淆知识点1。  

4）不同级别的语言编写的程序有什么区别？哪种语言编写的程序能被硬件直接执行？  

机器语言和汇编语言与机器指令对应，而高级语言不与指令直接对应，具有较好的可移植性。其中机器语言编写的程序可以被硬件直接执行。  
# 1.5常见问题和易混淆知识点  

1.翻译程序、解释程序、汇编程序、编译程序的区别和联系是什么？  

翻译程序有两种：一种是编译程序，它将高级语言源程序一次全部翻译成目标程序，只要源程序不变，就无须重新翻译。另一种是解释程序，它将源程序的一条语句翻译成对应的机器目标代码，并立即执行，然后翻译下一条源程序语句并执行，直至所有源程序语句全部被翻译并执行完。所以解释程序的执行过程是翻译一句执行一句，并且不会生成目标程序。  

汇编程序也是一种语言翻译程序，它把汇编语言源程序翻译为机器语言程序。  

编译程序与汇编程序的区别：若源语言是诸如C、 $\mathrm{C++}$ 、Java等“高级语言”，而目标语言是诸如汇编语言或机器语言之类的“低级语言”，则这样的一个翻译程序称为编译程序。若源语言是汇编语言，而目标语言是机器语言，则这样的一个翻译程序称为汇编程序。  

# 2.什么是透明性？透明是指什么都能看见吗？  

在计算机领域中，站在某类用户的角度，若感觉不到某个事物或属性的存在，即“看”不到某个事物或属性，则称为“对该用户而言，某个事物或属性是透明的”。这与日常生活中的“透明”概念（公开、看得见）正好相反。例如，对于高级语言程序员来说，浮点数格式、乘法指令等这些指令的格式、数据如何在运算器中运算等都是透明的；而对于机器语言或汇编语言程序员来说，指令的格式、机器结构、数据格式等则不是透明的。  

在CPU中，IR、MAR和MDR对各类程序员都是透明的。3.字、字长、机器字长、指令字长、存储字长的区别和联系是什么？  

字长是指CPU内部用于整数运算的数据通路的宽度，因此字长等于CPU内部用于整数运算的运算器位数和通用寄存器宽度，它反映了计算机处理信息的能力。字和字长的概念不同。字用来表示被处理信息的单位，用来度量数据类型的宽度，如 $\mathrm{x86}$ 机器中将一个字定义为16位。  

指令字长：一个指令字中包含的二进制代码的位数。  

存储字长：一个存储单元存储的二进制代码的位数。  

它们都必须是字节的整数倍。  

指令字长一般取存储字长的整数倍，若指令字长等于存储字长的2倍，则需要2个访存周期来取出一条指令：若指令字长等于存储字长，则取指令周期等于机器周期。  

早期的存储字长一般与指令字长、字长相等，因此访问一次主存储器便可取出一条指令或一个数据。随着计算机的发展，指令字长、字长都可变，但必须都是字节的整数倍。  

4.计算机体系结构和计算机组成的区别和联系是什么？  

计算机体系结构是指机器语言或汇编语言程序员所看得到的传统机器的属性，包括指令集、数据类型、存储器寻址技术等，大都属于抽象的属性。  

计算机组成是指如何实现计算机体系结构所体现的属性，它包含许多对程序员来说透明的硬件细节。例如，指令系统属于结构的问题，但指令的实现即如何取指令、分析指令、取操作数、如何运算等都属于组成的问题。因此，当两台机器的指令系统相同时，只能认为它们具有相同的结构，至于这两台机器如何实现其指令，则完全可以不同，即可以认为它们的组成方式是不同的。例如，一台机器是否具备乘法指令是一个结构的问题，但实现乘法指令采用什么方式则是一个组成的问题。许多计算机厂商提供一系列体系结构相同的计算机，而它们的组成却有相当大的差别，即使是同一系列的不同型号机器，其性能和价格差异也很大。  
5.基准程序执行得越快说明机器的性能越好吗？  

一般情况下，基准测试程序能够反映机器性能的好坏。但是，由于基准程序中的语句存在频度的差异，因此运行结果并不能完全说明问题。  
# 第2章数据的表示和运算  

# 【考纲内容】  

（一）数制与编码进位计数制及其相互转换；定点数的编码表示  

（二）运算方法和运算电路  

基本运算部件：加法器：算术逻辑单元（ALU）加/减运算：补码加/减运算器：标志位的生成乘/除运算：乘/除法运算的基本原理：乘法电路和除法电路的基本结构  

（三）整数的表示和运算  

无符号整数的表示和运算：有符号整数的表示和运算  

（四）浮点数的表示和运算  

浮点数的表示：IEEE754标准：浮点数的加/减运算  

# 【复习提示】  

本章内容较为繁杂，由于计算机中数的表示和运算方法与人们日常生活中的表示和运算方法不同，因此理解也较为困难。纵观历年统考真题，unsigned、short、int、long、float、double等在C语言中的表示、运算、溢出判断、隐式类型转换、强制类型转换、IEEE754浮点数的表示以及浮点数的运算，都是考研考查的重点，需要牢固掌握。  

在学习本章时，请读者思考以下问题：  

1）在计算机中，为什么要采用二进制来表示数据？2）计算机在字长足够的情况下能够精确地表示每个数吗？若不能，请举例说明3）字长相同的情况下，浮点数和定点数的表示范围与精度有什么区别？  

请读者在本章的学习过程中寻找答案，本章末尾会给出参考答案。  

# 2.1数制与编码  

# 2.1.1进位计数制及其相互转换  

>#### pro：采用二进制编码的原因（2018）  

在计算机系统内部，所有信息都是用二进制进行编码的，这样做的原因有以下几点。1）二进制只有两种状态，使用有两个稳定状态的物理器件就可以表示二进制数的每一位，  
制造成本比较低，例如用高低电乎或电荷的正负极性都可以很方便地表示0和1。  

2）二进制位1和0正好与逻辑值“真”和“假”相对应，为计算机实现逻辑运算和程序中的逻辑判断提供了便利条件。3）二进制的编码和运算规则都很简单，通过逻辑门电路能方便地实现算术运算。  

# 1.进位计数法  

常用的进位计数法有十进制、二进制、八进制、十六进制等。十进制数是日常生活中最常使用的，而计算机中通常使用二进制数、八进制数和十六进制数。  

在进位计数法中，每个数位所用到的不同数码的个数称为基数。十进制的基数为 $10\ (0{\sim}9)$ 每个数位计满10就向高位进位，即“逢十进一”。十进制数101，其个位的1显然与百位的1所表示的数值是不同的。每个数码所表示的数值等于该数码本身乘以一个与它所在数位有关的常数，这个常数称为位权。一个进位数的数值大小就是它的各位数码按权相加。  

一个 $r$ 进制数（ $K_{n}K_{n-1}...K_{0}K_{-1}...K_{-m}$ ）的数值可表示为  

$$
K_{n}r^{n}+K_{n-1}r^{n-1}+\dots+K_{0}r^{0}+K_{-1}r^{-1}+\dots+K_{-m}r^{-m}=\sum_{i=n}^{-m}K_{i}r^{i}
$$  

式中， $r$ 是基数； $r^{j}$ 是第 $i$ 位的位权； $K_{i}$ 的取值可以是 $0,1,\cdots,r-1$ 共 $r$ 个数码中的任意一个。  

1）二进制。计算机中用得最多的是基数为2的计数制，即二进制。二进制只有0和1两种数码，计数“逢二进一”。它的任意数位的权为 $2^{i},\textit{i}$ 为所在位数。2）八进制。基数为8，有 $_{0\sim7}$ 共8个不同的数码。计数逢八进一。因为 $r\!=\!8\!=\!2^{3}$ ，所以把二进制中的3位数码编为一组就是1位八进制数码，两者之间的转换极为方便。3）十六进制。基数为16，有 $_{0\sim9}$ 、A～F共16个不同的数码，其中 $\scriptstyle\mathrm{A}\sim\operatorname{F}$ 分别表示 $10{\sim}15$ 计数逢十六进一。因为 $r\!=\!16\!=\!2^{4}$ ，所以4位二进制数码与1位十六进制数码相对应。  

可以用后缀字母标识一个数的进位计数制，用B表示二进制，用O表示八进制，用D表示十进制（通常直接省略），用H表示十六进制，有时也用前缀0x表示十六进制数。  

# 2.不同进制数之间的相互转换  

（1）二进制数转换为八进制数和十六进制数  

对于一个二进制混合数（既包含整数部分，又包含小数部分），在转换时应以小数点为界。其整数部分，从小数点开始往左数，将一串二进制数分为3位（八进制）一组或4位（十六进制）一组，在数的最左边可根据需要加“0”补齐；对于小数部分，从小数点开始往右数，也将一串二进制数分为3位一组或4位一组，在数的最右边也可根据需要加“0”补齐。最终使总的位数为3或4的整数倍，然后分别用对应的八进制数或十六进制数取代。  

【例2.1】将二进制数1111000010.01101分别转换为八进制数和十六进制数。  

解：  

高位补0，凑足3位分界点低位补0，凑足3位↓ ↓ ↓ 001 111 000 010 011 010  

所以，对应的八进制数为 $(1702.32)_{8}\!=\!(1111000010.01101)_{2}\!\circ$  

所以，对应的十六进制数为 $(3C2.68)_{16}\!=\!(1111000010.01101)_{2}.$  
同样，由八进制数或十六进制数转换为二进制数，只需将每位改为3位或4位二进制数即可（必要时去掉整数最高位或小数最低位的0）。八进制数和十六进制数之间的转换也能方便地实现，十六进制数转换为八进制数（或八进制数转换为十六进制数）时，先将十六进制（八进制）数转换为二进制数，然后由二进制数转换为八进制（十六进制）数较方便。  

（2）任意进制数转换为十进制数  

将任意进制数的各位数码与它们的权值相乘，再把乘积相加，就得到了一个十进制数。这种方法称为按权展开相加法。例如， $(11011.1)_{2}\!=\!1\!\times\!2^{4}+1\!\times\!2^{3}+0\!\times\!2^{2}+1\!\times\!2^{1}+1\!\times\!2^{0}+1\!\times\!2^{-1}\!=\!27.5.$  

（3）十进制数转换为任意进制数  

>#### pro：十进制小数转换为二进制小数（2021、2022）  

一个十进制数转换为任意进制数，通常采用基数乘除法。这种转换方法对十进制数的整数部分和小数部分将分别进行处理，对整数部分采用除基取余法，对小数部分采用乘基取整法，最后将整数部分与小数部分的转换结果拼接起来。  

# 【例2.2】将十进制数123.6875转换成二制数。  

解：  

除基取余法（整数部分）：整数部分除基取余，最先取得的余数为数的最低位，最后取得的余数为数的最高位（即除基取余，先余为低，后余为高），商为0时结束。  

整数部分：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/196d6836af60c957474613cc5ddd3a50ef583549c205aab5dacf92ff151c2a8d.jpg)  

因此整数部分 $123\,{=}\,(1111011)_{2},$  

乘基取整法（小数部分）：小数部分乘基取整，最先取得的整数为数的最高位，最后取得的整数为数的最低位（即乘基取整，先整为高，后整为低），乘积为1.0（或满足精度要求）时结束。  

小数部分：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/54b7b8f03f6b150f058aee1bb6d9ab852907ade2d8ae065083cd2a78b401736d.jpg)  

因此小数部分 $0.6875\!=\!(0.1011)_{2}$ ，所以 $123.6875\!=\!(1111011.1011)_{2}.$  

# 注意  

关于十进制数转换为任意进制数为何采用除基取余法和乘基取整法，以及所取之数放置位置的原理，请结合 $r$ 进制数的数值表示公式思考，而不应死记硬背。  
# 注意  

在计算机中，小数和整数不一样，整数可以连续表示，但小数是离散的，所以并不是每个十进制小数都可以准确地用二进制表示。例如0.3，无论经过多少次乘二取整转换都无法得到精确的结果。但任意一个二进制小数都可以用十进制小数表示，希望读者引起重视。  

# 2.1.2定点数的编码表示  

# 1.真值和机器数  

在日常生活中，通常用正号、负号来分别表示正数（正号可省略）和负数，如+15、 $^{-8}$ 等。这种带“ $^+$ ”或“-”符号的数称为真值。真值是机器数所代表的实际值。  

在计算机中，通常将数的符号和数值部分一起编码，将数据的符号数字化，通常用“0”表示“正”，用“1”表示“负”。这种把符号“数字化”的数称为机器数。常用的有原码、补码和反码表示法。如0,101（这里的逗号“”仅为区分符号位与数值位）表示 $^{+5}$  

# 2.机器数的定点表示  

根据小数点的位置是否固定，在计算机中有两种数据格式：定点表示和浮点表示。在现代计算机中，通常用补码整数表示整数，用原码小数表示浮点数的尾数部分，用移码表示浮点数的阶码部分，历年统考真题的命题信息也主要落在这个范畴之内。  

定点表示法用来表示定点小数和定点整数。  

1）定点小数。定点小数是纯小数，约定小数点位置在符号位之后、有效数值部分最高位之前。若数据 $X$ 的形式为 $X=x_{0}.x_{1}x_{2}...x_{n}$ （其中 $x_{0}$ 为符号位， $x_{1}{\sim}x_{n}$ 是数值的有效部分，也称尾数， $x_{1}$ 为最高有效位），则在计算机中的表示形式如图2.1所示。  

2）定点整数。定点整数是纯整数，约定小数点位置在有效数值部分最低位之后。若数据 $X$ 的形式为 $X\,=\,x_{0}x_{1}x_{2}...x_{n}$ （其中 $x_{0}$ 为符号位， $x_{1}{\sim}x_{n}$ 是尾数， $x_{n}$ 为最低有效位)，则在计算机中的表示形式如图2.2所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4dd1fb5972f1ed936d1fc0ddfb38f8f045ee71a4c4d74334f59f8240e1e90456.jpg)  
图2.2定点整数表示  

事实上，在机器内部并没有小数点，只是人为约定了小数点的位置。因此，在定点数的编码和运算中不用考虑对应的定点数是小数还是整数，而只需关心它们的符号位和数值位即可。  

定点数的编码表示法主要有以下4种：原码、补码、反码和移码。  

# 3.原码、补码、反码、移码  

（1）原码表示法  

用机器数的最高位表示数的符号，其余各位表示数的绝对值。原码的定义如下。  

O,x, 0≤x<2" [x]原 =  $\cdot_{x}$  是真值，字长为  $n+1$  [2"-x=2"+[x], -2"<x≤0  

例如，若 $x_{1}\!=\!+1110$ ， $x_{2}\,{=}\,{-}1110$ ，字长为8位，则其原码表示为 $[x_{1}]_{\mathbb{R}}=\mathbf{0},$ 0001110, $[x_{2}]_{\mathbb{R}}=2^{7}+$  $1110=1,0001110$ ，其中最高位是符号位。  

若字长为 $n+1$ ，则原码整数的表示范围为- $\scriptstyle\cdot(2^{n}-1)\leqslant x\leqslant2^{n}-1$ （关于原点对称）。  
# 注意  

零的原码表示有正零和负零两种形式，即 $[+0]_{\#}=\mathbf{0}0000000$ 和[ $-0]_{\#}=10000000.$  

原码表示的优点： $\textcircled{\scriptsize{1}}$ 与真值的对应关系简单、直观，与真值的转换简单； $\circledcirc$ 用原码实现乘除运算比较简便。缺点： $_{\odot0}$ 的表示不唯一，有 $\pm0$ 两个编码； $\circledcirc$ 原码加减运算比较复杂。在原码加减运算中，对于两个不同符号数的加法（或同符号数的减法），先要比较两个数的绝对值大小，然后用绝对值大的数减去绝对值小的数，最后还要为结果选择合适的符号。  

（2）补码表示法  

补码表示法中的加减运算统一采用加法操作实现。正数的补码和原码相同，负数的补码等于模 $(n+1$ 位补码的模为 $2^{n+1}$ ）与该负数绝对值之差。补码的定义如下：  

$$
[x]_{\#}={\binom{0,x}{2^{n+1}+x=2^{n+1}-\left|x\right|}},\ \ -2^{n}\leqslant x<2^{n}{\pmod{2^{n+1}}}
$$  

综合上述定义可知，无论是正数还是负数， $[x]_{*}\!=\!2^{n+1}\!+x$  $-2^{n}\!\leqslant\!x\!<\!2^{n}$ ，mod $2^{n+1}$ )  

例如，若 $x_{1}\,{=}\,{+}1010$  $x_{2}\!=\!-1101$ ，字长为8位，则其补码表示为 $[x_{1}]_{*}\!=\!\mathbf{0}{,}0001010$ ， $[x_{2}]_{*}=2^{8}$  $0{,}0001101=1{,}1110011$  

>#### pro：补码的表示范围（2010、2013、2014、2022）若字长为 $n+1$ ，则补码整数的表示范围为 $-2^{n}\!\leqslant\!x\!\leqslant\!2^{n}\!-1$ （比原码多表示“ $"-2"$ ”）。  

·几个特殊数据的补码表示1) $[+0]_{*}\!=[-0]_{*}\!=0,\!00...0$ （含符号位共 $n+1$ 个0），说明0的补码表示是唯一的。2) $[-1]_{"}=2^{n+1}\!-\!1=1,\!11...1$ （含符号位共 $n+1$ 个1)。3） $[2^{n}\!-\!\!1]_{*}\!=0,11\dots1$ (n个1)，即 $n+1$ 位补码能表示的最大整数。4） $[-2^{\prime\prime}]_{*}\!=1,\!00...0$  $_{,n}$ 个0)，即 $n+1$ 位补码能表示的最小整数。  

·模运算  

在模运算中，一个数与它除以“模”后得到的余数是等价的，如A、B、 $M$ 满足 $A=B+K{\times}M$  $.K$ 为整数），则记为 $A\!\equiv\!B$ (mod $M)$ ，即 $A,\ B$ 各除以 $M$ 后的余数相同。在补码运算中， $[A]_{\#}-$  $[B]_{*}=[A]_{*}+M-[B]_{*}$ ，而 $M-[B]_{*}=[-B]_{*}$ ，因此补码可以借助加法运算来实现减法运算。  

补码与真值之间的转换  

>#### pro：补码和真值的相互转换（2020、2023）  

真值转换为补码：对于正数，与原码的方式一样。对于负数，符号位取1，其余各位由真值“各位取反，末位加1”得到。补码转换为真值：若符号位为0，与原码的方式一样。若符号位为1，真值的符号为负，数值部分各位由补码“各位取反，末位加1”得到。  

，变形补码  

变形补码是一种采用双符号位的补码表示，也称模4补码。假定变形补码的位数为 $n+1$ (其中符号位占2位，数值位占 $n-1$ 位），则整数变形补码的表示为  

$$
[x]_{\#\#}=\left\{\begin{array}{l l}{00,x,\qquad\qquad\qquad\qquad\quad0\leqslant x<2^{n-1}}\\ {2^{n+1}+x=2^{n+1}-\big|x\big|,\quad\;-2^{n-1}\leqslant x<0}\end{array}\;(\,\mathrm{mod}\,\,\,2^{n+1}\,)\right.
$$  

模4补码双符号位00表示正，11表示负，用在执行算术运算的ALU中。  
（3）反码表示法（了解）  

负数的补码可采用“各位取反，末位加1”的方法得到，若仅各位求反而末尾不加1，则是负数的反码表示，因此负数反码的定义就是在相应的补码表示中再末位减1。  

正数反码的定义和相应的补码（或原码）表示相同。  

反码表示存在以下几个方面的不足： $\textcircled{\scriptsize{1}}$ 0的表示不唯一（即存在 $\pm0$ )； $\circledcirc$ 表示范围比补码少一个最小负数。反码在计算机中很少使用，通常用作数码变换的中间表示形式。  

（4）移码表示法  

移码常用来表示浮点数的阶码，它只能表示整数。  

移码就是在真值 $X$ 上加上一个常数（偏置值），通常这个常数取 $2^{n}$ ，相当于 $X$ 在数轴上向正方向偏移了若干单位，这就是“移码”一词的由来。移码的定义如下。  

$[x]_{\#}\,=2^{n}+x$  $-2^{n}\leqslant x<2^{n}$ ，其中机器字长为 $n+1$  

例如，若正数 $x_{1}\,{=}\,{+}10101$  $x_{2}\!=\!-10101$ ，字长为8位，则其移码表示为 $[x_{1}]_{\#}\!=2^{7}\,+\,10101\!=1,$ 0010101; $[x_{2}]_{\mathrm{i}\mathrm{g}}\,{=}\,2^{7}\,{+}\,(-10101)\,{=}\,0$ ,1101011。  

移码具有以下特点：  

$\textcircled{\scriptsize{1}}$ 移码中零的表示唯一， $[+0]_{\#}=2^{n}+0=[-0]_{\#}=2^{n}-0=100...0$ （n个 $"0")$  

$\circledcirc$ 一个真值的移码和补码仅差一个符号位， $[x]_{\#}$ 的符号位取反即得 $[x]_{\theta}$ （“1”表示正，“ $0$  

表示负，这与其他机器数的符号位取值正好相反），反之亦然。  

$\circledast$ 移码全0时，对应真值的最小值 $-2^{n}$ ：移码全1时，对应真值的最大值 $2^{n}{-}1$  

$^{(4)}$ 移码保持了数据原有的大小顺序，移码大真值就大，移码小真值就小。  

原码、补码、反码和移码这4种编码表示的总结如下：  

>#### pro：补码大小的判断（2015）  

$\textcircled{\scriptsize{1}}$ 原码、补码、反码的符号位相同，正数的机器码相同。  

$\circledcirc$ 原码、反码的表示在数轴上对称，二者都存在 $_{+0}$ 和-0两个0。  

$\textcircled{3}$ 补码、移码的表示在数轴上不对称，零的表示唯一，它们比原码、反码多表示一个数。  

$\textcircled{4}$  整数的补码、移码的符号位相反，数值位相同。  

$\circledast$ 负数的补码、反码末位相差1。  

$^\mathrm{\textregistered}$ 原码很容易判断大小。而负数的补码、反码很难直接判断大小，可采用如下规则快速判  

断：对于负数，数值位部分越小，其绝对值越大，即负得越多。  

# 2.1.3整数的表示  

# 1.无符号整数的表示  

>#### pro：机器码与补码、无符号数之间的转换（2021）  

当一个编码的全部二进制位均为数值位而没有符号位时，该编码表示就是无符号整数，简称无符号数。此时，默认数的符号为正。因为无符号整数省略了一位符号位，所以在字长相同的情况下，它能表示的最大数比有符号整数能表示的大。一般在全部是正数运算且不出现负值结果的场合下，使用无符号整数表示。例如，可用无符号整数进行地址运算，或用它来表示指针。  

例如，对于8位无符号整数，最小数为00000000（值为0），最大数为11111111（值为 $2^{8}\!-1\!=$ 255），即表示范围为 $_{0\sim255}$ ：而对于8位有符号整数，最小数为 $1000\ 0000$ （值为 $-2^{7}\!=-128)$ ，最大数为01111111（值为 $2^{7}\!-1=127)$ ），即表示范围为- $\cdot128\!\sim\!127$  
# 2.有符号整数的表示  

将符号数值化，并将符号位放在有效数字的前面，就组成了有符号整数。虽然前面介绍的原码、补码、反码和移码都可以用来表示有符号整数，但补码表示有其明显的优势：  

$\textcircled{\scriptsize{1}}$ 与原码和反码相比，0的补码表示唯一。  

$\textcircled{2}$ 与原码和移码相比，补码运算规则比较简单，且符号位可以和数值位一起参加运算。  

$\textcircled{3}$ 与原码和反码相比，补码比原码和反码多表示一个最小负数。  

计算机中的有符号整数都用补码表示，故 $n$ 位有符号整数的表示范围是 $-2^{n-1}{\sim}2^{n-1}$ -1。  

# 2.1.4C语言中的整数类型及类型转换  

统考大纲要求考生具有对高级程序设计语言（如C语言）中相关问题进行分析的能力，而C语言变量之间的类型转换是统考中经常出现的题目，需要读者深入掌握这一内容。  

# 1.C语言中的整型数据类型  

>#### pro：int型数据的表示范围（2017、2019）  

C语言中的整型数据就是定点整数，根据位数的不同，可分为字符型（char，8位）、短整型（short或shortint，16位）、整型（int，32位）、长整型（long或longint，在32位机器中为32位，在64位机器中为64位）。char是整型数据中比较特殊的一种，其他如short/int/long等不指定signed/unsigned时都默认是有符号整数，但char默认是无符号整数。无符号整数（unsignedshort/int/long）的全部二进制位均为数值位，没有符号位，相当于数的绝对值。  

signed/unsigned整型数据都是按补码形式存储的，只是signed型的最高位代表符号位，而在unsigned型中表示数值位，因此这两者所表示的数据范围也有所不同。  

# 2.有符号数和无符号数的转换  

>#### pro：有符号数与无符号数的相互转换（2011、2016、2019）  

C语言允许在不同的数据类型之间做类型转换。强制类型转换格式为“TYPE $\boldsymbol{\mathrm{b}}\!=\!(\mathrm{TPE})$ a”，强制类型转换后，返回一个具有TYPE类型的数值，这种操作并不会改变操作数本身。  

先看由short型转换到unsignedshort型的情况。考虑如下代码片段：  

int main(){ short  $\mathrm{x}{=}{-}\,4321$  unsigned short  $\mathbb{Y}^{=}$  (unsigned short)x; printf(' $\scriptstyle{\mathrm{'}}_{\mathrm{X}}=\frac{9}{8}\mathrm{d}$ ， $\tt y=\tt S$ u\n"，x，y);  

有符号数 $_\mathrm{x}$ 是一个负数，而无符号数y的表示范围显然不包括x的值。  

在采用补码的机器上，上述程序会输出如下结果： $\texttt{x}=\,-4321$ ， $\texttt{y}=\ 61215$  

输出的结果中，得到的y值似乎与原来的x没有一点关系。不过将这两个数转换为二进制表示时，我们就会发现其中的规律，如表2.1所示。  

表2.1y与x的对比
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ea75c374ba8836e0e20e1d2fbf17389368b80728623490a6848a5ac33303d2d0.jpg)  
观察可知，将short型强制转换为unsignedshort型只改变数值，而两个变量对应的每位都是 一样的。通过本例可知，强制类型转换的结果是保持位值不变，仅改变了解释这些位的方式。  

再看由unsignedshort型转换到short型的情况。考虑如下代码片段：  

int main(）{ unsigned short  $\scriptstyle{\mathrm{x}=65535}$  short  $\mathtt{y}^{=}$  (short)x; printf $("x=\S u$ ， $\mathtt{y}{=}\mathtt{\frac{3}{6}}$ d\n"，x，y）；  

同样在采用补码的机器上，上述程序会输出如下结果：X=65535， $\texttt{y}=\texttt{-1}$  

把这两个数转换为二进制表示，同样可以证实之前的结论。因此，有符号数转换为等长的无符号数时，符号位解释为数值的一部分，负数转换为无符号数时数值将发生变化。同理，无符号数转换为有符号数时最高位解释为符号位，也可能发生数值的变化。  

# 注意  

若同时有无符号数和有符号数参与运算，则C语言标准规定按无符号数进行运算。  

# 3.不同字长整数之间的转换  

>#### pro：无符号数的零扩展（2012）  

另一种常见的运算是在不同字长的整数之间进行类型转换。  

先看大字长变量向小字长变量转换的情况。考虑如下代码片段：  

int main(）{ int  $_\mathrm{x=165537}$  ，  $\mathrm{u}{=}{-}34991$  //int型占用4B short  $\mathtt{y}^{=}$  (short)x,  $\scriptstyle{\mathbb{T}}=$  (short)u; //short型占用2B printf $("x=\S\,\mathrm{d}$ y=8d\n"，x，y）；printf $\scriptstyle{\mathcal{C}}^{\bullet}\cup=\mathrm{{s}}\,\mathrm{{d}}$  $\uptau=$ d\n”，u，v）;  

运行结果如下：  

$\texttt{x}=\texttt{165537}$ ， $\texttt{Y}=\,-31071$  $\mathrm{~u~}=\ -34991$ ， $\texttt{v}=\,30545$  

其中x,y，u,v的十六进制表示分别为0x000286al，0x86a1，0xfmf7751，0x7751，观察上述数字很容易得出结论，当大字长变量向小字长变量强制类型转换时，系统把多余的高位部分直接截断，低位部分直接赋值，因此也是一种保持位值的处理方法。  

再看小字长变量向大字长变量转换的情况。考虑如下代码片段：  

int main(){ short  $\mathrm{x}{=}{-}\,4321$  int  $\mathtt{y}^{=\mathtt{x}}$  unsigned short  $\mathrm{u}{=}$  (unsigned short)x; unsigned int  $\scriptstyle{\mathrm{even}}$  printf  $("x=\S\,\mathrm{d}$   $\mathtt{y}{=}\mathtt{\xi}$  d\n"，x，y）; printf  $\scriptstyle{"{\mathfrak{u}}={\mathfrak{s}}{\mathfrak{u}}}$   $\mathrm{v}{=}$  u\n",u，v）;  

运行结果如下：  

$\textsl{x}=\textsl{-4321}$ ， $\texttt{Y}=\texttt{--}4321$  $\mathrm{~u~}=~61215$ ， $\textsuperscript{v}=~61215$  
>#### pro：无符号数的零扩展（2012），补码的符号扩展（2021）  

x，y，u,v的十六进制表示分别为0xef1f0xffffeflf0xeflf0x0000ef1f。由本例可知，小字长到大字长的转换时，不仅要使相应的位值相等，还要对高位部分进行扩展。若原数字是无符号整数，则进行零扩展，扩展后的高位部分用0填充。否则进行符号扩展，扩展后的高位部分用原数字符号位填充。其实两种方式扩展的高位部分都可理解为原数字的符号位。这与之前的三个例子都不一样，从位值与数值的角度看，前三个例子的转换规则都是保证相应的位值相等，而小字长向大字长的转换，在位值相等的条件下还要补充高位的符号位，可以理解为数值的相等。注意，char型为8位无符号整数，其在转换为int型时高位补0即可。  


# 2.2运算方法和运算电路  

# 2.2.1基本运算部件  

在计算机中，运算器由算术逻辑单元（ArithmeticLogicUnit，ALU）、移位器、状态寄存器（PSW）和通用寄存器组等组成。运算器的基本功能包括加、减、乘、除四则运算，与、或、非、异或等逻辑运算，以及移位、求补等操作。ALU的核心部件是加法器。  
# 1.带标志加法器  

无符号数加法器只能用于两个无符号数相加，不能进行有符号整数的加/减运算。为了能进行有符号整数的加/减运算，还需要在无符号数加法器的基础上增加相应的逻辑门电路，使得加法器不仅能计算和/差，还要能生成相应的标志信息。图23是带标志加法器的实现电路。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b08b1b2e0864197bdd1d72ef2052e0df883af964dc46d02ed1cabeaf47084dfc.jpg)  
图2.3用全加器实现 $n$ 位带标志加法器的电路  

在图2.3中，溢出标志的逻辑表达式为 ${\mathrm{OF}}=C_{n}\oplus C_{n-1}$ ：符号标志就是和的符号，即 $\mathrm{SF}=F_{n-1}$ 零标志 $\mathrm{ZF}=1$ 当且仅当 $F\!=\!0$ ：进位/借位标志 $\mathrm{CF}=C_{\mathrm{out}}\oplus C_{\mathrm{in}^{\mathrm{c}}}$  

# 2.算术逻辑单元（ALU）  

ALU是一种功能较强的组合逻辑电路，它能进行多种算术运算和逻辑运算。由于加、减、乘、除运算最终都能归结为加法运算，因此ALU的核心是带标志加法器，同时也能执行“与”“或”“非”等逻辑运算。ALU的基本结构如图2.4所示，其中 $A$ 和 $B$ 是两个 $n$ 位操作数输入端， $C_{\mathrm{in}}$ 是进位输入端，ALUop是操作控制端（发出控制信号），用来决定ALU所执行的处理功能。例如，ALUop选择Add运算，ALU就执行加法运算，输出的结果就是 $A$ 加 $B$ 之和。ALUop的位数决定了操作的种类。例如，当位数为3时，ALU最多只有8种操作。  

图2.5给出了能够完成3种运算“与”“或”和“加法”的一位ALU结构图。其中，一位加法用一个全加器实现，在ALUop的控制下，由一个多路选择器（MUX）选择输出3种操作结果之一。这里有3种操作，所以ALUop至少要有两位。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9cdde373a0e9aac54e8a3252d040b0625dc2982eaa7ffb7b834dd4a5f48a2d34.jpg)  
图2.4ALU的基本结构  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/446801d26dabb23d19fea7dea7846e8892b38051dc1408e8f16cf0921912b209.jpg)  
图2.5一位ALU的结构  

同时，ALU也可以实现左移或右移的移位操作。  
# 2.2.2 定点数的移位运算  

当计算机中没有乘/除法运算电路时，可以通过加法和移位相结合的方法来实现乘/除法运算。对于任意二进制整数，左移一位，若不产生溢出，相当于乘以2（与十进制数的左移一位相当于乘以10类似)；右移一位，若不考虑因移出而舍去的末位尾数，相当于除以2。  

根据操作数的类型不同，移位运算可以分为逻辑移位和算术移位。  

1.逻辑移位  

>#### pro：逻辑移位运算（2018）  

逻辑移位将操作数视为无符号整数。逻辑移位的规则：左移时，高位移出，低位补0；右移时，低位移出，高位补0。对于无符号整数的逻辑左移，若高位的1移出，则发生溢出。  

# 2.算术移位  

>#### pro：算术移位运算（2012、2017、2018）  

算术移位需要考虑符号位的问题，即将操作数视为有符号整数。  

计算机中的有符号整数都是用补码表示的，因此对于有符号整数的移位操作应采用补码算术移位方式。算术移位的规则：左移时，高位移出，低位补0，若移出的高位不同于移位后的符号位，即左移前后的符号位不同，则发生溢出；右移时，低位移出，高位补符号位，若低位的1移出，则影响精度。例如，补码1001和0101左移时会发生溢出，右移时会丢失精度。  

# 2.2.3 定点数的加减运算  

# 1.补码的加减法运算  

>#### pro：不同字长补码的加法运算（2009）、补码和无符号数的减法运算（2011、2017）  

补码加减运算规则简单，易于实现。补码加减运算的公式如下（设机器字长为 $n+1)$  $\begin{array}{r l}&{[A+B]_{*}=[A]_{*}+[B]_{*}\ (\bmod2^{n+1})}\\ &{[A-B]_{*}=[A]_{*}+[-B]_{*}\ (\bmod2^{n+1})}\end{array}$  

补码运算的特点如下。  

1）按二进制运算规则运算，逢二进一。2）若做加法，两个数的补码直接相加；若做减法，则将被减数与减数的负数补码相加。3）符号位与数值位一起参与运算，加、减运算结果的符号位也在运算中直接得出。4）最终运算结果的高位丢弃，保留 $_{n+1}$ 位，运算结果亦为补码。  

【例2.3】设字长为8位（含1位符号位）， $A=15$  $B=24$ ，求 $[A+B]*$ 和 $[A-B]*$ 解：  

$A=+15=+0001111$ ， $B=+24=+0011000$ ：得 $[A]_{*}\,{=}\,00001111$ ， $[B]_{*}\,{=}\,00011000$  

求得  $[-B]_{*}=11101000$  。所以  

$[A+B]_{*}=00001111+00011000=00100111$ 符号位为0，对应真值为 $+39$  $[A-B]_{*}=[A]_{*}+[-B]_{*}=00001111+1110\,1000=11110\,1111$ ，符号位为1，对应真值为-9。  

2.溢出判别方法  

>#### pro：补码加减运算后的溢出判断（2010、2011、2014、2018、2021）  

仅当两个符号相同的数相加或两个符号相异的数相减才可能产生溢出，如两个正数相加，而结果的符号位却为1（结果为负）；一个负数减去一个正数，结果的符号位却为0（结果为正）。  
补码定点数加减运算溢出判断的方法有3种。  

（1）采用一位符号位  

由于减法运算在机器中是用加法器实现的，因此无论是加法还是减法，只要参加操作的两个数的符号相同，结果又与原操作数的符号不同，则表示结果溢出。  

设 $A$ 的符号为 $A_{s}$ ， $B$ 的符号为 $B_{s}$ ，运算结果的符号为 $S_{s}$ ，则溢出逻辑表达式为  

$$
V=A_{\mathrm{s}}B_{\mathrm{s}}\overline{{S_{\mathrm{s}}}}+\overline{{A_{\mathrm{s}}B_{\mathrm{s}}}}S_{\mathrm{s}}
$$  

若 $V\!=\!0$ ，表示无溢出；若 $V\!=\!1$ ，表示有溢出。  

（2）采用双符号位  

双符号位法也称模4补码。运算结果的两个符号位 $S_{s1}S_{s2}$ 相同，表示未溢出：运算结果的两个符号位 $S_{s1}S_{s2}$ 不同，表示溢出，此时最高位符号位代表真正的符号。  

符号位 $S_{s1}S_{s2}$ 的各种情况如下  

$\textcircled{\scriptsize{1}}$  $S_{s1}S_{s2}=00$ ：表示结果为正数，无溢出。 $\circledcirc$  $S_{s1}S_{s2}=01$ ：表示结果正溢出。 $\textcircled{3}$  $S_{s1}S_{s2}=10$ ：表示结果负溢出。 $\textcircled{4}$  $S_{s1}S_{s2}=11$ ：表示结果为负数，无溢出。  

溢出逻辑判断表达式为 $V\!=\!S_{s1}\oplus S_{s2}$ ，若 $V\!=\!0$ ，表示无溢出：若 $V\!=\!1$ ，表示有溢出。  

（3）采用一位符号位根据数值位的进位情况判断溢出  

若符号位（最高位）的进位 $C_{n}$ 与最高数位（次高位）的进位 $C_{n-1}$ 相同，说明无溢出，否则说明有溢出。溢出逻辑判断表达式为 $V=C_{n}\oplus C_{n-1}$ ，若 $V=0$ ，表示无溢出； $V=1$ ，表示有溢出。  

# 3.加减运算电路  

>#### pro：无符号数与有符号数加/减运算能用同一个加法器实现的理由（2011）  

已知一个数的补码表示为Y，则这个数的负数的补码为 $\overrightharpoon{Y}+1$ ，因此，只要在原加法器的Y输入端加 $n$ 个反向器以实现各位取反的功能，然后加一个2选1多路选择器，用一个控制端Sub来控制，以选择是将 $Y$ 输入加法器还是将 $\overrightharpoon{Y}$ 输入加法器，并将Sub同时作为低位进位送到加法器（做减法时实现末位加1），如图2.6所示。该电路可实现模 $2^{n}$ 补码加减运算。当Sub为1时，做减法，实现 $X+\overline{{{Y}}}+1=[x]_{*}+[-y]_{*}$ ：当Sub为O时，做加法，实现 $X+Y=[x]_{*}+[y]_{*}$  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ca2c5205d971573b48f8360dfee06c31fc7050362e076fdddeb45c514b1d2093.jpg)  
图2.6加减运算部件  

无符号整数相当于正整数的补码表示，因此图2.6的电路同时也能实现无符号数的加/减运算，对于有符号数 $x$ 和 $y$ ，图中 $X$ 和 $Y$ 分别是 $x$ 和 $y$ 的补码表示：对于无符号数 $x$ 和 $y$ ，图中 $X$ 和 $Y$ 分别是 $x$ 和 $y$ 的二进制表示。不论是补码减法还是无符号数减法，都是用被减数加上减数的负数的补码（即 $\overrightharpoon{Y}+1$ ）来实现的。  
# 注意  

运算器本身无法识别所处理的二进制串是有符号数还是无符号数。例如， $0-1=\,00...0+$  $11\ldots1\!=\!11\ldots1,$ 若解释为有符号数，对应值为-1，结果正确；若解释为无符号数，对应值为 $2^{n}{-}1$  $n$ 位无符号数的最大值），结果出错。此类易混点是统考极易考查的内容。  

可通过标志信息来区分有符号整数运算结果和无符号整数运算结果。  

>#### pro：  

无符号数、有符号数加减运算后CF和OF的值（2011、2018、2023）；SF和OF的逻辑表达式（2022）  

零标志ZF： $Z\mathrm{F}=1$ 表示结果F为O。对于无符号数和有符号数的运算，ZF都有意义。  

溢出标志OF：判断有符号数运算是否溢出，它是符号位进位与最高数位进位的异或结果即 ${\mathrm{OF}}=C_{n}\oplus C_{n-1}$ 。对于无符号数运算，OF没有意义，通俗地说，就是根据OF无法判断无符号数运算是否溢出。例如，无符号数加法 $010+011=101$ ，此时 $\mathrm{OF}=1$ ，但结果未溢出。  

符号标志SF：表示结果的符号，即F的最高位。对于无符号数运算，SF没有意义。  

进/借位标志CF：表示无符号数运算时的进位/借位，判断是否发生溢出。加法时， $\mathrm{CF}{=}1$ 表示结果溢出，因此CF等于进位输出 $C_{\mathrm{out}}$ 。减法时， $\mathrm{CF}=1$ 表示有借位，即不够减，故CF等于进位输出 $C_{\mathrm{out}}$ 取反。综合可得 $\mathrm{CF}\,{=}\,\mathrm{Sub}\oplus C_{\mathrm{out}}.$ 。例如，无符号数加法 $110+011$ 最高位产生进位，无符号数减法  $000-111$  最高位产生借位，结果均发生溢出（即  $\mathrm{CF}\,=\,1)$  。对于有符号数运算，CF 没有意义，也就是说，根据CF无法判断有符号数运算是否溢出。  

（1）无符号数大小的比较  

对于无符号数的运算，零标志ZF、进/借位标志CF才有意义。假设有两个无符号数 $A$ 和 $B$ 下面以执行 $A-B$ 为例来说明ZF、CF标志的几种可能情况。  

若 $A^{=}B$ ，如 $A-B=011-011=000$ ，此时结果为零 $Z\mathrm{F}=1$ ，无借位 $\mathrm{CF}=0$  

若 $A>B$ ，如 $A-B=010-001=001$ ，此时结果非零 $Z\mathrm{F}=0$ ，无借位 $\mathrm{CF}=0$  

若 $A<B$ ，如 $A-B=000-001=(1)000-001=111$ ，此时 $\mathrm{ZF}\!=0$ ，有借位 $\mathrm{CF}=1$  

当ZF=1时，说明 $\scriptstyle\mathcal{A}\equiv\mathcal{B}$ 。当ZF $\underline{{\underline{{\mathbf{\Pi}}}}}\,\underline{{\underline{{\mathbf{\delta\pi}}}}}\,\underline{{\underline{{\mathbf{\delta\pi}}}}}$ 且CF $\l_{\infty}^{\prime}0$ 时，说明 $\scriptstyle\mathcal{A}\geq\mathcal{B}\mathfrak{c}$ 当CF $=1$ 时，说明 $\underline{{A}}\le\underline{{B}}$  

（2）有符号数大小的比较  

对于有符号数的运算，零标志ZF、溢出标志OF、符号标志SF才有意义。假设两个有符号数 $A$ 和 $B$ ，用补码表示，以执行 $[A]_{*}-[B]_{*}$ 为例来说明ZF、OF、SF标志的几种可能情况。  

若 $A\,{=}\,B$ ，如 $![A]_{*}-[B]_{*}=011-011=[A]_{*}+[-B]_{*}=011+101=(1)000,$ ，此时结果为零 $\mathrm{ZF}=1$ 最高位进位与次高位进位的异或结果 $\mathrm{OF}=C_{3}\oplus C_{2}=0$ ，结果的最高位 $\mathrm{SF}=0$  

若  $A\!>B$   $l!\!\!1[A]_{*}-[B]_{*}=010-001=010+111=(1)001$  ，此时  $\mathrm{ZF}=0,~\mathrm{OF}=0,~\mathrm{SF}=0$  ；又  $999[A]*-[B]*=011-101=011+011=110$ ，此时 $\mathrm{{ZF}=0,\,\ O F=1,\,\ S F=1}\,.$  

若 $A<B$ ，如 $[A]_{*}-[B]_{*}\,=000-001=000+111=111$ ，此时 $\mathrm{ZF}=0,~\mathrm{OF}=0,~\mathrm{SF}=1$ 。又 $991[A]_{*}-[B]_{*}\ =101-011=101+101=(1)010$ ，此时 $\mathrm{{ZF}}=0,\;\;\mathrm{{OF}}=1,\;\;\mathrm{{SF}}=0.$  

当ZF $=$ 1时，说明 $\scriptstyle{\mathcal{A}}={\mathcal{B}}$ 。当 $Z\mathrm{F}=0$ 且未发生溢出时，即 $\mathrm{OF}\,{=}\,0$ 时，若 $\mathrm{SF}=0$ ，则表示结果非负，说明 $A>B$ ：当发生溢出时，即 $\mathrm{OF}=1$ 时，若 $\mathrm{SF}=1$ ，则必然是正数减去负数发生溢出导致结果为负，因此，当OF $=$ SF（或OFSF $\lneq0$ ）且ZF $=\!0$ 时，说明 $\scriptstyle\mathcal{A}\geq\mathcal{B}$ 。当 $Z\mathrm{F}=0$ 且未发生溢出时，即 $\mathrm{OF}=0$ 时，若 $\mathrm{SF}=1$ ，则表示结果为负，说明 $A<B$ ；当发生溢出时，即 $\mathrm{OF}=1$ 时，若 $\mathrm{SF}=0$ ，则必然是负数减去正数发生溢出导致结果为正，因此，当OFSF（或OFSF=1）HZF $=\!0$ 时，说明 $\scriptstyle A\leq B$  
# 4.原码的加减法运算（了解）  

在原码加减运算中，将符号位和数值位分开处理，具体的规则如下。  

加法规则：遵循“同号求和，异号求差”的原则，先判断两个操作数的符号位。具体来说，符号位相同，则数值位相加，结果符号位不变，若最高数值位相加产生进位，则发生溢出；符号位不同，则做减法，绝对值大的数减去绝对值小的数，结果符号位与绝对值大的数相同。  

减法规则：先将减数的符号取反，然后将被减数与符号取反后的减数按原码加法进行运算。  

# 注意  

原码的加减运算规则比较复杂，因此计算机采用的大多是补码加减运算。  

# 2.2.4 定点数的乘除运算  

1.定点乘法运算  

（1）乘法运算的基本原理  

>#### pro：如何用加、减、移位指令实现乘法指令（2020）；用软/硬件实现乘法指令的速度对比（2020）  

原码乘法的特点是符号位与数值位是分开求的，原码乘法运算分为两步： $\textcircled{\scriptsize{1}}$ 乘积的符号位由两个乘数的符号位“异或”得到： $\circledcirc$ 乘积的数值位是两个乘数的绝对值之积。两个定点数的数值部分之积可视为两个无符号数的乘积。下面是两个无符号数相乘的手算过程。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e9db16b99b4414f5ea84bd89e7c11ec1810c2c66dcab7d40d3de91283d2f650b.jpg)  

上述过程可写成数学推导过程：  

$$
\begin{array}{r l}&{X{\times}Y{=}X{\times}y_{4}{\times}2^{-4}+X{\times}y_{3}{\times}2^{-3}+X{\times}y_{2}{\times}2^{-2}+X{\times}y_{1}{\times}2^{-1}}\\ &{\qquad=2^{-1}\{2^{-1}[\ 2^{-1}(2^{-1}(0+X{\times}y_{4})+X{\times}y_{3})+X{\times}y_{2}]+X{\times}y_{1}\}}\end{array}
$$  

更普遍地， $n$ 位无符号数乘法 $X{\times}Y$ 可递归地定义如下。  

$$
\begin{array}{l}{{P_{1}=2^{-1}(P_{0}+X\times y_{n})}}\\ {{P_{2}=2^{-1}(P_{1}+X\times y_{n-1})}}\\ {{{}}}\\ {{P_{n}=2^{-1}(P_{n-1}+X\times y_{1})}}\end{array}
$$  

其递推公式为  

$$
P_{i+1}=2^{-1}(P_{i}+X\times y_{n-i}\ )\quad(\,i=0,\,1,\,2,\cdots,\,n-1\,)
$$  

最终乘积为  
$$
P_{n}{=}X{\times}Y
$$  

由上述分析可知，乘法运算可用加法和移位运算来实现（乘以 $2^{-1}$ 相当于做一次右移），两个 $n$ 位无符号数相乘共需进行 $n$ 次加法和 $n$ 次移位运算。原码乘法运算的过程可归纳如下：  

$\textcircled{\scriptsize{1}}$ 被乘数和乘数均取绝对值参加运算，视为无符号数，符号位为 $x_{s}\oplus y_{s}$  

$\circledcirc$ 部分积 $P_{i}$ 是乘法运算的中间结果，初值 $P_{0}\!=\!0$ 。从乘数的最低位 $y_{n}$ 开始，将前面所得的部分积 $P_{i}$ 加上 $X{\times}y_{n-i}$ ，然后右移一位，此步骤重复 $n$ 次。  

# 注意  

由于参与运算的是两个数的数值位，因此运算过程中的右移操作均为逻辑右移，  

（2）乘法运算电路  

>#### pro：乘法电路中控制逻辑的作用（2020）  

图2.7是32位无符号数乘法运算的逻辑结构图。部分积和被乘数 $X$ 做无符号数加法时，可能产生进位，因此设置一个专门的进位位 $C$ 。乘积寄存器 $P$ 初始置0。计数器 $C_{n}$ 初值为32，每循环一次减1。ALU是乘法器的核心部件，对乘积寄存器 $P$ 和被乘数寄存器 $X$ 的内容做“无符号加法”运算，结果送回寄存器 $P$ ，进位存放在 $C$ 中。每次循环都对进位位 $C_{\backprime}$ 寄存器 $P$ 和寄存器Y实现同步“逻辑右移”，此时，进位位 $C$ 移人寄存器 $P$ 的最高位，寄存器 $Y$ 的最低位移出。每次从寄存器Y移出的最低位都被送到控制逻辑，以决定被乘数是否“加”到部分积上。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8b2f2efb8fb8e06dba5d1e1515aadb7d8ddaed5027b92202ab8b99fb2db85ef1.jpg)  
图2.732位无符号数乘法运算的逻辑结构图  

>#### pro：无符号数和有符号数乘法指令的溢出判断（2019、2020、2021）  

在字长为32位的计算机中，对于两个int型变量 $x$ 和 $y$ 的乘积，若乘积高32位的每一位都相同，且都等于乘积低32位的符号，则表示不溢出，否则表示溢出。当 $x$ 和 $y$ unsigned in t型变量时，若乘积的高32位全为0，则表示不溢出，否则表示溢出。  

# 2.除法运算  

（1）除法运算的基本原理  

原码的除法运算与乘法运算很相似，都是一种移位和加减运算迭代的过程，但比乘法运算更复杂。 $n$ 位定点数的除法运算，需统一为：一个 $2n$ 位的数除以一个 $n$ 位的数，得到一个 $n$ 位的商，因此需要对被除数进行扩展。对于定点正小数（即原码小数），只需在被除数低位添 $n$ 个0即可。对于定点正整数（即无符号数），只需在被除数高位添 $n$ 个0即可。做整数除法时，若除数为0，则发生“除数为0”异常，此时需调出操作系统相应的异常处理程序进行处理。  

下面以两个无符号数为例说明手算除法步骤。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b22578c8487627eb2d6a4c43646e4c36db3f32c45ffb58d5a241672596cd920b.jpg)  

上述除法运算的过程可归纳如下：  

$\textcircled{\scriptsize{1}}$ 被除数与除数相减，够减则上商为1，不够减则上商为0  

$\circledcirc$ 每次得到的差为中间余数，将除数右移后与上次的中间余数比较。用中间余数减除数，  

够减则上商为1，不够减则上商为0。如此重复，直到商的位数满足要求为止。  

若是 $2n$ 位除以 $n$ 位的无符号数，商的位数为 $n+1$ 位，当第一次试商为1时，则表示结果溢出（即无法用 $n$ 位表示商），如 $1111\ 1111/1111=1\ 0001$ 。若是两个 $n$ 位的无符号数相除，则第一位商为0，且结果肯定不会溢出，如两个4位数相除的最大商为 $0000\;1111/0001=1111.$ 对于浮点数尾数的原码小数相除，第一次试商为1，则说明尾数部分有溢出，可通过右规消除。  

计算机内部的除法运算与手算除法一样，通过被除数（中间余数）减除数来得到每一位商，够减上商1，不够减上商0。原码除法运算也要将符号位和数值位分开处理，商的符号位是两个数的符号位的“异或”结果，商的数值位是两个数的绝对值之商。  

（2）除法运算电路  

图2.8是一个32位除法逻辑结构图。寄存器 $Y$ 存放除数：寄存器 $R$ 初始时存放扩展被除数的高32位，运算过程中存放中间余数的高位部分，结束时存放的是余数；寄存器 $\mathcal{Q}$ 初始时存放扩展被除数的低32位，运算过程中部分存放中间余数的低位部分、部分存放商，结束时存放的是32位商。ALU是除法器的核心部件，对寄存器 $R$ 和Y的内容做加/减运算，运算结果被送回寄存器 $R$ 。计数器 $C_{n}$ 初值为32，每循环一次减1。每次循环，寄存器 $R$ 和 $\mathcal{Q}$ 实现同步左移，左移时， $\mathcal{Q}$ 的最高位移入R的最低位， $\mathcal{Q}$ 中空出的最低位被上商。从低位开始，遂次把商的各个数位左移到 $\mathcal{Q}$ 中。每次由控制逻辑根据ALU运算结果的符号来决定上商是0还是1。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/99e080eafaeaa56c6e3b0cb75bcae35c36ab081b32783fa2a18c159d18a06bda.jpg)  
图2.832位除法运算的逻辑结构图  

若是两个32位int型整数相除，则除了 $-2^{31}/{-1}$ 会溢出，其余情况都不会溢出。  


# 浮点数的表示与运算  

# 2.3.1浮点数的表示  

浮点数表示法是指以适当的形式将比例因子表示在数据中，让小数点的位置根据需要而浮动。这样，在位数有限的情况下，既扩大了数的表示范围，又保持了数的有效精度。例如，用定点数表示电子的质量 $(9{\times}10^{-28}\mathrm{g})$ ）或太阳的质量（ $(2\!\times\!10^{33}\mathrm{g})$ ）是非常不方便的。  

# 1.浮点数的表示格式  

通常，浮点数表示为  

$$
N{=}(-1)^{S}{\times}M{\times}R^{E}
$$  

式中， $S$ 取值0或1，用来决定浮点数的符号； $M$ 是一个二进制定点小数，称为尾数，一般用定点原码小数表示： $E$ 是一个二进制定点整数，称为阶码或指数，用移码表示。 $R$ 是基数（隐含），可以药定为2、4、16等。可见浮点数由符号、尾数和阶码三部分组成。  

图2.9是一个32位短浮点数格式的例子。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a1b7a71d10d028b99f2e5658ea6e33dcdc0d30ea436288f4013315ca9d3ac5ff.jpg)  
图2.9浮点数格式的例子  

其中，第0位为符号 $S$ ：第 $1\!\sim\!7$ 位为移码表示的阶码 $E$ （偏置值为64）；第 $8\!\sim\!31$ 位为24位二进制原码小数表示的尾数 $M$ ：基数 $R$ 为2。阶码的值反映浮点数的小数点的实际位置：阶码的位数反映浮点数的表示范围：尾数的位数反映浮点数的精度。  
# 2.浮点数的表示范围  

原码是关于原点对称的，敌浮点数的范围也是关于原点对称的，如图2.10所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b69c0bc872d03974bb8a0faff59a9536bc3766b1475dc6f2288fb16f9676567b.jpg)  
图2.10浮点数的表示范围  

运算结果大于最大正数时称为正上溢，小于绝对值最大负数时称为负上溢，正上溢和负上溢统称上溢。数据一旦产生上溢，计算机必须中断运算操作，进行溢出处理。当运算结果在0至最小正数之间时称为正下溢，在0至绝对值最小负数之间时称为负下溢，正下溢和负下溢统称下溢。数据下溢时，浮点数值趋于零，计算机将其当作机器零处理。  

# 3.浮点数的规格化  

为了在浮点数运算过程中尽可能多地保留有效数字的位数，使有效数字尽量占满尾数数位必须在运算过程中对浮点数进行规格化操作。所谓规格化操作，是指通过调整一个非规格化浮点数的尾数和阶码的大小，使非零浮点数在尾数的最高数位上保证是一个有效值。  

左规：当运算结果的尾数的最高数位不是有效位，即出现 $^{\pm0.0...0\times...\times}$ 的形式时，需要进行左规。左规时，尾数每左移一位、阶码减1（基数为2时）。左规可能要进行多次。  

右规：当运算结果的尾数的有效位进到小数点前面时，需要进行右规，右规只需进行一次。将尾数右移一位、阶码加1（基数为2时）。右规时，阶码增加可能导致溢出。  

基数为2的原码规格化尾数 $M$ 应满足 $1/2\!\leqslant\!|M|<1$ ，形式如下： $\textcircled{\scriptsize{1}}$ 正数为 $0.1\times...\times$ 的形式，最大值为0.11...1，最小值为0.100...0，表示范围为 $1/2\!\leqslant\!M\!\leqslant\!(1-2^{-n})$ ： $\textcircled{2}$ 负数为 $1.1\times...\times$ 的形式，最大值为1.10...0，最小值为1.11..1，表示范围为一 $(1-2^{-n}){\leqslant}M{\leqslant}-1/2$  

基数不同，浮点数的规格化形式也不同。当浮点数尾数的基数为2时，原码规格化数的尾数最高位一定是1。当基数为4时，原码规格化数的尾数最高两位不全为0。  

# 4.IEEE754标准  

>#### pro：IEEE754单精度数大小的比较（2014）  

按照IEEE754标准，常用的浮点数的格式如图2.11所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3b05317cc38d69e199cbfe63befd2efce159619079739354914b91a50fa5ab65.jpg)  
图2.11IEEE754标准浮点数的格式  

IEEE754标准规定常用的浮点数格式有32位单精度浮点数（短浮点数、float型）和64位双精度浮点数（长浮点数、double型），其基数隐含为2，见表2.2。  
表2.2IEEE754浮点数的格式
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0ca31a6a712a028a5cadc8997f2d0ee5e30453ac3a0d7a755db034c662d63b9a.jpg)  

单精度格式中包含1位符号 $s,\ 8$ 位阶码 $e$ 和23位尾数 $f_{1}$ ：双精度格式包含1位符号 $s$ 、11位阶码 $e$ 和52位尾数 $f_{\circ}$ 基数隐含为2；尾数用原码表示。对于规格化的二进制浮点数，尾数的最高位总是1，为了能使尾数多表示一位有效位，将这个1隐藏，称为隐藏位，因此23位尾数实际表示了24位有效数字。IEEE754规定隐藏位1的位置在小数点之前，例如， $(12)_{10}\!=\!(1100)_{2}$ 将它规格化后结果为 $1.1\!\times\!2^{3}$ ，其中整数部分的“1”将不存储在23位尾数内。  

# 注意  

单精度与双精度浮点数都采用隐藏尾数最高位的方法，因而使浮点数的精度更高。  

在IEEE754标准中，指数用移码表示，但偏置值并不是通常 $n$ 位移码所用的 $2^{n-1}$ ，而是 $2^{n-1}{-1}$ ，因此，单精度和双精度浮点数的偏置值分别为127和1023。在存储浮点数阶码之前，偏置值要先加到阶码真值上。上例中，阶码值为3，因此在单精度浮点数中，移码表示的阶码为 $127+3=130(82\mathrm{H})$ 在双精度浮点数中，阶码为 $1023+3=1026$ (402H)。  

IEEE754标准中，规格化单精度浮点数的真值为  

$$
(-1)^{s}{\times}1.f{\times}2^{e-127}
$$  

规格化双精度浮点数的真值为  

$$
(-1)^{s}{\times}1.f{\times}2^{e{-}1023}
$$  

式中，规格化单精度浮点数的阶码 $e$ 的取值范围为 $1\!\sim\!254$ （8位）：规格化双精度浮点数的阶码 $e$ 的取值范围为 $1\!\sim\!2046$ （11位）。1EEE754规格化浮点数的表示范围见表2.3。  

>#### pro：IEEE754单精度数的表示范围和有效位（2017、2018）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0e09dbec5860d7cec7c801ef49119346c4db36645552b736a3f51caead1e3a23.jpg)  

对于EEE754格式的浮点数，阶码全为0或全为1时，有其特别的解释，如表2.4所示。>#### pro：IEEE754标准中阶码全为0或全为1时的特殊意义（2017、2023）  

表2.4阶码全为0或全为1时IEEE754浮点数的解释
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5cab272967bd8b58b3d1903235f5ed69c303bb77df5afa2deea36e8c30238b4d.jpg)  
(续表) 
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a466833be1246442271c1562278ccba92a69b86a821388a52a08a2ecffff59b4.jpg)  

1）全0阶码全0尾数： $+0/-0$ 。零的符号取决于符号 $s$ ，一般情况下 $+0$ 和-0是等效的。  

2）全1阶码全0尾数： $+\infty/-\infty$ 。 $+\infty$ 在数值上大于所有有限数， $-\infty$ 则小于所有有限数。引入无穷大数的目的是，在计算过程出现异常的情况下使得程序能继续进行下去。  

3）全1阶码非0尾数：NaN（NotaNumber）。表示一个没有定义的数，称为非数。  

4）全0阶码非0尾数：非规格化数。非规格化数的特点是阶码为全0，尾数高位有一个或几个连续的0，但不全为0。因此，非规格化数的隐藏位为0，且单精度和双精度浮点数的指数分别为-126或-1022。非规格化数可以用于处理阶码下溢。  

>#### pro：实数与1EEE754单精度数的相互转换（2011、2013、2020、2022、2023）  

【例2.5】将十进制数-8.25转换为IEEE754单精度浮点数格式表示。  

解：  

IEEE754规定：单精度浮点数的偏置值是127；尾数最高位的“1”是被隐藏的。  

先将-8.25转换成二进制数，即 $-1000.01\!=\!-1.000\:01\!\times\!2^{3}$ ，再计算阶码 $E$  $E-127=3$ ，因此 $E\!=$ 130，转换成二进制数为10000010。  

IEEE754单精度浮点数格式：符号（1位） $^+$ 阶码（8位） $^+$ 尾数（23位)。因此，单精度格式表示为  

即  

【例2.6】求IEEE754单精度浮点数 $\mathrm{C640\,\,0000H}$ 的值是多少。  

# 解：  

先将 $\mathrm{C640\,0000H}$ 按二进制展开为  

11000110010000000000000000000000  

其对应IEEE754单精度浮点数的格式如下：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d7a584d8be78918f4c203a6b65fcbebbfc1fbd6fb5150e3de3722237aab3bc05.jpg)  

因此，符号 $=1$ 表示负数；阶码值为 $1000\ 1100-0111\ 1111=0000\ 1101=13$ ：尾数值为1.5（注意其有隐藏位，要加1)。因此，浮点数的值为一 $\cdot1.5\!\times\!2^{13}$  

# 5.定点、浮点表示的区别  

（1）数值的表示范围若定点数和浮点数的字长相同，则浮点表示法所能表示的数值范围远大于定点表示法  

(2) 精度对于字长相同的定点数和浮点数来说，浮点数虽然扩大了数的表示范围，但精度降低了。  

（3）数的运算浮点数包括阶码和尾数两部分，运算时不仅要做尾数的运算，还要做阶码的运算，而且运算结果要求规格化，所以浮点运算比定点运算复杂。  
（4）溢出问题  

在定点运算中，当运算结果超出数的表示范围时，发生溢出；在浮点运算中，运算结果超出尾数表示范围却不一定溢出，只有规格化后阶码超出所能表示的范围时，才发生溢出。  

# 2.3.2 浮点数的加减运算  

浮点数运算的特点是阶码运算和尾数运算分开进行，浮点数加减运算分为以下几步。>#### pro：float型能否通过左移实现乘以2运算（2017）；浮点数的加减运算（2009）  

# 1.对阶  

对阶的目的是使两个操作数的小数点位置对齐，即使得两个数的阶码相等。为此，先求阶码差，然后以小阶码向大阶码看齐的原则，将阶码小的尾数右移一位（基数为2），阶码加1，直到两个数的阶码相等为止。尾数右移时，若舍弃有效位会产生误差，影响精度。为了保证运算的精度，尾数石移时，低位移出的位不要去掉，应保留并参加尾数部分的运算。  

# 注意  

若采用大阶码向小阶码看齐的原则，则尾数需要左移，最高有效位被移出，导致结果出错。  

2.尾数加减  

将对阶后的尾数按定点原码小数的加（减）运算规则进行运算。因为IEEE754浮点数尾数中有一个隐藏位，因此在进行尾数加减时，必须将隐藏位还原到尾数部分。运算后的尾数不一定是规格化的，因此，浮点数的加减运算需要进一步进行规格化处理。  

# 3.尾数规格化  

IEEE754规格化尾数的形式为 $\pm1.\times...\times_{\circ}$ 尾数相加减后会得到各种可能结果，例如：  

$$
1.\times...\times+1.\times...\times=\pm1\times...\times...\times
$$  

$$
1.\times_{...}\times-1.\times_{...}\times=\pm0.0...01\times_{...}\times
$$  

1）右规：当结果为 $|\pm1\times.\times\ldots\times$ 时，需要进行右规。尾数右移一位，阶码加1。尾数右移时，最高位1被移到小数点前一位作为隐藏位，最后一位移出时，要考虑舍入。2）左规：当结果为 $\pm0.0...01\times...\times$ 时，需要进行左规。尾数每左移一位，阶码减1。可能需要左规多次，直到将第一位1移到小数点左边。  

# 注意  

$\textcircled{\scriptsize{1}}$ 左规一次相当于乘以2，右规一次相当于除以2； $\textcircled{2}$ 需要右规时，只需进行一次。  

4.舍入  

在对阶和尾数右规时，可能会对尾数进行右移，为保证运算精度，一般将移出的部分低位保留下来，参加中间过程的运算，最后再将运算结果进行舍入，还原表示成IEEE754格式。  

IEEE754提供了以下4种可选的舍入模式。  

1）就近舍入：舍人为最近的可表示数。当运算结果是两个可表示数的非中间值时，实际上是“0舍1入”方式（类似于十进制的“四舍五入”法）：当运算结果正好在两个可表示数的中间时，则选择结果为偶数。例如，计算 $1.24{\times}10^{5}+5.04{\times}10^{2}$ （假定科学记数法的精度保留两位小数），若只采用2位保留位，则结果是 $1.2400{\times}10^{5}+0.0050{\times}10^{5}=1.2450{\times}10^{5}$  
这个结果在两个可表示数 $1.24\!\times\!10^{5}$ 和 $1.25\!\times\!10^{5}$ 的中间，采用就近舍入方式到偶数，则结果应该是 $1.24\!\times\!10^{5}$ ：若采用3位保留位，则结果是 $1.24000{\times}10^{5}+\ 0.00504{\times}10^{5}\ =$  $1.24504{\times}10^{5}$ ，这个结果就不在 $1.24\!\times\!10^{5}$ 和 $1.25\!\times\!10^{5}$ 的中间，而更接近于 $1.25\!\times\!10^{5}$ ，采用就近舍入方式，则结果应该是 $1.25\!\times\!10^{5}$ 。显然，后者更为精确。  

2）正向舍入：朝数轴 $+\infty$ 方向舍入，即取右边最近的可表示数。3）负向舍入：朝数轴-方向舍入，即取左边最近的可表示数。  

4）截断法：直接截取所需位数，丢弃后面的所有位，这种舍入处理最简单。对正数或负数来说，都是取更接近原点的那个可表示数，是一种趋向原点的舍入。  

# 5.溢出判断  

>#### pro：浮点数运算时的溢出判断（2015）  

在尾数规格化和尾数舍入时，可能会对结果的阶码执行加/减运算。因此，必须考虑指数溢出问题。若一个正指数超过了最大允许值（127或1023），则发生指数上溢，产生异常。若一个负指数超过了最小充许值（-149或-1074）°，则发生指数下溢，通常把结果按机器零处理。  

1）右规和尾数舍入。数值很大的尾数舍入时，可能因为末位加1而发生尾数溢出，此时需要通过右规来调整尾数和阶码。右规时阶码加1，导致阶码增大，因此需要判断是否发生了指数上溢。当调整前的阶码为11111110时，加1后，会变成11111111而发生指数上溢。2）左规。左规时阶码减1，导致阶码减小，因此需要判断是否发生了指数下溢。其判断规则与指数上溢类似，左规一次，阶码减1，然后判断阶码是否为全0来确定指数是否下溢。由此可见，浮点数的溢出并不是以尾数溢出来判断的，尾数溢出可以通过右规操作得到纠正。  

管结里县不送出主亚丢结里的指数县不发生了上送，因此县中指数上送来判断的  

# 注意  

某些题目中可能会指定尾数或阶码采用补码表示。通常可以采用双符号位，当尾数求和结果溢出（如尾数为 $10.\times\times...\times...$ 或 $01.\times\times...\times$ ）时，需右规一次；当结果出现 $00.0\times\times_{...}\times$ 或 $11.1\times\times_{...}\times$ 时，需要左规，直到尾数变为 $00.1\times\times...\times$ 或 $11.0\times\times_{...}\times_{i}$  

# 2.3.3C语言中的浮点数类型  

>#### pro：不同类型数据转换后数值的变化（2010）  

C语言中的float型和double 型分别对应于IEEE754单精度浮点数和双精度浮点数。longdouble型对应于扩展双精度浮点数，但longdouble型的长度和格式随编译器和处理器类型的不同而有所不同。在C程序中，等式的赋值和判断会导致强制类型转换，以char→int→long→double和float一double最为常见，从前到后范围和精度都从小到大，转换过程没有损失。  

不同类型数的混合运算时，遵循的原则是“类型提升”，即较低类型转换为较高类型。如long型与int型一起运算时，需先将int型转换为long型，然后进行运算，结果为long型。若float型和double型一起运算，虽然两者同为浮点型，但精度不同，则仍需先将float型转换为double型后再进行运算，结果亦为double型。所有这些转换都是系统自动进行的，这种转换称为隐式类型转换。  

>#### pro：int型和float型的精度和范围的分析（2017）  

1）int型转换为float型时，虽然不会发生溢出，但float型尾数连隐藏位共24位，当int型  
数的第 $24\!\sim\!31$ 位非0时，无法精确转换成24位浮点数的尾数，需舍入处理，影响精度。2）int型或float型转换为double型时，因double型的有效位数更多，因此能保留精确值。3）double型转换为float型时，因float型的表示范围更小，因此大数转换时可能会发生溢出。此外，由于尾数有效位数变少，因此高精度数转换时会发生舍入。4）float型或double型转换为int型时，因int型没有小数部分，因此数据会向O方向截断（仅  

保留救数部分）发生全入，另外、因int型的表示范围更小，因业大数桂换时可能会送出在不同数据类型之间转换时，往往隐藏着一些不容易察觉的错误，编程时要非常小心。  

# 2.3.4数据的大小端和对齐存储  

# 1.数据的“大端方式”和“小端方式”存储  

在存储数据时，数据从低位到高位可以按从左到右排列，也可以按从右到左排列。因此，无法用最左或最右来表征数据的最高位或最低位，通常用最低有效字节（LSB）和最高有效字节（MSB）来分别表示数据的低位和高位。例如，在32位计算机中，一个int型变量i的机器数为01234567H，其最高有效字节 $\mathrm{MSB}=01\mathrm{H}$ ，最低有效字节 $\mathrm{LSB}=67\mathrm{H}$  

>#### pro：数据的大小端存储（2016、2018、2019）  

现代计算机基本都采用字节编址，即每个地址编号中存放1字节。不同类型的数据占用的字节数不同，如int型和float型占4字节，double型占8字节等，而程序中对每个数据只给定一个地址。假设变量i的地址为 $08\ \mathrm{~00H}$ ，字节01H、 $^{23\mathrm{H}}$ 、45H、67H应各有一个内存地址，那么4字节在内存中应如何排列呢？根据数据中各字节在连续字节序列中的排列顺序不同，可以采用两种排列方式：大端方式（bigendian）和小端方式（lileendian），如图2.12所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/84b38180f8e3e94007c8d5d059202ea50bd801817d21a778faa66e4c344005dc.jpg)  
图2.12采用大端方式和小端方式存储数据  

>#### pro：根据存放顺序判断大小端方式（2019、2023）  

1）大端方式：先存储高位字节，后存储低位字节。字中的字节顺序和原序列的相同。2）小端方式：先存储低位字节，后存储高位字节。字中的字节顺序和原序列的相反。  

在检查底层机器级代码时，需要分清各类型数据字节序列的顺序，例如，以下是由反汇编器（汇编的逆过程，即将机器代码转换为汇编代码）生成的一行机器级代码的文本表示：  

4004d3:010564940408 addeax,0x8049464  

其中，“4004d3”是十六进制数表示的地址，‘ $\lceil01\;05\;64\;94\;04\;08$ ”是指令的机器代码，“addeax,0x8049464”是指令的汇编形式，该指令的第二个操作数是一个立即数 $0{\mathrm{x}}8049464$ 。执行指令时，从指令代码的后4字节中取出该立即数，立即数存放的字节序列为 $64\mathrm{H}$ 、94H、04H、08H，正好与操作数的字节顺序相反，即采用的是小端方式存储，得到08049464H，去掉开头的0，得到值0x8049464，在阅读以小端方式存储的机器代码时，要注意字节是按相反顺序显示的。  

# 2.数据按“边界对齐”方式存储  

现代计算机都是按字节编址的，假设字长为32位，数据按边界对齐方式存放要求其存储地址是自身大小的整数倍，半字地址一定是2的整数倍，字地址一定是4的整数倍，这样无论所取 的数据是字节、半字还是字，均可一次访存取出。当所存数据不满足上述要求时，可通过填充空白字节使其符合要求。这样做虽然会浪费一些存储空间，但可以提高存取数据的速度。当数据不按边界对齐方式存储时，半字长或字长的数据可能在两个存储字中，此时需要两次访存，并对高低字节的位置进行调整后才能得到所需数据，从而影响了系统的效率。  
例如，“字节1、字节2、字节3、半字1、半字2、半字3、字1”的数据按序存放在存储器中，按边界对齐方式和按边界不对齐方式存储时，格式分别如图2.13和图2.14所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/67830ff4aa95539687716a65b4721775d480669d1061978c1db29d559d02a9d6.jpg)  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d1d6304976238bbf3f89570e9a0865f42e06a2cef809c11fe4381efd07032597.jpg)  
图2.14按边界不对齐方式存储  

>#### pro：结构体的小端、边界对齐存储（2012、2020）  

在C语言的struct类型中，“边界对齐”有两个重要要求： $\textcircled{\scriptsize{1}}$ 每个成员按其类型的大小对齐，char型的对齐值为1，short型的对齐值为2，int型的对齐值为4，单位为字节；  $\circledcirc$  struct的长度 必须是成员中最大对齐值的整数倍（不够就补空字节）。这样就能保证struct数组的每项都满足边界对齐的条件。  

先来看两个例子（32位，x86环境，GCC编译器）：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a106cd6e73c0cca59a16d1068d7eab6ca420beac8d815b1685e0a3f75e177bd6.jpg)  

结果却是：  $\mathrm{sizeof}\mathrm{(A)}=8$  ，  $\mathrm{sizeof}(\mathrm{B})=12$  

之所以出现上面的结果，是因为编译器要使结构体成员在空间上对齐。为此必须满足： $\textcircled{\scriptsize{1}}$ 每个成员存储的“起始地址 $.\%$ 该成员的长度 $=0$ ”，而结构体中的成员都是按定义的先后顺序排放的。 $\textcircled{2}$ 结构体的长度也必须是最大成员长度的整数倍，即结构体也要对齐排放。  

设B从地址 $0x0000$ 开始，第一个成员b的对齐值是1，其存放地址符合 $0\mathrm{x}0000\%1=0$ ：第二个成员a的对齐值是4，只能存放在从0x0004到 $\mathrm{0x0007}$ 这四个字节中，满足 $0\X{000}{4\%{4=0}}$ 且紧邻第一个成员；第三个成员c的对齐值是2，可以存放在从 $\mathrm{0x0008}$ 到 $0{\bf x}0009$ 这两个字节中。此外，结构体长度必须是最大对齐值的整数倍，故 $\mathrm{0x000A}$ 到 $\mathrm{0x000B}$ 也为B所占用，共12字节。  

设A也从地址 $0x0000$ 开始，第一个成员a的对齐值是4，存放在从 $0x0000$ 到 $0\mathbf{x}0003$ 这四个字节中；第二个成员b的对齐值是1，存放在 $0x0004$ 中；第三个成员c的对齐值是2，为满足“起始地址 $\%N\!=\!0$ ”的条件，只能存放在从 $0x0006$ 到 $0x0007$ 这两个字节中，结构体共占用8字节。  

边界对齐方式相对边界不对齐方式是一种空间换时间的思想。精简指令系统计算机RISC通常采用边界对齐方式，因为边界对齐方式取指令时间相同，因此能适应指令流水。  


# 2.4 本章小结  

本章开头提出的问题的参考答案如下：  

1）在计算机中，为什么要采用二进制来表示数据？答案已在本章开头说明。  
2）计算机在字长足够的情况下能够精确地表示每个数吗？若不能，请举例说明  

计算机采用二进制来表示数据，在字长足够时，可以表示任何一个整数。而二进制表示小数时只能够用 $1/(2^{n})$ 的和的任意组合表示，即使字长很长，也不可能精确表示出所有小数，只能无限接近。例如0.1就无法用二进制精确地表示。  

3）字长相同的情况下，浮点数和定点数的表示范围与精度有什么区别？  

字长相同时，浮点数取字长的一部分作为阶码，所以表示范围比定点数要大，而取一部分作为阶码也就代表着尾数部位的有效位数减少，而定点数字长的全部位都用来表示数值本身，精度要比同字长的浮点数更大。  

4）用移码表示浮点数的阶码有什么好处？  

移码的两个好处：  

$\textcircled{\scriptsize{1}}$ 浮点数进行加减运算时，要比较阶码的大小，移码比较大小更方便。  

$\circledcirc$ 检验移码的特殊值（0和max）时比较容易。阶码以移码编码时的特殊值如下。0：表示指数为负无穷大，相当于分数分母无穷大，整个数无穷接近0，在尾数也为0时可用来表示0：尾数不为零表示未规格化的数。max：表示指数正无穷大，若尾数为0，则表示浮点数超出表示范围（正负无穷大）：尾数不为0，则表示浮点数运算错误。  

# 2.5常见问题和易混淆知识点  

1.如何表示一个数值数据？计算机中的数值数据都是二进制数吗？在计算机内部，数值数据的表示方法有以下两大类。  

$\textcircled{\scriptsize{1}}$ 直接用二进制数表示。分为有符号数和无符号数，有符号数又分为定点数表示和浮点数表示。无符号数用来表示无符号整数（如地址等信息）。  

$\circledcirc$ 二进制编码的十进制数，一般采用BCD码表示，用来表示整数。  

所以，计算机中的数值数据虽然都用二进制表示，但不全是二进制，也有用十进制表示的。例如在指令类型中，就分别有二进制加法指令和十进制加法指令。  

# 2.什么称为无符号整数的“溢出”？  

对于无符号定点整数来说，若寄存器位数不够，则计算机运算过程中一般保留低 $n$ 位，舍弃高位。这样，会产生以下两种结果。  

$\textcircled{\scriptsize{1}}$ 保留的低 $n$ 位数不能正确表示运算结果。在这种情况下，意味着运算的结果超出了计算机所能表达的范围，有效数值进到了第 $n+1$ 位，称此时发生了“溢出”现象。  

$\circledcirc$ 保留的低 $n$ 位数能正确表达计算结果，即高位的舍去并不影响其运算结果，  

3.如何判断一个浮点数是否是规格化数？  

为了使浮点数能尽量多地表示有效位数，一般要求运算结果用规格化数形式表示。规格化浮点数的尾数小数点后的第一位一定是个非零数。因此，对于原码编码的尾数来说，只要看尾数的第一位是否为1就行；对于补码表示的尾数，只要看符号位和尾数最高位是否相反。需要注意的是，IEEE754标准的浮点数尾数是用原码编码的。  

4.对于位数相同的定点数和浮点数，可表示的浮点数个数比定点数个数多吗？  

不是，可表示的数据个数取决于编码所采用的位数。编码位数一定，编码出来的数据个数就是一定的。 $n$ 位编码只能表示 $2^{n}$ 个数，所以对于相同位数的定点数和浮点数来说，可表示的数据个数应该一样多（有时可能因为一个值有两个或多个编码对应，编码个数会有少量差异）。  
5.现代计算机中是否要考虑原码加减运算？如何实现？现代计算机中的浮点数采用IEEE754标准，所以在进行两个浮点数的加减运算时，必须考虑原码的加减运算，因为IEEE754标准的浮点数尾数都采用原码表示。  

原码的加减运算可以有以下两种实现方式  

1）转换为补码后，用补码加减法实现，结果再转换为原码。2）直接用原码进行加减运算，符号位和数值位分开处理（见原码加减运算部分）。  
# 第3章存储系统  

# 【考纲内容】  

（一）存储器的分类  

（二）层次化存储器的基本结构  

（三）半导体随机存储器（RAM）SRAM、DRAM、Flash存储器  

（四）主存储器DRAM芯片和内存条、多模块存储器、主存储器和CPU之间的连接  

（五）外部存储器磁盘存储器、固态硬盘（SSD）  

（六）高速缓冲存储器（Cache）Cache的基本原理：Cache和主存之间的映射方式Cache中主存块的替换算法：Cache写策略  

（七）虚拟存储器  

虚拟存储器的基本概念页式虚拟存储器：基本原理、页表、地址转换、TLB（快表）段式虚拟存储器的基本原理：段页式虚拟存储器的基本原理  

# 【复习提示】  

本章是历年命题重点，特别是有关Cache和虚拟存储器的考点容易出综合题。此外，存储器的特点，存储器的扩展（芯片选择、连接方式、地址范围等），交叉存储器，Cache的相关计算与替换算法，虚拟存储器与TLB也容易出选择题。读者应在掌握基本原理的基础上，多结合习题进行反复训练，以加深巩固。另外，读者需掌握存在Cache和TLB的计算机中的地址翻译与Cache映射问题，也建议结合《操作系统考研复习指导》复习。  

在学习本章时，请读者思考以下问题  

1）存储器系统为何要分这些层次？计算机如何管理这些层次？  

2）影响Cache性能的因素有哪些？  

3）虚拟存储系统的页面是设置得大一些好还是设置得小一些好？请读者在学习本章的过程中寻找答案，本章末尾会给出参考答案。  

# 3.1存储器概述  

# 3.1.1存储器的分类  

存储器种类繁多，可从不同角度对存储器进行分类。  
# 1.按在计算机中的作用（层次）分类  

1）主存储器。简称主存，也称内存储器（内存），用来存放计算机运行期间所需的程序和数据，CPU可以直接随机地对其进行访问，也可以和高速缓冲存储器（Cache）及辅助存储器交换数据。其特点是容量较小、存取速度较快、每位的价格较高。2）辅助存储器。简称辅存，也称外存储器或外存，用来存放当前暂时不用的程序和数据，以及一些需要永久性保存的信息。辅存的内容需要调入主存后才能被CPU访问。其特点是容量大、存取速度较慢、单位成本低。3）高速缓冲存储器。简称Cache，位于主存和CPU之间，用来存放当前CPU经常使用的指令和数据，以便CPU能高速地访问它们。Cache的存取速度可与CPU的速度相匹配，但存储容量小、价格高。现代计算机通常将它们制作在CPU中。  

# 2.按存储介质分类  

按存储介质，存储器可分为磁表面存储器（磁盘、磁带）、磁芯存储器、半导体存储器（MOS型存储器、双极型存储器）和光存储器（光盘）。  

# 3.按存取方式分类  

>#### pro：采用随机存取的存储器（2011）  

1）随机存储器（RAM)。存储器的任何一个存储单元都可以随机存取，而且存取时间与存储单元的物理位置无关。其优点是读/写方便、使用灵活，主要用作主存或高速缓冲存储器。RAM又分为静态RAM和动态RAM（第2节会详细介绍）。2）只读存储器（ROM）。存储器的内容只能随机读出而不能写入。信息一旦写入存储器就固定不变，即使断电，内容也不会丢失。因此，通常用它存放固定不变的程序、常数和汉字字库等。它与随机存储器可共同作为主存的一部分，统一构成主存的地址域。由ROM派生出的存储器也包含可反复重写的类型，ROM和RAM的存取方式均为随机存取。广义上的只读存储器已可通过电擦除等方式进行写入，其“只读”的概念没有保留，但仍保留了断电内容保留、随机读取特性，但其写入速度比读取速度慢得多。3）串行访问存储器。对存储单元进行读/写操作时，需按其物理位置的先后顺序寻址，包括顺序存取存储器（如磁带）和直接存取存储器（如磁盘、光盘）。  

顺序存取存储器的内容只能按某种顺序存取，存取时间的长短与信息在存储体上的物理位置有关，其特点是存取速度慢。直接存取存储器既不像RAM那样随机地访问任何一个存储单元，又不像顺序存取存储器那样完全按顺序存取，而是介于两者之间。存取信息时通常先寻我整个存储器中的某个小区域（如磁盘上的磁道），再在小区域内顺序查找。  

# 4.按信息的可保存性分类  

断电后，存储信息即消失的存储器，称为易失性存储器，如RAM。断电后信息仍然保持的存储器，称为非易失性存储器，如ROM、磁表面存储器和光存储器。  

若某个存储单元所存储的信息被读出时，原存储信息被破坏，则称为破坏性读出：若读出时，被读单元原存储信息不被破坏，则称为非破坏性读出。具有破坏性读出性能的存储器，每次读出操作后，必须紧接一个再生的操作，以便恢复被破坏的信息。  

# 3.1.2 存储器的性能指标  

存储器有三个主要性能指标，即存储容量、单位成本和存储速度。这三个指标相互制约，设计存储器系统所追求的目标就是大容量、低成本和高速度。  
1）存储容量 $=$ 存储字数 $\times$ 字长（如 $1\mathrm{M}{\times}8$ 位）。单位换算：1B（Byte，字节） $=8\mathrm{b}$ (bit，位)。存储字数表示存储器的地址空间大小，字长表示一次存取操作的数据量。  

2）单位成本：每位价格 $=$ 总成本/总容量。  

3）存储速度：数据传输速率（每秒传送信息的位数） $=$ 数据的宽度/存取周期  

$\textcircled{\scriptsize{1}}$ 存取时间（ $T_{\mathrm{a}})$ ：存取时间是指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间。 $\circledcirc$ 存取周期（ $T_{\mathrm{m}}$ )：存取周期是指存储器进行一次完整的读/写操作所需的全部时间，即连续两次独立访问存储器操作（读或写操作）之间所需的最小时间间隔。 $\textcircled{3}$ 主存带宽（ $B_{\mathrm{m}}$ )：也称数据传输速率，表示每秒从主存进出信息的最大数量，单位为字/秒、字节/秒（ $\mathbf{B}/\mathrm{s}.$ ）或位/秒（b/s)。  

存取时间不等于存取周期，通常存取周期大于存取时间。这是因为对任何一种存储器，在读/写操作之后，总要有一段恢复内部状态的复原时间。对于破坏性读出的存储器，存取周期往往比存取时间大得多，甚至可达 $T_{\mathrm{m}}\,{=}\,2T_{\mathrm{a}}$ ，因为存储器中的信息读出后需要马上进行再生。  

存取时间与存取周期的关系如图3.1所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/21f64fafd194c1ba1c6165c7728968a6e8ae536402c6539569c4d4e7c1719c0f.jpg)  
图3.1存取时间与存取周期的关系  

# 3.1.3多级层次的存储系统  

为了解决存储系统大容量、高速度和低成本这三个相互制约的矛盾，在计算机系统中，通常采用多级存储器结构，如图3.2所示。在图中由上至下，位价越来越低，速度越来越慢，容量越来越大，CPU访问的频度也越来越低。实际上，存储系统层次结构主要体现在Cache-主存层和主存-辅存层。在存储体系中，Cache、主存能与CPU直接交换信息，辅存则要通过主存与CPU交换信息：主存与CPU、Cache、辅存都能交换信息，如图3.3所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ecbfb7431920fae95ef8cac047bea026b1dcf473fe23120161d91a5948c10f1a.jpg)  
图3.2多级存储器结构  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3695ac60caa0ef8aa0adc0813638b48ef2f1586374984cdd5278a8b6809a560d.jpg)  
图3.3三级存储系统的层次结构及其构成  

存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。当CPU要从存储器中存取数据时，先访问Cache，若不在Cache中，则访问主存，若不在主存中，则访问磁盘，此时，操作数从磁盘读出送到主存，然后从主存送到Cache。从CPU的角度看，Cache-主存层的速度接近于Cache，容量和位价却接近于主存。从主存-辅存层分析，其速度接近于主存，容量和位价却接近于辅存。这就解决了速度、容量、成本这三者之间的矛盾。  
Cache-主存层主要解决CPU和主存速度不匹配的问题，主存和Cache之间的数据调动是由硬件自动完成的，对所有程序员均是透明的。主存一辅存层主要解决存储系统的容量问题，主存和辅存之间的数据调动是由硬件和操作系统共同完成的，对应用程序员是透明的。  

在主存一辅存层的不断发展中，逐渐形成了虚拟存储系统，在这个系统中程序员编程的地址范围与虚拟存储器的地址空间相对应，编程时可用的地址空间远大于主存空间。  

# 注意  

在Cache一主存层和主存一辅存层中，上一层中的内容都只是下一层中的内容的副本，也即Cache（或主存）中的内容只是主存（或辅存）中的内容的一部分。  



# 3.2主存储器  

# 3.2.1SRAM DRAM  

半导体存储器分为随机存储器（RAM）和只读存储器（ROM）。RAM又分为静态随机存储器

（SRAM）和动态随机存储器（DRAM），主存储器主要由DRAM实现，靠近处理器的那一层（Cache）则由SRAM实现，它们都是易失性存储器。ROM是非易失性存储器。  

1.SRAM的工作原理  

通常把存放一个二进制位的物理器件称为存储元，它是存储器的最基本的构件。地址码相同的多个存储元构成一个存储单元。若干存储单元的集合构成存储体。  

静态随机存储器（SRAM）的存储元是用双稳态触发器（六晶体管MOS）来记忆信息的，静态是指即使信息被读出后，它仍保持其原状态而不需要再生（非破坏性读出）。  

SRAM的存取速度快，但集成度低，功耗较大，价格昂贵，一般用于高速缓冲存储器  

2.DRAM的工作原理  

与SRAM的存储原理不同，动态随机存储器（DRAM）是利用存储元电路中栅极电容上的电荷来存储信息的，DRAM的基本存储元通常只使用一个晶体管，所以它比SRAM的密度要高很多。相对于SRAM来说，DRAM具有集成度高、位价低和功耗低等优点，但DRAM的存取速度比SRAM慢，且必须定时刷新和读后再生，一般用于大容量的主存系统。  
>#### pro：需要刷新的存储芯片：SDRAM（2015）  

DRAM电容上的电荷一般只能维持 $1\!\sim\!2\mathrm{ms}$ ，因此即使电源不断电，信息也会自动消失。此外，读操作会使其状态发生改变（破坏性读出），需读后再生，这也是称其为动态存储器的原因。刷新可以采用读出的方法进行，根据读出内容对相应单元进行重写，即读后再生。对同一行进行相邻两次刷新的时间间隔称为刷新周期，通常取 $2\mathrm{ms}$ 。常用的刷新方式有以下3种：  

1）集中刷新：在一个刷新周期内，利用一段固定的时间，依次对存储器的所有行进行逐一再生，在此期间停止对存储器的读/写操作，称为死时间，也称访存死区。优点是读/写操  

作时不受刷新工作的影响：缺点是在集中刷新期间（死区）不能访问存储器。后半部分用于刷新。这种刷新方式增加了系统的存取周期，如存储芯片的存取周期为 $0.5\upmu\mathrm{s}$  $1\upmu\mathrm{s}$ 。优点是没有死区；缺点是加长了系统的存取周期。3）异步刷新：结合了前两种方法，使得在一个刷新周期内每一行仅刷新一次。具体做法是将刷新周期除以行数，得到相邻两行之间刷新的时间间隔1，每隔时间1产生一次刷新请求。这样就使“死时间”的分布更加分散，避免让CPU连续等待过长的时间。  

DRAM的刷新需要注意以下问题： $\textcircled{\scriptsize{1}}$ 刷新对CPU是透明的，即刷新不依赖于外部的访问； $\circledcirc$ DRAM的刷新单位是行，由芯片内部自行生成行地址； $\textcircled{3}$ 刷新操作类似于读操作，但又有所不同。另外，刷新时不需要选片，即整个存储器中的所有芯片同时被刷新。  

# 注意  

虽然DRAM的刷新和再生都是恢复数据，但刷新与再生的过程并不完全相同。刷新是以行为单位，逐行恢复数据的，而再生仅需恢复被读出的那些单元的数据。  

>#### pro：DRAM芯片行缓冲器容量的计算（2022）  

目前更常用的是SDRAM（同步DRAM)芯片，其工作方式与传统DRAM的不同，传统DRAM与CPU采用异步方式交换数据，CPU发出地址和控制信号后，经过一段延迟时间，数据才读出或写入，在读/写完成之前，CPU不能做其他工作。而SDRAM与CPU采用同步方式交换数据，它将CPU发出的地址和控制信号锁存起来，CPU在其读/写完成之前可进行其他操作。SDRAM的每一步操作都在系统时钟的控制下进行，支持突发传输方式?。第一次存取时给出首地址，同一行的所有数据都被送到行缓冲器，因此，以后每个时钟都可以连续地从SDRAM输出一个数据。行缓冲器用来缓存指定行中整行的数据，其大小为“列数 $\cdot\times$ 位平面数”，通常用SRAM实现。  

# 3.DRAM芯片的读/写周期  

DRAM芯片读/写周期的时序图如图3.4所示。为了使芯片能正确接收行、列地址并实现读写操作，各信号的时间关系应符合一定要求。读（写）周期时间 $t_{\mathrm{{RC}}}$  $t_{\mathrm{{wc}}}$ ）表示DRAM芯片进行两次连续读（写）操作时所必须间隔的时间。  

在读周期中，在RAS有效前将行地址送到芯片的地址引I脚，CAS滞后RAS一段时间，在CAS有效前再将列地址送到芯片的地址引脚，RAS、CAS应分别至少保持 $t_{\mathrm{RAS}}$ 和 $t_{\mathrm{CAS}}$ 的时间。在读周期中WE为高电平，并在CAS有效前建立。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ac49c5139324c976bef95c5760eecc986130d9c6997bdc4b888ceda236371d26.jpg)  
图3.4DRAM芯片读/写周期时序图  

在写周期中，行列选通信号的时序关系和读周期相同。在写周期中WE为低电平，同样在CAS有效前建立。为了保证数据可靠地写入，写数据必须在CAS有效前在数据总线上保持稳定。  

# 4.SRAM DRAM  

表3.1详细列出了SRAM和DRAM各自的特点。  

表3.1SRAM DRAM
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/247e4075afae5a6921141e41eb4721eb9e64db737333bbae6ebd4d1ecd2c7aab.jpg)  

# 5.存储器芯片的内部结构  

如图3.5所示，存储器芯片由存储体、1/0读/写电路、地址译码器和控制电路等部分组成。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2516f94b368ccd12877ec553c7401ec98c5b18224a062f7a42b548d1c7b596b4.jpg)  
图3.5存储器芯片结构图  
1）存储体（存储矩阵）。存储体是存储单元的集合，它由行选择线（X）和列选择线（Y）来选择所访问单元，存储体的相同行、列上的多位（位平面数）同时被读出或写入。  

2）地址译码器。用来将地址转换为译码输出线上的高电乎，以便驱动相应的读/写电路。地址译码有单译码法（一维译码）和双译码法（二维译码）两种方式。  

·单译码法。只有一个行译码器，同一行中所有存储单元的字线连在一起，同一行中的各单元构成一个字，被同时读出或写入。缺点是地址译码器的输出线数过多。·双译码法。如图3.5所示，地址译码器分为 $X$ 和Y方向两个译码器，在选中的行和列交叉点上能确定一个存储单元，这是DRAM芯片目前普遍采用的译码结构。  

3）I/O控制电路。用以控制被选中的单元的读出或写入，具有放大信息的作用。  

4）片选控制信号。单个芯片容量太小，往往满足不了计算机对存储器容量的要求，因此需用一定数量的芯片进行存储器的扩展。在访问某个字时，必须“选中”该存储字所在的芯片，而其他芯片不被“选中”，因此需要有片选控制信号。  

5）读/写控制信号。根据CPU给出的读命令或写命令，控制被选中单元进行读或写，  

# 3.2.2只读存储器  

# 1.只读存储器（ROM）的特点  

>#### pro：RAM和ROM的区别（2010）  

ROM和RAM都是支持随机访问的存储器，其中SRAM和DRAM均为易失性半导体存储器。而ROM中一旦有了信息，就不能轻易改变，即使掉电也不会丢失。ROM具有两个显著的优点：

 $\textcircled{\scriptsize{1}}$ 结构简单，所以位密度比可读/写存储器的高。 $\circledcirc$ 具有非易失性，所以可靠性高。  

# 2.ROM的类型  

根据制造工艺的不同，ROM可分为掩模式只读存储器（MROM）、一次可编程只读存储器

（PROM）、可擦除可编程只读存储器（EPROM）、Flash存储器和固态硬盘（SSD）。  

（1）掩模式只读存储器  

MROM的内容由半导体制造厂按用户提出的要求在芯片的生产过程中直接写入，写入以后任何人都无法改变其内容。优点是可靠性高，集成度高，价格便宜；缺点是灵活性差。  

（2）一次可编程只读存储器  

PROM是可以实现一次性编程的只读存储器。允许用户利用专门的设备（编程器）写入自己的程序，一旦写入，内容就无法改变。  

（3）可擦除可编程只读存储器  

EPROM不仅可以由用户利用编程器写入信息，而且可以对其内容进行多次改写。EPROM虽然既可读又可写，但它不能取代RAM，因为EPROM的编程次数有限，且写入时间过长。  

（4）Flash存储器  

>#### pro：Flash存储器的特点（2012）  

Flash存储器是在EPROM的基础上发展起来的，它兼有ROM和RAM的优点，可在不加电的情况下长期保存信息，又能在线进行快速擦除与重写。Flash存储器既有EPROM价格便宜、集成度高的优点，又有EPROM电可擦除重写的特点，且擦除重写的速度快。  

（5）固态硬盘（Solid State Drive，SSD）基于闪存的固态硬盘是用固态电子存储芯片阵列制成的硬盘，由控制单元和存储单元（Flash芯片）组成。保留了Flash存储器长期保存信息、快速擦除与重写的特性。对比传统硬盘也具有读/写速度快、低功耗的特性，缺点是价格较高。  
# 3.2.3主存储器的基本组成  

图3.6是主存储器（MainMemory，MM）的基本框图，其中由一个个存储0或1的记忆单元（也称存储元件）构成的存储矩阵（也称存储体）是存储器的核心部件。存储元件是具有两种稳态的能表示二进制0和1的物理器件。为了存取存储体中的信息，必须对存储单元编号（也称编址）。编址单位是指具有相同地址的那些存储元件构成的一个单位，可以按字节编址，也可以按字编址。现代计算机通常采用字节编址方式，此时存储体内的一个地址中有1字节。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/32d7adac4f2bd43918e63a15cb75067abfdb78b3072fd13466d39b41b1a285a2.jpg)  
图3.6主存储器的基本组成框图  

指令执行过程中需要访问主存时，CPU首先把被访问单元的地址送到MAR中，然后通过地址线将主存地址送到主存中的地址寄存器，以便地址译码器进行译码，选中相应单元，同时CPU将读/写信号通过控制线送到主存的读/写控制电路。若是写操作，则CPU同时将要写的信息送到MIDR中，在读/写控制电路的控制下，经数据线将信号写入选中的单元；若是读操作，则主存读出选中单元的内容送至数据线，然后被送到MDR中。MDR的位数与数据线的位数相同，MAR的位数与地址线的位数相同。图3.6采用64位数据线，所以在按字节编址方式下，每次最多可以存取8个单元的内容。地址线的位数决定了主存地址空间的最大可寻址范围。例如，36位地址的最大寻址范围为 $0{\sim}2^{36}\!-\!1$ ，即地址从0开始编号。  

# 注意  

数据线的位数通常等于存储字长，因此MIDR的位数通常等于存储字长；若数据线的位数不等于存储字长，则MIDR的位数由数据线的位数决定。  

>#### pro：DRAM芯片的地址引脚复用技术（2014）  

DRAM芯片容量较大，地址位数较多，为了减少芯片的地址引脚数，通常采用地址引脚复用技术，行地址和列地址通过相同的引脚分先后两次输入，这样地址引脚数可减少一半。  

>#### pro：DRAM芯片行、列数的优化原则（2018）  

假定有一个 $2^{n}{\times}b$ 位DRAM芯片的存储阵列，其行数为r，列数为 $c$ ，则 $2^{n}\!=r\!\times\!c_{\circ}$ 存储阵列的地址位数为 $n$ ，其中行地址位数为 $\log_{2}r$ ，列地址位数为 $\log_{2}\!c$ ，则 $n\!=\!\log_{2}\!r\!+\!\log_{2}\!c$ 。由于DRAM芯片采用地址引脚复用技术，为减少地址引脚数，应尽量使行、列位数相同，即满足 $|r–c|$ 最小。又由于DRAM按行刷新，为减少刷新开销，应使行数较少，因此还需满足 $r\!\leqslant c$  
# 3.2.4多模块存储器  

多模块存储器是一种空间并行技术，利用多个结构完全相同的存储模块的并行工作来提高存储器的吞吐率。常用的有单体多字存储器和多体低位交叉存储器。  

# 注意  

CPU的速度比存储器快得多，若同时从存储器中取出 $n$ 条指令，就可以充分利用CPU资源，提高运行速度。多体交叉存储器就是基于这种思想提出的。  

# 1.单体多字存储器  

在单体多字系统中，每个存储单元存储 $m$ 个字，总线宽度也为 $m$ 个字，一次并行读出 $m$ 个字。在一个存取周期内，从同一地址取出 $m$ 条指令，然后将指令逐条送至CPU执行，即每隔 $1/m$ 存取周期，CPU向主存取一条指令。这显然提高了单体存储器的工作速度。  

缺点：只有指令和数据在主存中连续存放时，这种方法才能有效提升存取速度。一旦遇到转移指令，或操作数不能连续存放时，这种方法的提升效果就不明显。  

# 2.多体并行存储器  

多体并行存储器由多体模块组成。每个模块都有相同的容量和存取速度，各模块都有独立的读/写控制电路、地址寄存器和数据寄存器。它们既能并行工作，又能交叉工作。  

多体并行存储器分为高位交叉编址和低位交叉编址两种。  

（1）高位交叉编址（顺序方式）  

高位地址表示模块号（或体号），低位地址为模块内地址（或体内地址）。如图3.7所示，存储器共有4个模块 $\mathbf{M}_{0}{\sim}\mathbf{M}_{3}$ ，每个模块有 $n$ 个单元，各模块的地址范围如图中所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/75d2ac2a627c5bcdace95fe592ef3010583976cec7fbd37807fc2eed52d25b78.jpg)  
图3.7高位交叉编址的多体存储器  

在高位交叉方式下，总把低位的体内地址送到由高位体号确定的模块内进行译码。访问一个连续主存块时，总是先在一个模块内访问，等到该模块访问完才转到下一个模块访问，CPU总是按顺序访问存储模块，各模块不能被并行访问，因而不能提高存储器的吞吐率。  

# 注意  

模块内的地址是连续的，存取方式仍是串行存取，因此这种存储器仍是顺序存储器。  
（2）低位交叉编址（交叉方式）  

>#### pro：交叉存储器中数据的存放方式（2017）  

低位地址为模块号，高位地址为模块内地址。如图3.8所示，每个模块按“模 $m$ ”交叉编址，模块号 $=$ 单元地址 $\%\,m$ ，假定有 $m$ 个模块，每个模块有 $k$ 个单元，则单元 $0,m,\cdots,(k-1)m$ 位于 $\mathbf{M}_{0}$ ：单元 $1,m+1,\cdots,(k-1)m+1$ 位于 $\mathbf{M}_{1}$ ；以此类推。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b4f48c1df4011710c3242e64f98016fdf9a431c95108f08cf1745946d0aec796.jpg)  
图3.8低位交叉编址的多体存储器  

低位交义方式下，总是把高位的体内地址送到由低位体号所确定的模块内进行译码。程序连续存放在相邻模块中，因此称采用此编址方式的存储器为交叉存储器。  

交叉存储器可以采用轮流启动或同时启动两种方式。  

轮流启动方式  

若每个模块一次读/写的位数正好等于数据总线位数，模块的存取周期为T，总线周期为 $r,$ 为实现轮流启动方式，存储器交叉模块数应大于或等于  

$$
m=T/r
$$  

>#### pro：交叉存储器存取时间和带宽的计算（2012、2013）  

按每隔 $1/m$ 个存取周期轮流启动各模块，则每隔 $1/m$ 个存取周期就可读出或写入一个数据，存取速度提高 $m$ 倍，图3.9展示了4体交叉轮流启动的时间关系。交叉存储器要求其模块数大于或等于 $m$ ，以保证启动某模块后经过 $_{m\times r}$ 的时间后再次启动该模块时，其上次的存取操作已经完成（以保证流水线不间断）。这样，连续存取 $m$ 个字所需的时间为  

$$
t_{1}=T+(m-1)r
$$  

而顺序方式连续读取 $m$ 个字所需的时间为 $t_{2}\!=\!m T$ 。可见交叉存储器的带宽大大提高。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/357a8d6b3c8858f8e0445d4f33ec790e4dc9c97914e01f04c3acc061319ce47a.jpg)  
图3.9低位交叉轮流启动的存取时间示意图  

>#### pro：交叉存储器中访存冲突的分析（2015）  

在理想情况下， $m$ 体交叉存储器每隔1/m存取周期可读/写一个数据，若相邻的 $m$ 次访问的访存地址出现在同一个模块内，则会发生访存冲突，此时需延迟发生冲突的访问请求。  
同时启动方式  

若所有模块一次并行读/写的总位数正好等于数据总线位数，则可以同时启动所有模块进行读/写。设每个模块一次读/写的位数为16位，模块数 $m=4$ ，数据总线位数为64位，4个模块一共提供64位，正好构成一个存储字，因此应该同时启动4个模块进行并行读/写。  
 

# 3.3 主存储器与CPU的连接  

# 3.3.1连接原理  

1）主存储器通过数据总线、地址总线和控制总线与CPU连接。  

2）数据总线的位数与工作频率的乘积正比于数据传输速率。  

3）地址总线的位数决定了可寻址的最大内存空间。  

4）控制总线（读/写）指出总线周期的类型和本次输入/输出操作完成的时刻。  

主存储器与CPU的连接如图3.10所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1e1d92cf5473f7cdbefec0c268399f79d298a75bd67083e238876b319130a603.jpg)  
图3.10主存储器与CPU的连接  

单个芯片的容量是有限的，因此通过存储器芯片扩展技术，将多个芯片集成在一个内存条上，然后由多个内存条及主板上的ROM芯片组成计算机所需的主存空间，再通过总线与CPU相连。  

# 3.3.2主存容量的扩展  

由于单个存储芯片的容量是有限的，它在字数或字长方面与实际存储器的要求都有差距，因此需要在字和位两方面进行扩充才能满足实际存储器的容量要求。  

1.位扩展法  

位扩展是指对字长进行扩展（增加存储字长）。当CPU的系统数据线数多于存储芯片的数据位数时，必须对存储芯片扩位，使其数据位数与CPU的数据线数相等。  
位扩展的连接方式：各芯片的地址线、片选线和读/写控制线与系统总线相应并联：各芯片的数据线单独引出，分别连接系统数据线。各芯片同时工作。  

如图3.11所示，用8片 $8K\!\times\!1$ 位的RAM芯片组成 $8K\!\times\!8$ 位的存储器。8片RAM芯片的地址线 $\mathrm{A}_{12}{\sim}\mathrm{A}_{0}$ 、CS、WE都分别连在一起，每片的数据线依次作为CPU数据线的一位。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f2b1e66bdcaafe6c0055bf34f9b6020f9ac3160dbd2ded9961f636deabd2b444.jpg)  
图3.11位扩展连接示意图  

2.字扩展法  

字扩展是指对存储字的数量进行扩展，而存储字的位数满足系统要求。系统数据线位数等于芯片数据线位数，系统地址线位数多于芯片地址线位数。  

字扩展的连接方式：各芯片的地址线与系统地址线的低位对应相连；芯片的数据线和读/写控制线与系统总线相应并联；由系统地址线的高位译码得到各芯片的片选信号。各芯片分时工作。  

>#### pro：字扩展（或字位扩展）后存储芯片的地址范围（2010、2016）  

如图3.12所示，用4片 $16K{\times}8$ 位的RAM芯片组成 $64\mathrm{K}\!\times\!8$ 位的存储器。4片RAM芯片的数据线 $\mathrm{D}_{0}{\sim}\mathrm{D}_{7}$ 和WE都分别连在一起。将 $\mathrm{A_{15}A_{14}}$ 用作片选信号， $\mathrm{A}_{15}\mathrm{A}_{14}=00$ 时，译码器输出端0有效，选中最左边1号芯片； $\mathrm{A}_{15}\mathrm{A}_{14}=01$ 时，译码器输出端1有效，选中2号芯片，以此类推（同一时刻只能有一个芯片被选中）。各芯片的地址分配如下：  

第一片，最低地址：0000000000000000：最高地址：0011111111111111（16位）第二片，最低地址：0100000000000000：最高地址：0111111111111111  

第三片，最低地址：1000000000000000；最高地址：1011111111111111第四片，最低地址：1100000000000000：最高地址：1111111111111111  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/44f1fe99a9391d96d9aeb0fb8712474bf298dbedaaa36321308e7bb49a6874d2.jpg)  
图3.12字扩展连接示意图  
3.字位同时扩展法  

字位同时扩展是前两种扩展的组合，这种方式既增加存储字的数量，又增加存储字长。  

字位同时扩展的连接方式：将进行位扩展的芯片作为一组，各组的连接方式与位扩展的相同；由系统地址线高位译码产生若干片选信号，分别接到各组芯片的片选信号。  

如图3.13所示，用8片 $16K\times4$ 位的RAM芯片组成 $64\mathrm{K}\!\times\!8$ 位的存储器。每两片构成一组 $16K\times8$ 位的存储器（位扩展），4组便构成 $64\mathrm{K}\!\times\!8$ 位的存储器（字扩展）。地址线 $\mathrm{A}_{15}\mathrm{A}_{14}$ 经译码器得到4个片选信号， $\mathrm{A}_{15}\mathrm{A}_{14}=00$ 时，输出端0有效，选中第一组的芯片（ $\textcircled{\scriptsize{1}}$ 和 $\circledcirc$ )； $\mathrm{A}_{15}\mathrm{A}_{14}=01$ 时，输出端1有效，选中第二组的芯片（ $\textcircled{3}$ 和 $\textcircled{4}$ )，以此类推。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1bd0ffee871eff245d8c4e998e914cbf1ee53c30a0465b58592027c9ed8d0501.jpg)  
图3.13字位同时扩展及CPU的连接图  

# 3.3.3存储芯片的地址分配和片选  

CPU要实现对存储单元的访问，首先要选择存储芯片，即进行片选；然后在选定的芯片中选择具体的存储单元，以进行数据的读/写，即进行字选。芯片内的字选通常是由CPU送出的 $N$ 条低位地址线完成（ $(N$ 由片内存储容量 $2^{N}$ 决定）。片选信号的产生方法分为线选法和译码片选法。  

# 1.线选法  

线选法用除片内寻址外的高位地址线直接连接至各个存储芯片的片选端，当某位地址线信息为“0”时，就选中与之对应的存储芯片。这些片选地址线每次寻址时只能有一位有效，不允许同时有多位有效，这样才能保证每次只选中一个芯片（或芯片组）。假设4片  $2\mathrm{K}\!\times\!8$  位存储芯片采用线选法构成  $8K\!\times\!8$  位存储器，各芯片 的片选信号见表3.2，其中低位地址线 $\mathrm{A_{10}}\mathrm{\sim}\mathrm{A_{0}}$ 作为字选线，用于片内寻址。  

优点：不需要地址译码器，线路简单。缺点：地址空间不连续，选片的地址线必须分时为低电平（否则不能工作），不能充分利用系统的存储器空间，造成地址资源的浪费。  

表3.2线选法的地址分配
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d3e8ef9e2d826e33c5a04dddaf3613401040af874224f56e1f181b5f42aec2d2.jpg)  

# 2.译码片选法  

译码片选法用除片内寻址外的高位地址线通过地址译码器产生片选信号。如用8片 $8K\!\times\!8$ 位的存储芯片组成 $64\mathrm{K}\!\times\!8$ 位存储器（地线为16位，数据线为8位），需要8个片选信号；若采用线选法，除去片内寻址的13位地址线，仅余高3位，不足以产生8个片选信号。因此，采用译码片选法，即用一片74LS138作为地址译码器，高3位用于片选，则 $\mathrm{A}_{15}\mathrm{A}_{14}\mathrm{A}_{13}=000$ 时选中第一片， $\mathrm{A}_{15}\mathrm{A}_{14}\mathrm{A}_{13}\,{=}\,001$ 时选中第二片，以此类推。  
# 3.3.4 存储器与CPU的连接  

# 1.合理选择存储芯片  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7794c8d428e0c6881d434e25e174952bfec52ac2823fcd17f03373df192eebd5.jpg)  

# 根据要求合理选择存储芯片（2009、2021）  

要组成一个主存系统，选择存储芯片是第一步，主要指存储芯片的类型（RAM或ROM）和数量的选择。通常选用ROM存放系统程序、标准子程序和各类常数，RAM则是为用户编程而设置的。此外，在考虑芯片数量时，要尽量使连线简单、方便。  

# 2.地址线的连接  

>#### pro：  

# 地址范围与存储容量的对应关系（2016、2023）  

存储芯片的容量不同，其地址线数也不同，而CPU的地址线数往往比存储芯片的地址线数要多。通常将CPU地址线的低位与存储芯片的地址线相连，以选择芯片中的某一单元（字选），这部分的译码是由芯片的片内逻辑完成的。而CPU地址线的高位则在扩充存储芯片时使用，用来选择存储芯片（片选），这部分译码由外接译码器逻辑完成。  

例如，设CPU地址线为16位，即 $\mathrm{A}_{15}{\sim}\mathrm{A}_{0}$  $1K{\times}4$ 位的存储芯片仅有10根地址线，此时可将CPU的低位地址 $\mathrm{A}_{9}{\sim}\mathrm{A}_{0}$ 与存储芯片的地址线 $\mathrm{A}_{9}{\sim}\mathrm{A}_{0}$ 相连。  

# 3.数据线的连接  

CPU的数据线数与存储芯片的数据线数不一定相等，在相等时可直接相连：在不等时必须对存储芯片扩位，使其数据位数与CPU的数据线数相等。  

# 4.读/写命令线的连接  

CPU读/写命令线一般可直接与存储芯片的读/写控制端相连，通常高电平为读，低电平为写。有些CPU的读/写命令线是分开的（读为RD，写为WE，均为低电平有效），此时CPU的读命令线应与芯片的充许读控制端相连，而CPU的写命令线则应与芯片的充许写控制端相连。  

# 5.片选线的连接  

片选线的连接是CPU与存储芯片连接的关键。存储器由许多存储芯片叠加而成，哪一片被选中完全取决于该存储芯片的片选控制端CS是否能接收到来自CPU的片选有效信号。  

片选有效信号与CPU的访存控制信号MREQ（低电平有效）有关，因为只有当CPU要求访存时，才要求选中存储芯片。若CPU访问I/O，则MREQ为高，表示不要求存储器工作。  


# 3.4外部存储器  

# 3.4.1磁盘存储器  

磁盘存储器是以磁盘为存储介质的存储器，其主要优点： $\textcircled{\scriptsize{1}}$ 存储容量大，位价格低： $\circledcirc$ 记录介质可重复使用： $\textcircled{3}$ 记录信息可长期保存而不丢失，甚至可脱机存档： $\textcircled{4}$ 非破坏性读出，读出时不需要再生。缺点：存取速度慢，机械结构复杂，对工作环境要求较高。  

# 1.磁盘存储器  

>#### pro：  

# 磁盘存储器的相关概念（2019）  

（1）磁盘设备的组成  

$\textcircled{\scriptsize{1}}$ 磁盘存储器的组成。磁盘存储器由磁盘驱动器、磁盘控制器和盘片组成。  

·磁盘驱动器。驱动磁盘转动并在盘面上通过磁头进行读/写操作的装置，如图3.14所示。·磁盘控制器。磁盘驱动器与主机的接口，负责接收并解释CPU发来的命令，向磁盘驱 动器发出各种控制信号，并负责检测磁盘驱动器的状态。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/949e3320f633db83d48f7dfbb5d87ac3e37d71935bede8ce35981b7926da2bb7.jpg)  
图3.14磁盘驱动器示意图  

$\circledcirc$ 存储区域。一个磁盘含有若干记录面，每个记录面划分为若干圆形的磁道，而每条磁道又划分为若干扇区，扇区（也称块）是磁盘读/写的最小单位，即磁盘按块存取。  

·磁头数（Heads）：即记录面数，表示磁盘共有多少个磁头，磁头用于读取/写入盘片上记录面的信息，一个记录面对应一个磁头·柱面数（Cylinders）：表示磁盘每面盘片上有多少条磁道。在一个盘组中，不同记录面的相同编号（位置）的诸磁道构成一个圆柱面。  

·扇区数（Sectors）：表示每条磁道上有多少个扇区。  

相邻磁道及相邻扇区间通过一定的间隙分隔开，以避免精度错误。由于扇区按固定圆心角度划分，因此位密度从最外道向里道增加，磁盘的存储能力受限于最内道的最大记录密度。  
$\textcircled{3}$ 磁盘高速缓存（DiskCache）。在内存中开辟一部分区域，用于缓冲将被送到磁盘上的数据。优点：写磁盘时是按“簇”进行的，可以避免频繁地用小块数据写盘；有些中间结果数据在写回磁盘之前可被快速地再次使用。  

（2）磁记录原理  

编码方法：按某种方案（规律），把一连串的二进制信息变换成存储介质磁层中一个磁化翻转状态的序列，并使读/写控制电路容易、可靠地实现转换。  

磁记录方式：通常采用调频制（FM）和改进型调频制（MFM）的记录方式。  

（3）磁盘的性能指标  

$\textcircled{\scriptsize{1}}$ 记录密度。记录密度是指盘片单位面积上记录的二进制信息量，通常以道密度、位密度和面密度表示。道密度是沿磁盘半径方向单位长度上的磁道数，位密度是磁道单位长度上能记录的二进制代码位数，面密度是位密度和道密度的乘积。  

$\circledcirc$ 磁盘的容量。磁盘容量有非格式化容量和格式化容量之分。非格式化容量是指磁记录表面可利用的磁化单元总数，非格式化容量 $=$ 记录面数 $\cdot\times$ 柱面数 $\times$ 每条磁道的磁化单元数。格式化容量是指按照某种特定的记录格式所能存储信息的总量。格式化容量  $=$  记录面数  $\times$  柱 面数 $\times$ 每道扇区数x每个扇区的容量。格式化后的容量比非格式化容量要小。  

>#### pro：磁盘存取时间的计算（2013、2015、2022）  

$\circledast$ 存取时间。存取时间由寻道时间（磁头移动到自的磁道的时间）、旋转延迟时间（磁头定位到要读/写扇区的时间）和传输时间（传输数据所花费的时间）三部分构成。因为寻道和我扇区的距离远近不一，所以寻道时间和旋转延迟时间通常取平均值（平均寻道时间取从最外道移动到最内道时间的一半，平均旋转延迟时间取旋转半周的时间）。  

$\textcircled{4}$ 数据传输速率。磁盘存储器在单位时间内向主机传送数据的字节数，称为数据传输速率。假设磁盘转数为r转/秒，每条磁道容量为 $N$ 字节，则数据传输速率为  

$$
D_{\mathrm{r}}\,{=}\,r N
$$  

# （4）磁盘地址  

>#### pro：磁盘地址结构的计算（2022）  

主机向磁盘控制器发送寻址信息，磁盘的地址一般如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/63c7621ebd786e99322bc2b3b8f2b7a6108c715c1896f3fefe6388625f9c5d47.jpg)  

若磁盘有16个盘面，每个盘面有256个磁道，每个磁道划分为16个扇区，则每个扇区地址要16位二进制代码，其格式如下图所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a05c8eee3f46040951717583967f67c0aa6f299dd9fed653a49b666bc3e3b2b4.jpg)  

（5）磁盘的工作过程  

磁盘的主要操作是寻址、读盘、写盘。每个操作都对应一个控制字，磁盘工作时，第一步是取控制字，第二步是执行控制字。磁盘属于机械式部件，其读/写操作是事行的，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据。  

# 2.磁盘阵列  

RAID（独立冗余磁盘阵列）是指将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分割交义存储、并行访问，具有更好的存储性能、可靠性和安全性。  
>#### pro：提高RAID可靠性的措施（2013）  

RAID的分级如下所示。在RAID1～RAID5几种方案中，无论何时有磁盘损坏，都可随时拔出受损的磁盘再插入好的磁盘，而数据不会损坏，提升了系统的可靠性。  

RAID0：无冗余和无校验的磁盘阵列，RAID1：镜像磁盘阵列。RAID2：采用纠错的海明码的磁盘阵列。RAID3：位交叉奇偶校验的磁盘阵列。RAID4：块交叉奇偶校验的磁盘阵列。RAID5：无独立校验的奇偶校验磁盘阵列。  

RAIDO把连续多个数据块交替地存放在不同物理磁盘的扇区中，几个磁盘交叉并行读/写，即条带化技术，这样不仅扩大了存储容量，还提高了磁盘存取速度，但RAIDO没有容错能力。  

为了提高可靠性，RAID1使两个磁盘同时进行读/写，互为备份，若一个磁盘出现故障，可从另一磁盘中读出数据。两个磁盘当一个磁盘使用，意味着容量减少一半。  

总之，RAID通过同时使用多个磁盘，提高了传输速率；通过在多个磁盘上并行存取来大幅提高存储系统的数据吞吐量：通过镜像功能，提高安全可靠性：通过数据校验，提供容错能力。  

# 3.4.2 固态硬盘  

# 1.固态硬盘的特性  

固态硬盘（SSD）是一种基于闪存技术的存储器。它与U盘并无本质差别，只是容量更大，存取性能更好。一个SSD由一个或多个闪存芯片和闪存翻译层组成，如图3.15所示。闪存芯片替代传统旋转磁盘中的机械驱动器，而闪存翻译层将来自CPU的逻辑块读/写请求翻译成对底层 物理设备的读/写控制信号，因此，这个闪存翻译层相当于代替了磁盘控制器的角色。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f4c9b82aff9e75d81635a4e6f89fa583ec0838d5124b1cd07047a821d4691ebd.jpg)  
图3.15固态硬盘（SSD）  

在图3.15中，一个闪存由 $B$ 块组成，每块由 $P$ 页组成。通常，页的大小是 $512\mathrm{B}{\sim}4\mathrm{KB}$ ，每块由 $32\!\sim\!128$ 页组成，块的大小为 $16\mathrm{KB}{\sim}512\mathrm{KB}$ 。数据是以页为单位读/写的。只有在一页所属的块整个被擦除后，才能写这一页。不过，一旦一个块被擦除，块中的每个页就都可以直接再写一次。某个块进行了若干次重复写之后，就会磨损坏，不能再使用。  

随机写很慢，有两个原因。首先，擦除块较慢，通常比访问页高一个数量级。其次，若写操作试图修改一个包含已有数据的页 $P_{i},$ 则这个块中所有含有用数据的页都必须被复制到一个新（擦除过的）块中，然后才能进行对页 $P_{i}$ 的写操作。  

比起传统磁盘，SSD有很多优点，它由半导体存储器构成，没有移动的部件，因而随机访问时间比机械磁盘要快很多，也没有任何机械噪声和振动，能耗更低，抗震性好，安全性高等。  
# 2.磨损均衡（Wear Leveling）  

固态硬盘也有缺点，闪存的擦写寿命是有限的，一般是几百次到几干次。若直接用普通闪存组装SSD，则实际的寿命表现可能非常令人失望一一读/写数据时会集中在SSD的一部分闪存，这部分闪存的寿命会损耗得特别快。一旦这部分闪存损坏，整块SSD也就损坏了。这种磨损不均衡的情况，可能会导致一块256GB的SSD，只因数兆字节空间的闪存损坏而整块损坏。  

为了弥补SSD的寿命缺陷，引入了磨损均衡。SSD磨损均衡技术大致分为两种1）动态磨损均衡。写入数据时，自动选择较新的闪存块。老的闪存块先歇一歇。  

2）静态磨损均衡。这种技术更为先进，就算没有数据写入，SSD也会监测并自动进行数据分配，让老的闪存块承担无须写数据的存储任务，同时让较新的闪存块腾出空间，平常的读/写操作在较新的闪存块中进行。如此一来，各个闪存块的寿命损耗就都差不多。  

有了这种算法加持，SSD的寿命就比较可观了。例如，对于一个256GB的SSD，若闪存的擦写寿命是500次，则需要写入125TB数据，才寿终正寝。就算每天写入10GB数据，也要三十多年才能将闪存磨损坏，更何况很少有人每天往SSD中写入10GB数据。  
 

# 3.5高速缓冲存储器  

由于程序的转移概率不会很低，数据分布的离散性较大，因此单纯依靠并行主存系统提高主存系统的效率是有限的。高速缓存Cache拥有比主存更快的速度，因此在CPU和主存之间设置Cache可以显著提高存储系统的效率。Cache由SRAM组成，通常直接集成在CPU中。  

# 3.5.1程序访问的局部性原理  

程序访问的局部性原理包括时间局部性和空间局部性。>#### pro：分析给定代码的时空局部性（2017、2023）  

时间局部性是指最近的未来要用到的信息，很可能是现在正在使用的信息，因为程序中存在盾环和需要多次重复执行的子程序段，以及对数组的存储和访问操作。空间局部性是指最近的末来要用到的信息，很可能与现在正在使用的信息在存储空间上是邻近的，因为指令通常是顺序存放、顺序执行的，数据一般也是以向量、数组等形式簇聚地存储的。  
高速缓冲技术就是利用局部性原理，把程序中正在使用的部分数据存放在一个高速的、容量较小的Cache中，使CPU的访存操作大多数针对Cache进行，从而提高程序的执行速度。  

【例3.2】假设数组元素按行优先方式存储，对于下面的两个程序：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b41550f0178bf3620106cb205eed357ec765a9ec70eeda1a5cf5cda98d67dbf0.jpg)  

1）对于数组a的访问，哪个空间局部性更好？哪个时间局部性更好？2）对于指令访问来说，for循环体的空间局部性和时间局部性如何？  

解：假定M、N都为2048，按字节编址，每个数组元素占4字节，则指令和数据在主存中的存放情况如图3.16所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3beffe3fd561e33f22d27b23b7735f6b3805a9b89288a00b6514d0ad34b06ace.jpg)  
图3.16指令和数据在主存的存放  

>#### pro：数组按行或列访问命中率的分析（2010）；数组循环访问的命中率分析（2016、2020）  

1）对于数组a，程序A和程序B的空间局部性相差较大  

程序A对数组a的访问顺序为a[0][0],a[0][1],,a[0][2047];a[1][0],a[1][1],,a[1][2047] 由此可见，访问顺序与存放顺序是一致的，因此空间局部性好。  

程序B对数组a的访问顺序为a[0][0],a[1][0].,a[2047][0];a[0][1],a[1][1],,a[2047][1]；。由此可见，访问顺序与存放顺序不一致，每次访问都要跳过2048个数组元素，即8192字节，若主存与Cache的交换单位小于8KB，则每访问一个数组元素都需要将一个主存块装入Cache，因而没有空间局部性。  

两个程序中，数组a的时间局部性都差，因为每个数组元素都只被访问一次。  
>#### pro：程序中指令Cache的命中率分析（2014）  

2）对于for循环体，程序A和程序B中的访问局部性是一样的。因为循环体内指令按序连续存放，所以空间局部性好；内循环体被连续重复执行 $2048{\times}2048$ 次，因此时间局部性也好。  

由上述分析可知，虽然程序A和程序B的功能相同，但因内、外两重循环的顺序不同而导致两者对数组a访问的空间局部性相差较大，从而带来执行时间的巨大差异。  

# 3.5.2Cache的基本工作原理  

为便于Cache与主存交换信息，Cache和主存都被划分为大小相等的块，Cache块也称Cache行，每块由若干字节组成，块的长度称为块长（也称行长）。因为Cache的容量远小于主存的容量，所以Cache中的块数要远少于主存中的块数，Cache中仅保存主存中最活跃的若干块的副本。因此，可按照某种策略预测CPU在未来一段时间内欲访存的数据，将其装入Cache。图3.17所示为Cache的基本结构。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e95e7ed2b82fea1f024168bab35ac7aaf81ff99ed3bddc2a543be0029e74d2bd.jpg)  
图3.17高速缓冲存储器的工作原理  

>#### pro：  

Cache命中对CPU执行时间影响的分析（2013、2015）  

当CPU发出读请求时，若访存地址在Cache中命中，就将此地址转换成Cache地址，直接对Cache进行读操作，与主存无关；若Cache不命中，则仍需访问主存，并把此字所在的块一次性地从主存调入Cache。若此时Cache已满，则需根据某种替换算法，用这个块替换Cache中原来的某块信息。整个过程全部由硬件实现。值得注意的是，CPU与Cache之间的数据交换以字为单位，而Cache与主存之间的数据交换则以Cache块为单位。  

当CPU发出写请求时，若Cache命中，有可能会遇到Cache与主存中的内容不一致的问题。例如，由于CPU写Cache，把Cache某单元中的内容从 $X$ 修改成 $X$ ，而主存对应单元中的内容仍然是 $X,$ ，没有改变，因此若Cache命中，需要按照一定的写策略处理，常见的处理方法有全写法和回写法，详见本节的Cache写策略部分。  

# 注意  

某些计算机中也采用同时访问Cache和主存的方式，若Cache命中，则终止访存。  

>#### pro：Cache命中率的计算（2009）  

CPU欲访问的信息已在Cache 中的比率称为Cache的命中率。设一个程序执行期间，Cache的总命中次数为 $N_{\mathrm{c}}$ ，访问主存的总次数为 $N_{\mathrm{m}}$ ，则命中率 $H$ 为  
$$
H={N_{\mathrm{c}}}\,/({N_{\mathrm{c}}}+{N_{\mathrm{m}}})
$$  

可见为提高访问效率，命中率 $H$ 越接近1越好。设 $t_{c}$ 为命中时的Cache访问时间， $t_{\mathrm{m}}$ 为未命中时的访问时间， $1-H$ 表示未命中率，则Cache-主存系统的平均访问时间 $T_{\mathrm{a}}$ 为  

$$
T_{\mathrm{a}}=H t_{\mathrm{c}}+\left(1-H\right)t_{\mathrm{m}}
$$  

>#### pro：Cache缺失率对主存带宽的影响（2012）  

【例3.3】假设Cache的速度是主存的5倍，且Cache的命中率为 $95\%$ ，则采用Cache后，存储器性能提高多少（假设采用先访问Cache，Cache不命中时，才采用访问主存的方式）？  

解：设Cache的存取周期为 $t$ ，主存的存取周期为 $5t$ ，得出系统的平均访问时间 $T$ 为  

$T\!=$ Cache命中时的访问时间 $\times$ 命中率 $^+$ Cache缺失时的访问时间 $\times$ 缺失率 $=0.95\times t+0.05\times(t+5t)=1.25t$  

或  

$T\!=$  Cache命中时的访问时间  $^+$  Cache缺失时的访存开销  $\times$  缺失率  $=t+0.05{\times}5t=1.25t$  可知，采用Cache后的存储器性能为原来的 $5t/1.25t/{\approx}\,4$ 倍。  

根据Cache的读、写流程，可知实现Cache时需解决以下关键问题  

1）数据查找。如何快速判断数据是否在Cache中。2）地址映射。主存块如何存放在Cache中，如何将主存地址转换为Cache地址。3）替换策略。Cache满后，使用何种策略对Cache块进行替换或淘汰。4）写入策略。如何既保证主存块和Cache块的数据一致性，又尽量提升效率。  

# 3.5.3Cache和主存的映射方式  

由于Cache行数比主存块数少得多，因此主存中只有一部分块的信息可放在Cache中，因此在Cache中要为每块加一个标记位，指明它是主存中哪一块的副本。该标记的内容相当于主存中块的编号。为了说明Cache行中的信息是否有效，每个Cache行需要一个有效位。  

Cache行中的信息是主存中某个块的副本，地址映射是指把主存地址空间映射到Cache地址空间，即把存放在主存中的信息按照某种规则装入Cachnie。地址映射的方法有以下3种。  

1.直接映射  

主存中的每一块只能装入Cache中的唯一位置。若这个位置已有内容，则产生块冲突，原来的块将无条件地被替换出去（无须使用替换算法）。直接映射实现简单，但不够灵活，即使Cache的其他许多地址空着也不能占用，这使得直接映射的块冲突概率最高，空间利用率最低。  

>#### pro：直接映射的地址结构及映射关系的分析（2010、2011、2015）  

直接映射的关系可定义为  

Cache行号 $=$ mod Cache  

假设Cache共有 $2^{c}$ 行，主存有 $2^{m}$ 块，在直接映射方式中，主存的第0块、第 $2^{c}$ 块、第 $2^{c+1}$ 块·………·只能映射到Cache的第0行；而主存的第1块、第 $2^{c}+1$ 块、第 $2^{c+1}+1$ 块·只能映射到Cache的第1行，以此类推。由映射函数可看出，主存块号的低 $^c$ 位正好是它要装入的Cache行号。给每个Cache行设置一个长为 $\scriptstyle t\,=\,m\,-\,c$ 的标记（tag），当主存某块调入Cache后，就将其块号的高 $t$ 位设置在对应Cache行的标记中，如图3.18（a所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0d4d9150e1b74972905e0f2411e001d19ac079c052b685d6319df172fd1f46af.jpg)  
图3.18Cache和主存之间的直接映射方式  

直接映射的地址结构为  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1a310ec397e1e430790891edc7b4fe7034517d79896535099a72318e362d5cfc.jpg)  

CPU访存过程如图3.18（b）所示。首先根据访存地址中间的c位，找到对应的Cache行，将对 应Cache行中的标记和主存地址的高t位标记进行比较，若相等且有效位为1，则访问Cache“命中”，此时根据主存地址中低位的块内地址，在对应的Cache行中存取信息；若不相等或有效位为O，则“不命中”，此时CPU从主存中读出该地址所在的一块信息送到对应的Cache行中，将有效位置1，并将标记设置为地址中的高：位，同时将该地址中的内容送CPU。  

# 2.全相联映射  

主存中的每一块可以装入Cache中的任何位置，如图3.19所示，每行的标记用于指出该行来自主存的哪一块，因此CPU访存时需要与所有Cache行的标记进行比较。优点： $\textcircled{\scriptsize{1}}$ Cache块的冲突概率低，只要有空闲Cache行，就不会发生冲突： $\circledcirc$ 空间利用率高： $\textcircled{3}$ 命中率高：缺点： $\textcircled{\scriptsize{1}}$ 标记的比较速度较慢： $\circledcirc$ 实现成本较高，通常需采用按内容寻址的相联存储器。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a8989ceb071e5ad8c8d6dca134a27f62a4c6286c510cc52ef891f745bf53aba0.jpg)  
图3.19Cache和主存之间的全相联映射方式  

全相联映射的地址结构为  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d778483358bb5cfaa81acdb4053dea9aacce5ec9ea238257e705ba9e2fca92cd.jpg)  
CPU访存过程如下：首先将主存地址的高位标记（位数 $=\log_{2}$ 主存块数）与Cache各行的标记进行比较，若有一个相等且对应有效位为1，则命中，此时根据块内地址从该Cache行中取出信息；若都不相等，则不命中，此时CPU从主存中读出该地址所在的一块信息送到Cache的任意一个空闲行中，将有效位置1，并设置标记，同时将该地址中的内容送CPU。  

>#### pro：根据地址结构和比较器数量判断映射方式（2018）  

通常为每个Cache行都设置一个比较器，比较器位数等于标记字段的位数。访存时根据标记字段的内容来访问Cache行中的主存块，因而其查找过程是一种“按内容访问”的存取方式，所以是一种“相联存储器”。这种方式的时间开销和硬件开销都较大，不适合大容量Cache。  

# 3.组相联映射  

>#### pro：组相联映射方式的原理（2009、2016、2018～2020、2023）  

将Cache分成 $\mathcal{Q}$ 个大小相等的组，每个主存块可以装入固定组中的任意一行，即组间采用直接映射、而组内采用全相联映射的方式，如图3.20所示。它是对直接映射和全相联映射的一种折中，当 $Q=1$ 时变为全相联映射，当 $\varrho=$ Cache行数时变为直接映射。路数越大，即每组Cache行的数量越大，发生块冲突的概率越低，但相联比较电路也越复杂。选定适当的数量，可使组相联映射的成本接近直接映射，而性能上仍接近全相联映射。假设每组有 $r$ 个Cache行，则称为 $r$ 路组相联，图3.20中每组有两个Cache行，因此称为二路组相联。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/705d35296eca71ed8eded974c3d677da76008d584c3b528fa5e8971962c6d880.jpg)  
图3.20Cache和主存之间的二路组相联映射方式  

组相联映射的关系可以定义为  

Cache组号 $=$ mod Cache 组数（Q）  

组相联映射的地址结构为  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/16468247b7f68d80ea35bf713452faaeaab1af0cc4620f1f67e90b71bd4d66a4.jpg)  

>#### pro：组相联映射的访存过程及Cache缺失处理过程（2020）  

CPU访存过程如下：首先根据访存地址中间的组号找到对应的Cache组；将对应Cache组中每个行的标记与主存地址的高位标记进行比较；若有一个相等且有效位为1，则访问Cache命中，此时根据主存地址中的块内地址，在对应Cache行中存取信息；若都不相等或虽相等但有效位为0，则不命中，此时CPU从主存中读出该地址所在的一块信息送到对应Cache组的任意一个空闲行中，将有效位置1，并设置标记，同时将该地址中的内容送CPU。  
>#### pro：组相联映射中比较器的个数和位数（2022）  

直接映射因为每块只能映射到唯一的Cache行，因此只需设置1个比较器。而 $r$ 路组相联映射需要在对应分组中与 $r$ 个Cache行进行比较，因此需设置 $r$ 个比较器。  

>#### pro：直接映射、组相联映射相关标记位及总容量的分析（2010）  

【例3.4】假设某个计算机的主存地址空间大小为256MB，按字节编址，其数据Cache有8个Cache行，行长为64B。  

1）若不考虑用于Cache的一致维护性位（脏位）和替换算法控制位，并且采用直接映射方式，则该数据Cache的总容量为多少？2）若该Cache采用直接映射方式，则主存地址为3200（十进制）的主存块对应的Cache行号是多少？采用二路组相联映射时又是多少？3）以直接映射方式为例，简述访存过程（设访存的地址为0123456H）。  

解：  

1）因为Cache包括了可以对Cache中所包含的存储器地址进行跟踪的硬件，即Cache的总容量 $\bar{=}$ 存储容量 $^+$ 标记阵列容量（有效位、标记位），本题不考虑脏位和替换算法位。  

>#### pro：直接映射相关标记位的分析（2015、2021）  

# 注意  

每个Cache行对应一个标记项（包括有效位、脏位、替换算法位、标记位），在组相联中，将每组各行的标记项排成一行，将各组从上到下排列，构成一个二维的标记阵列。查找Cache时就是查找标记阵列的标记项是否符合要求。二路组相联的标记阵列如图3.21所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/57f1a99d258e755109902e23acf15b394fc66b1b280f1f9dca674653a358810b.jpg)  
图3.21二路组相联的标记阵列示意图  

因此本题中每行相关的存储器容量如图3.22所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/683ed3f03365e410bb54f631a3aa7975ef5c257a5d5fb4a06bc06596f36764f8.jpg)  
图3.22Cache行的存储容量示意图  

标记字段长度的计算：主存地址有28位 $(256\mathrm{MB}=2^{28}\mathrm{B}$ ），其中6位为块内地址（ $2^{6}\mathrm{B}=$ 64B），3位为行号 $(2^{3}=8)$ ），剩余 $28-6-3=19$ 位为标记字段，故数据Cache的总容量为 $8{\times}(1+19+512)=4256$ 位。  
2）直接映射方式中，主存按照块的大小划分，主存地址3200对应的字块号为 $3200\mathrm{B}/64\mathrm{B}=$ 50。而Cache只有8行，则 $50\;\mathrm{mod}\;8=2$ ，因此对应的Cache行号为2。二路组相联映射方式，实质上就是将两个Cache行合并，内部采用全相联方式，外部采用直接映射方式， $50~\mathrm{mod}\:4=2$ ，对应的组号为2，即对应的Cache行号为4或5。  

3）直接映射方式中，28位主存地址可分为19位的主存标记位，3位的块号，6位的块内地址，即 $0000\:0001\:0010\:0011\:010$ 为主存标记位，001为块号，010110为块内地址。首先根据块号，查Cache（即001号Cache行）中对应的主存标记位，看是否相同。若相同，再看Cache行中的有效位是否为1，若是，称此访问命中，按块内地址010110读出Cache行所对应的单元并送入CPU中，完成访存。若出现标记位不相等或有效位为0的情况，则不命中，访问主存将数据取出并送往CPU和Cache对应块中，把主存地址的高19位写入001行的标记位，并将有效位置1。  

思考： $\textcircled{\scriptsize{1}}$ 若第一问中采用二路组相联，则Cache总容量是多少？ $\textcircled{2}$ 仔细分析主存划分和Cache划分的关系，自行推导二路组相联映射方式的主存地址划分和访存过程。  

三种映射方式中，直接映射的每个主存块只能映射到Cache中的某一固定行；全相联映射可以映射到所有Cache行： $N$ 路组相联映射可以映射到 $N$ 行。当Cache大小、主存块大小一定时，  

1）直接映射的命中率最低，全相联映射的命中率最高。2）直接映射的判断开销最小、所需时间最短，全相联映射的判断开销最大、所需时间最长。3）直接映射标记所占的额外空间开销最少，全相联映射标记所占的额外空间开销最大。  

# 3.5.4Cache中主存块的替换算法  

在采用全相联映射或组相联映射方式时，从主存向Cache传送一个新块，当Cache或Cache组中的空间已被占满时，就需要使用替换算法置换Cache行。而采用直接映射时，一个给定的主存块只能放到唯一的固定Cache行中，所以在对应Cache行已有一个主存块的情况下，新的主存块毫无选择地把原先已有的那个主存块替换掉，因而无须考虑替换算法。  

常用的替换算法有随机（RAND）算法、先进先出（FIFO）算法、近期最少使用（LRU）算法和最不经常使用（LFU）算法。其中最常考查的是LRU算法。  

1）随机算法：随机地确定替换的Cache行。它的实现比较简单，但未依据程序访问的局部性原理，因此可能命中率较低。2）先进先出算法：选择最早调入的Cache行进行替换。它比较容易实现，但也未依据程序访问的局部性原理，因为最早进入的主存块也可能是目前经常要用的。  

>#### pro：组相联映射中LRU算法的命中分析（2012、2021）  

3）近期最少使用算法（LRU）：依据程序访问的局部性原理，选择近期内长久未访问过的Cache行进行替换，其平均命中率要比FlFO的高，是堆栈类算法。  

>#### pro：LRU替换位及其位数的计算（2018、2020）  

LRU算法对每个Cache行设置一个计数器（也称LRU替换位），用计数值来记录主存块的使用情况，并根据计数值选择淘汰某个块，计数值的位数与Cache组大小有关，二路时有1位LRU 位，四路时有2位LRU位。假定采用四路组相联，有5个主存块 $\{1,2,3,4,5\}$ 映射到Cache的同一组，对于主存访问序列 $\{1,2,3,4,1,2,5,1,2,3,4,5\},$ 采用LRU算法的替换过程如图3.23所示。图中左边阴影的数字是对应Cache行的计数值，右边的数字是存放在该行中的主存块号。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/172e58f1cfb7469387af458dc7e49c1ea931605bc2c9081f5e57a4932c9604de.jpg)  
图3.23LRU算法的替换过程示意图  

计数器的变化规则： $\textcircled{\scriptsize{1}}$ 命中时，所命中的行的计数器清零，比其低的计数器加1，其余不变： $\circledcirc$ 未命中且还有空闲行时，新装入的行的计数器置0，其余全加1； $\textcircled{3}$ 未命中且无空闲行时，计数值为3的行的信息块被替换，新装入的行的计数器置0，其余全加1。  

当集中访问的存储区超过Cache组的大小时，命中率可能变得很低，如上例的访问序列变为 $1,2,3,4,5,1,2,3,4,5,\cdots,$ ，而Cache每组只有4行，则命中率为0，这种现象称为抖动。  

4）最不经常使用算法：将一段时间内被访问次数最少的Cache行换出。每行也设置一个计数器，新行装入后从0开始计数，每访问一次，被访问的行计数器加1，需要替换时比较各特定行的计数值，将计数值最小的行换出。这种算法与LRU类似，但不完全相同。  

# 3.5.5Cache的一致性问题  

因为Cache中的内容是主存块副本，当对Cache中的内容进行更新时，就需选用写操作策略使Cache内容和主存内容保持一致。此时分两种情况。  

对于Cache写操作命中（writehit），有两种处理方法。  

>#### pro：直写法的特点（2015）、直写法是否需设修改位（2020）  

1）全写法（直写法、Write-through）。当CPU对Cache写命中时，必须把数据同时写入Cache和主存。当某一块需要替换时，就不必把这一块写回主存了，用新调入的块直接覆盖即可。这种方法实现简单，能随时保持主存数据的正确性。缺点是增加了访存次数，降低了Cache的效率。写缓冲：为减少全写法直接写入主存的时间损耗，在Cache和主存之间加一个写缓冲（WriteBuffer），如下图所示。CPU同时写数据到Cache和写缓冲中，写缓冲再将内容写入主存。写缓冲是一个FO队列，写缓冲可以解决速度不匹配的问题。但若出现频繁写时，会使写缓冲饱和溢出。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f5ab311434521af2d47d204cc146f946fd1d802128ddcf2071dc6828c717e2cc.jpg)  

>#### pro：回写法的修改位（2018、2020）  

2）回写法（write-back）?。当CPU对Cache写命中时，只把数据写入Cache，而不立即写入主存，只有当此块被替换出时才写回主存。这种方法减少了访存次数，但存在数据不一致的隐惠。为了减少写回主存的次数，给每个Cache行设置一个修改位（脏位）。若修改位为1，则说明对应Cache行中的块被修改过，替换时须写回主存；若修改位为0，则 说明对应Cache行中的块未被修改过，替换时无须写回主存。  
全写法和回写法都对应于Cache写命中（要被修改的块在Cache中）时的情况。  

对于Cache写操作不命中，也有两种处理方法。  

1）写分配法（write-allocate）。更新主存单元，然后把这个主存块调入Cache。它试图利用程序的空间局部性，缺点是每次写不命中都要从主存读一个块到Cache中。  

2）非写分配法（not-write-allocate）。只更新主存单元，而不把主存块调入Cache。  

非写分配法通常与全写法合用，写分配法通常和回写法合用。  

>#### pro：  

# 采用分离的指令Cache和数据Cache的主要目的（2014）  

随着指令流水技术的发展，需要将指令Cache和数据Cache分开设计，这就有了分离的Cache结构。统一Cache的优点是设计和实现相对简单，但由于执行部件存取数据时，指令预取部件要从同一Cache读指令，因此会引发冲突。采用分离的Cache结构可以解决这个问题，而且分离的指令和数据Cache还可以充分利用指令和数据的不同局部性来优化性能。  

现代计算机的Cache通常设立多级Cache，假定设2级Cache，按离CPU的远近可各自命名为L1Cache、L2Cache，离CPU越远，访问速度越慢，容量越大。指令Cache与数据Cache分离一般在L1级，此时通常为写分配法与回写法合用。下图是一个含有两级Cache的系统，L1Cache对L2Cache使用全写法，L2Cache对主存使用回写法，由于L2Cache的存在，其访问速度大于主存，因此避免了因频繁写时造成的写缓冲饱和溢出。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a36a40284b9aa454bc42de878bcab6fe9160cad5f6b92ce9054bac667f2a2cf5.jpg)  
  

# 3.6虚拟存储器  

主存和辅存共同构成了虚拟存储器，二者在硬件和系统软件的共同管理下工作。对于应用程序员而言，虚拟存储器是透明的。虚拟存储器具有主存的速度和辅存的容量。  

# 3.6.1虚拟存储器的基本概念  

虚拟存储器将主存或辅存的地址空间统一编址，形成一个庞大的地址空间，在这个空间内，用户可以自由编程，而不必在乎实际的主存容量和程序在主存中实际的存放位置。  

用户编程允许涉及的地址称为虚地址或逻辑地址，虚地址对应的存储空间称为虚拟空间或程序空间。实际的主存单元地址称为实地址或物理地址，实地址对应的是主存地址空间，也称实地址空间。虚地址比实地址要大很多。虚拟存储器的地址空间如图3.24所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3f30148f78a751f6de56c12ee740b690d95cef0f05379cb11a3386b06baf0ec8.jpg)  
图3.24虚拟存储器的三个地址空间  

CPU使用虚地址时，先判断这个虚地址对应的内容是否已装入主存。若已在主存中，则通过地址变换，CPU可直接访问主存指示的实际单元；若不在主存中，则把包含这个字的一页或一段调入主存后再由CPU访问。若主存已满，则采用替换算法置换主存中的交换块（页面）。  

>#### pro：虚拟存储器只能采用回写法的原因（2016）  

虚拟存储器也采用和Cache类似的技术，将辅存中经常访问的数据副本存放到主存中。但是缺页（或段）而访问辅存的代价很大，提高命中率是关键，因此虚拟存储机制采用全相联映射，每个虚页面可以存放到对应主存区域的任何一个空闲页位置。此外，当进行写操作时，不能每次写操作都同时写回磁盘，因而，在处理一致性问题时，采用回写法。  
# 3.6.2页式虚拟存储器  

页式虚拟存储器以页为基本单位。主存空间和虚拟地址空间都被划分成相同大小的页，主存空间中的页称为物理页、实页、页框，虚拟地址空间中的页称为虚拟页、虚页。页表记录了程序的虚页调入主存时被安排在主存中的位置。页表一般长久地保存在内存中。  

# 1.页表  

图3.25是一个页表示例。有效位也称装入位，用来表示对应页面是否在主存，若为1，则表示该虚拟页已从外存调入主存，此时页表项存放该页的物理页号：若为0，则表示没有调入主存，此时页表项可以存放该页的磁盘地址。脏位也称修改位，用来表示页面是否被修改过，虚存机制中采用回写策略，利用脏位可判断替换时是否需要写回磁盘。引用位也称使用位，用来配合替换策略进行设置，例如是否实现最先调入（FIFO位）或最近最少用（LRU位）策略等。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b8ab5292e69b51c36468563f144fde40a570b1a370f205fa85c05cc588cbae16.jpg)  
图3.25主存中的页表示例  

>#### pro：数组的分页存放、缺页异常分析及缺页处理过程（2014、2019、2023）  

以图3.25的页表为例，假设CPU欲访问的数据在第1页，对应的有效位为1，说明该页已存放在主存中，再通过地址转换部件将虚拟地址转换为物理地址，然后到相应的主存实页中存取数据。若该数据在第5页，有效位为0，则发生“缺页”异常，需调用操作系统的缺页异常处理程序。缺页处理程序根据对应表项中的存放位置字段，将所缺页面从磁盘调入一个空闲的物理页框。若主存中没有空闲页框，还需要选择一个页面替换。由于采用回写策略，因此换出页面时根据脏位确定是否要写回磁盘。缺页处理过程中需要对页表进行相应的更新。  

页式虚拟存储器的优点是，页面的长度固定，页表简单，调入方便。缺点是，因为程序不可能正好是页面的整数倍，最后一页的零头将无法利用而造成浪费，并且页不是逻辑上独立的实体，所以处理、保护和共享都不及段式虚拟存储器方便。  

# 2.地址转换  

>#### pro：虚拟地址结构的分析（2011、2019、2021）  

在虚拟存储系统中，指令给出的地址是虚拟地址，因此当CPU执行指令时，要先将虚拟地址转换为主存物理地址，才能到主存中存取指令和数据。虚拟地址分为两个字段：高位为虚页号，低位为页内偏移地址。物理地址也分为两个字段：高位为物理页号，低位为页内偏移地址。由于两者的页面大小相同，因此页内偏移地址是相等的。虚拟地址到物理地址的转换是由页表实现的，页表是一张存放在主存中的虚页号和实页号的对照表。  
>#### pro：虚拟地址主存物理地址（2011、2013、2018、2022）  

每个进程都有一个页表基址寄存器，存放该进程的页表首地址，据此找到对应的页表首地址（对应 $^\mathrm{\textregistered}$ )，然后根据虚拟地址高位的虚拟页号找到对应的页表项（对应 $\mathcal{Q}$ ），若装入位为1，则取出物理页号（对应 $\textcircled{3}$ ），和虚拟地址低位的页内地址拼接，形成实际物理地址（对应 $^{(4)}$ ）。若装入位为0，说明缺页，需要操作系统进行缺页处理。地址变换过程如图3.26所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8abbc24dc44951166da271761d02b9beff867be6de5e5dc08cc6e6325bcebf8e.jpg)  
图3.26页式虚拟存储器的地址变换过程  

3.快表（TLB）  

由地址转换过程可知，访存时先访问一次主存去查页表，再访问主存才能取得数据。若缺页，则还要进行页面替换、页面修改等，因此采用虚拟存储机制后，访问主存的次数更多了。  

>#### pro：TLB的硬件实现（2018），TLB和Cache的比较（2020）  

依据程序访问的局部性原理，在一段时间内总是经常访问某些页时，若把这些页对应的页表项存放在高速缓冲器组成的快表（TLB）中，则可以明显提高效率。相应地把放在主存中的页表称为慢表（Page）。在地址转换时，首先查找快表，若命中，则无须访问主存中的页表。  

>#### pro：TLB映射方式、地址划分与标记字段：与Cache相同（2016、2021）  

快表用SRAM实现，其工作原理类似于Cache，通常采用全相联或组相联映射方式。TLB表项由页表表项内容和TLB标记组成。全相联映射下，TLB标记就是对应页表项的虚拟页号；组相联方式下，TLB标记则是对应虚拟页号的高位部分，而虚拟页号的低位部分作为TLB组的组号。  

# 4.具有TLB和Cache的多级存储系统  

图3.27是一个具有TLB和Cache的多级存储系统，其中Cache采用二路组相联方式。CPU给出一个32位的虚拟地址，TLB采用全相联方式，每一项都有一个比较器，查找时将虚页号与每个TLB标记字段同时进行比较，若有某一项相等且对应有效位为1，则TLB命中，此时可直接通过TLB进行地址转换；若未命中，则TLB缺失，需要访问主存去查页表。图中所示的是两级页表方式，虚页号被分成页目录索引和页表索引两部分，由这两部分得到对应的页表项，从而进行地址转换，并将相应表项调入TLB，若TLB已满，则还需要采用替换策略。完成由虚拟地址到物理地址的转换后，Cache机构根据映射方式将物理地址划分成多个字段，然后根据映射规则找到对应的Cache行或组，将对应Cache行中的标记与物理地址中的高位部分进行比较，若相等且对应有效位为1，则Cache命中，此时根据块内地址取出对应的字送给CPU。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/631bb0e61b3bdacef3897c62f9b2563c6e1aa46c348e5f719e87b9db2f47ed57.jpg)  
图3.27TLB和Cache的访问过程  

查找时，快表和慢表也可以同步进行，若快表中有此虚页号，则能很快地找到对应的实页号，并且使慢表的查找作废，从而就能做到虽采用虚拟存储器但访问主存速度几乎没有下降。  

>#### pro：TLB、Cache和Page缺失组合的分析（2010）  

在一个具有TLB和Cache的多级存储系统中，CPU一次访存操作可能涉及TLB、页表、Cache、主存和磁盘的访问，访问过程如图3.28所示。可见，CPU访存过程中存在三种缺失情况： $\textcircled{\scriptsize{1}}$ TLB缺失：要访问的页面的页表项不在TLB中： $\circledcirc$ Cache缺失：要访问的主存块不在Cache中： $\textcircled{3}$ Page缺失：要访问的页面不在主存中。由于TLB只是页表的一部分副本，因此Page缺失时，TLB也必然缺失。同理，Cache也只是主存的一部分副本，页表未命中意味着信息不在主存，因此Page缺失时，Cache也必然缺失。这三种缺失的可能组合情况如表3.3所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/410f211a8065de602231efcdde6fb31482045afcb7cd24653c854c6b447608e7.jpg)  
图3.28带TLB虚拟存储器的CPU访存过程  
表3.3TLB、Page、Cache三种缺失的可能组合情况
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5449e48e05a1210c3ad8e1dda8ec750f02c257f2e7997847b56ece5d409deea7.jpg)  

最好的情况是第1种组合，此时无须访问主存；第2种和第3种组合都需要访问一次主存；第4种组合需要访问两次主存；第5种组合发生“缺页异常”，需要访问磁盘，并且至少访问两次主存。Cache缺失处理由硬件完成；缺页处理由软件完成，操作系统通过“缺页异常处理程序”来实现：而TLB缺失既可以用硬件，又可以用软件来处理。  

# 注意  

在《操作系统考研复习指导》的第3章中，介绍了在同时具有TLB和Cache的存储系统中虚实地址转换的实例，读者可以结合这些内容进行学习。  

# 3.6.3段式虚拟存储器  

段式虚拟存储器中的段是按程序的逻辑结构划分的，各个段的长度因程序而异。把虚拟地址分为两部分：段号和段内地址。虚拟地址到实地址之间的变换是由段表来实现的。段表是程序的逻辑段和在主存中存放位置的对照表。段表的每行记录与某个段对应的段号、装入位、段起点和段长等信息。因为段的长度可变，所以段表中要给出各段的起始地址与段的长度。  

CPU根据虚拟地址访存时，首先根据段表基地址与段号拼接成对应的段表项，然后根据该段表项的装入位判断该段是否已调入主存（装入位为“1”，表示该段已调入主存；装入位为“0”表示该段不在主存中）。已调入主存时，从段表读出该段在主存中的起始地址，与段内地址（偏移量）相加，得到对应的主存实地址。段式虚拟存储器的地址变换过程如图3.29所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1b0fa6804dac3b58468ab24b6f02dbc573bbcb4d48f2326802894513dae0c641.jpg)  
图3.29段式虚拟存储器的地址变换过程  

因为段本身是程序的逻辑结构所决定的一些独立部分，因而分段对程序员来说是不透明的：而分页对程序员来说是透明的，程序员编写程序时不需知道程序将如何分页。  

段式虚拟存储器的优点是，段的分界与程序的自然分界相对应，因而具有逻辑独立性，使得它易于编译、管理、修改和保护，也便于多道程序的共享；缺点是因为段长度可变，分配空间不便，容易在段间留下碎片，不好利用，造成浪费。  
# 3.6.4段页式虚拟存储器  

在段页式虚拟存储器中，把程序按逻辑结构分段，每段再划分为固定大小的页，主存空间也划分为大小相等的页，程序对主存的调入、调出仍以页为基本交换单位。每个程序对应一个段表，每段对应一个页表，段的长度必须是页长的整数倍，段的起点必须是某一页的起点。  

虚地址分为段号、段内页号、页内地址三部分。CPU根据虚地址访存时，首先根据段号得到段表地址；然后从段表中取出该段的页表起始地址，与虚地址段内页号合成，得到页表地址；最后从页表中取出实页号，与页内地址拼接形成主存实地址。  

段页式虚拟存储器的优点是，兼具页式和段式虚拟存储器的优点，可以按段实现共享和保护。缺点是在地址变换过程中需要两次查表，系统开销较大。  

# 3.6.5 虚拟存储器与Cache的比较  

虚拟存储器与Cache既有很多相同之处，又有很多不同之处。  

# 1.相同之处  

1）最终目标都是为了提高系统性能，两者都有容量、速度、价格的梯度。2）都把数据划分为小信息块，并作为基本的交换单位，虚存系统的信息块更大3）都有地址映射、替换算法、更新策略等问题。4）都依据局部性原理应用“快速缓存”的思想，将活跃的数据放在相对高速的部件中。  

# 2.不同之处  

1）Cache主要解决系统速度，而虚拟存储器却是为了解决主存容量。  

2）Cache全由硬件实现，是硬件存储器，对所有程序员透明；而虚拟存储器由OS和硬件共同实现，是逻辑上的存储器，对系统程序员不透明，但对应用程序员透明。  

>#### pro：Cache缺失和缺页的处理开销对比（2016）  

3）对于不命中性能影响，因为CPU的速度约为Cache的10倍，主存的速度为硬盘的100倍以上，因此虚拟存储器系统不命中时对系统性能影响更大。  

4）CPU与Cache和主存都建立了直接访问的通路，而辅存与CPU没有直接通路。也就是说在Cache不命中时主存能和CPU直接通信，同时将数据调入Cache；而虚拟存储器系统不命中时，只能先由硬盘调入主存，而不能直接和CPU通信。  
 

08.【解答】  

1）数组a的起始地址为 $0042\,2000\mathrm{H}$ ，页大小为4KB，所以页内偏移量占12位，数组a共有 $24{\times}64=1536$ 个元素，每个int型数据占4字节，因此数组a共占 $1536\!\times\!4\mathrm{B}=6\mathrm{KB}$ ，故分布在2个相邻的页面中。页号分别为00422H和00423H，当访问这两个页面的第一个数组元素的地址时，因为页面尚未调入内存，所以会发生2次缺页异常，两个页故障地址分别是00422000H和 $0042\,3000\mathrm{H}$  

2）若不考虑变量i和j，该程序段的数据访问只涉及对数组元素的访问，由于每个数组元素只访问一次，因此该程序段的数据访问没有时间局部性。  

3）在组相联映射方式下，物理地址结构为Tag标记 $^+$ Cache组号 $^+$ 块内地址，主存块大小为32B，故块内地址占5位；Cache数据区共有 $\mathrm{8KB^{\cdot}\!32B=\!256}$ 行，采用4路组相联，共有64组，故Cache组号占6位，因此虚拟地址中低5位（ $\mathrm{A4\!\sim\!A0})$ ）用作块内地址：低11位虚拟地址中高6位 $(\mathrm{A}10{\sim}\mathrm{A}5)$ 用作Cache组号。a[1][o]的虚拟地址为 $0042\ 2000\mathrm{H}+$  $1{\times}64{\times}4\ +\ 0{\times}4\ =0042\ 2100\mathrm{H}$ 。虚拟地址为32位，页框大小为4KB，虚拟地址的低12位表示页内偏移量，因此物理地址的低12位和虚拟地址的低12位相同，因此a[1]I0]所在主存块对应的Cache组号为 $001000\mathbf{B}=8$  

4）数组a占  $24{\times}64{\times}4\mathrm{B}{\div}32\mathrm{B}=192$  个主存块。每个主存块存放  $32\mathrm{B}{\cdot}4\mathrm{B}=8$  个数组元素，访问 数组a的Cache命中率为 $(8-1)/8=87.5\%\,8$ 行数组元素占 $8{\times}64{\times}4\mathrm{B}{\div}32\mathrm{B}=64$ 个主存块，分别映射到64个Cache组的某Cache行，数组a共有24行，因此每个Cache组中只有 $24/8=3$ 个Cache行存放数组a中的数据，而每个Cache组有4行，因而不会发生替换，访问数组a的Cache命中率为 $7/8=87.5\%$  

# 3.7 本章小结  

本章开头提出的问题的参考答案如下。  

1）存储器系统为何要分这些层次？计算机如何管理这些层次？  

Cache-主存层在存储系统中主要对CPU访存起加速作用，即从整体运行的效果看，CPU访存速度加快，接近于Cache的速度，而寻址空间和位价却接近于主存。主存-辅存层在存储系统中主要起扩容作用，即从程序员的角度看，他所使用的存储器的容量和位价接近于辅存，而速度接近于主存。因此从整个存储系统来看，就达到了速度快、容量大、位价低的效果。  

主存与Cache之间的信息调度全部由硬件自动完成。而主存与辅存的信息调度则采用虚拟存储技术实现，即将主存与辅存的一部分通过软/硬结合的技术组成虚拟存储器，程序员可用这个比主存实际空间（物理地址空间）大得多的虚拟地址空间（逻辑地址空间）编程，当程序运行时，再由软/硬件自动配合完成虚拟地址空间与主存实际物理空间的转换。  

2.影响Cache性能的因素有哪些？  

决定Cache系统访存效率重要因素是命中率，它与很多因素有关。1）命中率与映射方式有关，全相联映射方式的命中率最高，直接映射方式的命中率最低。2）命中率与Cache容量有关，显然Cache容量越大，命中率就越高。3）命中率还与主存块（或Cache行）的大小有关，主存块的大小要适中。  
除上述因素外，系统是采用单级还是采用多级Cache，数据Cache和指令Cache是分离还是合在一起，主存-总线-Cache-CPU之间采用什么架构等，都会影响Cache的总体性能。  

3）虚拟存储系统的页面是设置得大一些好还是设置得小一些好？  

页面大小要适中。页面太小时，平均页内剩余空间较小，可节省存储空间，但会使得页表增大，页面太小时也不能充分利用空间局部性来提高命中率：页面太大时，可减少页表空间，但平均页内剩余空间较大，会浪费较多存储空间，页面太大还会使页面调入/调出的时间较长。  

# 3.8常见问题和易混淆知识点  

1.Cache行的大小和命中率之间有什么关系？  

Cache行的长度较大时，能充分利用程序访问的空间局部性，使一个较大的局部空间被一起调到Cache中，因而可以增加命中机会。但是，行长也不能太大，主要原因有两个：  

1）行长大使失效损失变大。也就是说，若未命中，则需花更多时间从主存读块。  

2）行长太大，Cache项数变少，因而命中的可能性变小。  

Cache行的长度较小时，命中率会很低，但好处是存取块的代价较小。  

2.发生取指令Cache缺失的处理过程是什么？  

1）程序计数器恢复当前指令的值。  

2）对主存进行读的操作。  

3）将读入的指令写入Cache中，更改有效位和标记位。  

4）重新执行当前指令。  

3.Cache总容量与映射方式有何种关系？  

Cache总容量 $=$ [每个Cache行标记项的容量（有效位、脏位、LRU替换位、标记位）+Cache行长xCache总行数。其中，有效位和标记位是所有Cache所必需的；脏位只在Cache采用回写法时才需要设置；LRU替换位只在Cache采用LRU替换算法时才需要设置。  

有效位：占1位，用于说明Cache行中的数据是否有效。脏位（修改位）：占1位，回写法才需要设置，用以说明Cache行中的数据是否被修改过。LRU替换位：位数为 $\log_{2}($ 组内块数），用于LRU替换算法中的访问计数。  

标记位Tag：主存地址结构中的标记字段，其位数取决于所用的映射方式，用于匹配Cache行对应主存中的哪个块。  

Cache容量与映射方式的具体关系如图3.30所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/77d74c7bc0a8fc408aa68057edb2cbdd1c424abbf65fd57e9f4d982659723d0b.jpg)  
# 第4章指令系统  

# 【考纲内容】  

（一）指令格式的基本概念（二）指令格式（三）寻址方式（四）数据的对齐和大/小端存放方式（五）CISC和RISC的基本概念（六）高级语言程序与机器级代码之间的对应编译器、汇编器与链接器的基本概念：选择结构语句的机器级表示循环结构语句的机器级表示：过程（函数）调用对应的机器级表示  

# 【复习提示】  

指令系统是表征一台计算机性能的重要因素。应掌握各种寻址方式的特点及有效地址的计算，三种偏移寻址（相对寻址、基址寻址和变寻址）的计算，CISC与RISC的特点与区别。2022年大纲新增机器级表示，机器级代码相关的题型曾在历年统考中多次考查，要能读懂代码。本章知识点既可能出选择题，又可能结合其他章节出有关指令的综合题。指令格式、机器指令和指令寻址方式与CPU指令执行过程部分紧密相关，需引起重视。  

在学习本章时，请读者思考以下问题  

1）什么是指令？什么是指令系统？为什么要引入指令系统？2）一般来说，指令分为哪些部分？每部分有什么用处？3）对于一个指令系统来说，寻址方式多和少有什么影响？请读者在本章的学习过程中寻找答案，本章末尾会给出参考答案。  

# 4.1指令系统  

# 4.1.1指令集体系结构  

>#### pro：指令集体系结构（ISA）规定的内容（2022）  

机器指令（简称指令）是指示计算机执行某种操作的命令。一台计算机的所有指令的集合构成该机的指令系统，也称指令集。指令系统是指令集体系结构（ISA）中最核心的部分，ISA完整定义了软件和硬件之间的接口，是机器语言或汇编语言程序员所应熟悉的。  
ISA规定的内容主要包括：  

1）指令格式，指令寻址方式，操作类型，以及每种操作对应的操作数的相应规定。  

2）操作数的类型，操作数寻址方式，以及是按大端方式还是按小端方式存放。  

3）程序可访问的寄存器编号、个数和位数，存储空间的大小和编址方式。  

4）指令执行过程的控制方式等，包括程序计数器、条件码定义等  

ISA规定了机器级程序的格式，机器语言或汇编语言程序员必须对机器的ISA非常熟悉。不过，大多数程序员不会用汇编语言或机器语言编写程序，通常用高级语言（如 $\mathrm{C}/\mathrm{C++}/\mathrm{Java}$ )广编写程序，这样开发效率更高，也不易出错。但是，高级语言抽象层太高，隐藏了许多机器级程序的细节，使得高级语言程序员不能很好地利用与机器结构相关的一些优化方法来提升程序的性能。若程序员对ISA和底层硬件实现细节有充分的了解，则可以更好地编制高性能程序。  

# 4.1.2指令的基本格式  

一条指令就是机器语言的一个语句，它是一组有意义的二进制代码。一条指令通常包括操作码字段和地址码字段两部分：  

操作码字段地址码字段  

其中，操作码指出该指令应执行什么操作以及具有何种功能。操作码是识别指令、了解指令功能及区分操作数地址内容等的关键信息。例如，指出是算术加运算还是算术减运算，是程序转移还是返回操作。地址码给出被操作的信息（指令或数据）的地址，包括参加运算的一个或多个操作数的地址、运算结果的保存地址、程序的转移地址、被调用子程序的入口地址等。  

指令字长是指一条指令所包含的二进制代码的位数，其取决于操作码的长度、地址码的长度和地址码的个数。指令字长与机器字长没有固定的关系，它既可以等于机器字长，又可以大于或小于机器字长。通常，把指令长度等于机器字长的指令称为单学长指令，指令长度等于半个机器字长的指令称为半字长指令，指令长度等于两个机器字长的指令称为双字长指令。  

# 注意  

指令长度的不同会导致取指令时间开销的不同，单字长指令只需访存1次就能将指令完整取出；而双字长指令则需访存2次才能完整取出，耗费2个存取周期。  

在一个指令系统中，若所有指令的长度都是相等的，则称为定长指令字结构。定字长指令的执行速度快，控制简单。若各种指令的长度随指令功能而异，则称为变长指令字结构。然而，因为主存一般是按字节编址的，所以指令字长通常为字节的整数倍。  

根据指令中操作数地址码的数目的不同，可将指令分成以下几种格式。>#### pro：根据指令格式及相关编码条件组合成机器代码（2015）  

# 1.零地址指令  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6e7552f06b4d8317fc022359d2dcccb811aec4c3314eb4cd1ac1ec714e795bd3.jpg)  

只给出操作码OP，没有显式地址。这种指令有两种可能：1）不需要操作数的指令，如空操作指令、停机指令、关中断指令等。  

2）零地址的运算类指令仅用在堆栈计算机中。通常参与运算的两个操作数隐含地从栈顶和次栈顶弹出，送到运算器进行运算，运算结果再隐含地压入堆栈。  
2.一地址指令  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f73beb07fd477d00ecf244bb03d345248115ffa6dad3968d55fb69658646a4ca.jpg)  

这种指令也有两种常见的形态，要根据操作码的含义确定究竟是哪一种。  

1）只有目的操作数的单操作数指令，按 $\mathrm{A_{1}}$ 地址读取操作数，进行OP操作后，结果存回原地址。  

指令含义： $\mathrm{OP(A_{1}){\rightarrow}A_{1}}$  

如操作码含义是加1、减1、求反、求补、移位等。  

2）隐含约定目的地址的双操作数指令，按指令地址  $\mathrm{A_{1}}$  可读取源操作数，指令可隐含约定另 一个操作数由ACC（累加器）提供，运算结果也将存放在ACC中。指令含义： $(\mathrm{ACC})\mathrm{OP}(\mathrm{A}_{1}){\rightarrow}\mathrm{ACC}$  

>#### pro：地址位数与寻址范围的关系（2010、2021）  

若指令字长为32位，操作码占8位，1个地址码字段占24位，则指令操作数的直接寻址范围为 $2^{24}\,=\,16\mathrm{M}$ 。若地址码字段均为主存地址，则完成一条一地址指令需要3次访存（取指令1次，取操作数1次，存结果1次）。  

3.二地址指令  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/808143d9dc4a64a19f32b18f99d45ecad816da4b5a2564cee34b907da02c8e67.jpg)  

指令含义： $(\mathrm{A}_{1})\mathrm{OP}(\mathrm{A}_{2}){\rightarrow}\mathrm{A}_{1}$  

对于常用的算术和逻辑运算指令，往往要求使用两个操作数，需分别给出目的操作数和源操作数的地址，其中目的操作数地址还用于保存本次的运算结果。  

若指令字长为32位，操作码占8位，两个地址码字段各占12位，则每个操作数的直接寻址范围为 $2^{12}\,=\,4\mathrm{K}$ 。若地址码字段均为主存地址，则完成一条二地址指令需要4次访存（取指令1次，取两个操作数2次，存结果1次）。  

4.三地址指令  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/964f896e4265099daa90e4a7313c3f27dbada8cdcabb04ced0efe9b9d5d4944a.jpg)  

指令含义： $\mathrm{(A_{1})O P(A_{2})}{\rightarrow}\mathrm{A}_{3}\,.$  

若指令字长为32位，操作码占8位，3个地址码字段各占8位，则每个操作数的直接寻址范 围为 $2^{8}\,=\,256$ 。若地址码字段均为主存地址，则完成一条三地址需要4次访问存储器（取指令1次，取两个操作数2次，存结果1次）。  

5.四地址指令  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/56bca1a6922d69a95d02641971447a3f6f573122ef2321a9000c316913151d9c.jpg)  

指令含义： $(\mathrm{A}_{1})\mathrm{OP}(\mathrm{A}_{2}){\rightarrow}\mathrm{A}_{3}$  $\mathrm{A}_{4}\,{=}$ 下一条将要执行指令的地址。  

若指令字长为32位，操作码占8位，4个地址码字段各占6位，则每个操作数的直接寻址范 围为 $2^{6}\!=\!64$ 。若地址码字段均为主存地址，则完成一条四地址指令需要4次访存（取指令1次）取两个操作数2次，存结果1次）。  

# 4.1.3定长操作码指令格式  

>#### pro：定长操作码的指令条数（2015）  

定长操作码指令在指令字的最高位部分分配固定的若干位（定长）表示操作码。一般 $n$ 位操作码字段的指令系统最大能够表示 $2^{n}$ 条指令。定长操作码对于简化计算机硬件设计，提高指令译码和识别速度很有利。当计算机字长为32位或更长时，这是常规用法。  
# 4.1.4扩展操作码指令格式  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/071560d5e5eda10464fba863c6dfebfd51fa6d763bb74f898427072c733063e7.jpg)  

扩展操作码的设计与分析（2017、2021、2022）  

为了在指令字长有限的前提下仍保持比较丰富的指令种类，可采取可变长度操作码，即全部指令的操作码字段的位数不固定，且分散地放在指令字的不同位置上。显然，这将增加指令译码和分析的难度，使控制器的设计复杂化。最常见的变长操作码方法是扩展操作码，它使操作码的长度随地址码的减少而增加，不同地址数的指令可具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长。图4.1所示即为一种扩展操作码的安排方式。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b10a369778010289fef7ffaa5f77b8dcc6e481322d548dc450d59062bbc00886.jpg)  
操作码的位数随地址数的减少而增加  

在图4.1中，指令字长为16位，其中4位为基本操作码字段0P，另有3个4位长的地址字段 $\mathrm{A_{1}}$  $\mathrm{A}_{2}$ 和 $\mathrm{A}_{3}$ 。4位基本操作码若全部用于三地址指令，则有16条。图4.1中所示的三地址指令为15条，1111留作扩展操作码之用：二地址指令为15条，11111111留作扩展操作码之用；一地址指令为15条，111111111111留作扩展操作码之用；零地址指令为16条。×  

除这种安排外，还有其他多种扩展方法，如形成15条三地址指令、12条二地址指令、63条一地址指令和16条零地址指令，共106条指令，请读者自行分析。  

在设计扩展操作码指令格式时，必须注意以下两点：  

1）不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分的代码相同，  

2）各指令的操作码一定不能重复。  

通常情况下，对使用频率较高的指令分配较短的操作码，对使用频率较低的指令分配较长的操作码，从而尽可能减少指令译码和分析的时间。  

# 4.1.5指令的操作类型  

设计指令系统时必须考虑应提供哪些操作类型，指令操作类型按功能可分为以下几种。  

1.数据传送  

传送指令通常有寄存器之间的传送（MOV）、从内存单元读取数据到CPU寄存器（LOAD）  
从CPU寄存器写数据到内存单元（STORE）、进栈操作（PUSH）、出栈操作（POP）等。  

# 2.算术和逻辑运算  

这类指令主要有加（ADD）、减（SUB）、乘（MUL）、除（DIV）、加1（INC）、减1（DEC）、与（AND）、或（OR）、取反（NOT）、异或（XOR）等。  

# 3.移位操作  

移位指令主要有算术移位、逻辑移位、循环移位等。  

# 4.转移操作  

>#### pro：转跳指令、调用和返回指令、条件转移指令的区分（2019）  

转移指令主要有无条件转移（JMP）、条件转移（BRANCH）、调用（CALL）、返回（RET）、陷阶（TRAP）等。无条件转移指令在任何情况下都执行转移操作，而条件转移指令仅在特定条件满足时才执行转移操作，转移条件一般是某个标志位的值，或几个标志位的组合。  

调用指令和转移指令的区别：执行调用指令时必须保存下一条指令的地址（返回地址），当子程序执行结束时，根据返回地址返回到主程序继续执行：而转移指令则不返回执行。  

# 5.输入输出操作  

这类指令用于完成CPU与外部设备交换数据或传送控制命令及状态信息。  
 
  

# 4.2指令的寻址方式  

寻址方式是指寻找指令或操作数有效地址的方式，即确定本条指令的数据地址及下一条待执行指令的地址的方法。寻址方式分为指令寻址和数据寻址两大类。  

# 4.2.1指令寻址和数据寻址  

寻找下一条将要执行的指令地址称为指令寻址：寻找本条指令的数据地址称为数据寻址。  

1.指令寻址  

指令寻址方式有两种：一种是顺序导址方式，另一种是跳跃寻址方式。  

（1）顺序寻址  

通过程序计数器PC加1（1条指令的长度），自动形成下一条指令的地址  

>#### pro：PC自增大小与编址方式、指令字长的关系（2013、2014、2019、2023）  

# 注意  

PC自增的大小与编址方式、指令字长有关。现代计算机通常是按字节编址的，若指令字长为16位，则PC自增为 $(\mathrm{PC})+2$ ；若指令字长为32位，则PC自增为 $(\mathrm{PC})+4,$  

# （2）跳跃寻址  

通过转移类指令实现。跳跃是指由本条指令给出下条指令地址的计算方式。而是否跳跌可能受到状态寄存器的控制，跳跃的方式分为绝对转移（地址码直接指出转移自标地址）和箱对转移（地址码指出转移目的地址相对于当前PC值的偏移量），由于CPU总是根据PC的内容去主存取指令的，因此转移指令执行的结果是修改PC值，下一条指令仍然通过PC给出。  

# 2.数据寻址  

>#### pro：指令格式中各字段的位数分析（2020）  

数据寻址是指如何在指令中表示一个操作数的地址，或怎样计算出操作数的地址。数据寻址的方式较多，为区别各种方式，通常在指令字中设置一个寻址特征字段，用来指明属于哪种寻址方式（其位数决定了寻址方式的种类），由此可得指令的格式如下所示：  

>#### pro：指令格式中寻址特征字段的作用（2023）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/cc57f57875406369a446ee41b6e46ac9b01777329de41e632ddfab7ec83264fd.jpg)  

指令中的地址码字段并不代表操作数的真实地址，这种地址称为形式地址（A）。形式地址结合寻址方式，可以计算出操作数在存储器中的真实地址，这种地址称为有效地址（EA）。  
·若为立即寻址，则形式地址的位数决定了操作数的范围！·若为直接寻址，则形式地址的位数决定了可寻址的范围。·若为寄存器寻址，则形式地址的位数决定了通用寄存器的最大数量。·若为寄存器间接寻址，则寄存器的位数决定了可寻址的范围。  

# 注意  

（A）表示地址为A的数值，A既可以是寄存器编号，又可以是内存地址。  

# 4.2.2常见的数据寻址方式  

# 1.隐含寻址  

这种类型的指令不明显地给出操作数的地址，而是隐含操作数的地址。例如，单地址的指令格式就隐含约定第二个操作数由累加器（ACC）提供，指令中只明显指出第一个操作数的地址。因此，累加器（ACC）对单地址指令格式来说是隐含寻址，如图4.2所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/eb95a905f61e44cad56b518a1aa375ef438a60ca7ed3fc676e2fa55c6f573d41.jpg)  
图4.2隐含寻址  

优点是有利于缩短指令字长：缺点是需增加存储操作数或隐含地址的硬件。  

# 2.立即（数）寻址  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/110d116c8b8f204cc811f75888fc2be6eb59e94bed8f4be454cefdd61d820bbe.jpg)  

指令字中的地址字段指出的不是操作数的地址，而是操作数本身，也称立即数，采用补码表示。图43所亲为立即寻址示意图，图中#表示立即寻址特征，A就是操作数。  

优点是指令在执行阶段不访存，指令执行速度最快；缺点是A的位数限制了立即数的范围。  

# 3.直接寻址  

指令字中的形式地址A就是操作数的真实地址EA，即EA $\mathbf{\tau}=\mathbf{A}$ ，如图4.4所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/948183c5b772d6544c6bec9a19645480a2b25ccbad62d507552486df04009957.jpg)  

优点是简单，不需要专门计算操作数的地址，指令在执行阶段仅需访存一次；缺点是A的位数限制了该指令操作数的寻址范围，操作数的地址不易修改。  

# 4.间接寻址  

间接寻址是相对于直接寻址而言的，指令的地址字段给出的不是操作数的真正地址，而是操作数有效地址所在主存单元的地址，也就是操作数地址的地址，即 $\mathrm{EA}=(\mathrm{A})$ ，如图4.5所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/297661d0b53d517f5369db6eeea0399b48288d259fb0194ce89d2cff392ca596.jpg)  
图4.5间接寻址  

优点是可扩大寻址范围（有效地址EA的位数大于形式地址A的位数），便于编制程序（用间接寻址可方便地完成子程序返回）：缺点是指令在执行阶段要多次访存（一次间接寻址需2次访存）。由于执行速度较慢，一般为了扩大寻址范围时，通常采用寄存器间接寻址。  

# 5.寄存器寻址  

与直接寻址的原理一样，只是把访问主存改为访问寄存器，指令的地址字段给出的是操作数所在寄存器的编号，即 $\mathrm{EA}=\mathrm{R}_{i}$ ，其操作数在由 $\mathbf{R}_{i}$ 所指的寄存器内，如图4.6所示。  

>#### pro：寄存器编号位数与寄存器数量的关系（2022）  

优点是指令在执行阶段不用访存，只访问寄存器，执行速度快；寄存器数量远小于内存单元数，所以地址码位数较少，指令字长较短；缺点是寄存器价格昂贵，CPU的寄存器数量有限。  

# 6.寄存器间接寻址  

>#### pro：寄存器间接寻址的取数操作（2010）  

这种方式综合了间接寻址和寄存器寻址各自的特点，指令字中的 $\mathbf{R}_{i}$ 所指寄存器给出的不是一个操作数，而是操作数所在主存单元的地址，即 $\mathrm{EA}=(\mathrm{R}_{i})$ ，如图4.7所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/92cc364b37cca2cace4edc484a7917ca840b456ec8c78df2714108a04df0e6ef.jpg)  
图4.6寄存器寻址  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/71cf46d10de7a2353718ca3f208d5dd43920b00188d4ad2d26638c7036ec9415.jpg)  
图4.7寄存器间接寻址  

相比间接寻址，这种方式既扩大了寻址范围，又减少了访存次数，在执行阶段仅需访存1次。相比寄存器寻址，这种方式在执行阶段需要访存（因操作数在主存中）获得操作数。  

# 7.相对寻址  

>#### pro：相对寻址的偏移量或目标地址的计算（2009、2013、2014、2019、2023）  

相对寻址是把PC的内容加上指令格式中的形式地址A而形成操作数的有效地址，即EA $=$ PC) $\mathbf{\varepsilon}+\mathbf{A}$ ，其中A是相对于当前PC值的偏移量，可正可负，补码表示，如图4.8所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/54a79a897f2ebe46f3c3320ba9fc90c8d14eba5a2917c433c88919cf0d1c4e2d.jpg)  
图4.8相对寻址  

在图4.8中，A的位数决定操作数的寻址范围。  

优点是操作数的地址不是固定的，它随PC值的变化而变化，且与指令地址之间总是相差一个固定的偏移量，因此便于程序浮动。相对寻址广泛应用于转移指令。  

>#### pro：相对寻址转跳范围的计算（2010、2013、2014）  

# 注意  

对于转移指令JMPA，若指令的地址为X，且占2B，则在取出该指令后，PC的值会增2，即 $(\mathrm{PC})\,{=}\,\mathrm{X}+2$ ，这样在执行完该指令后，会自动跳转到 $\mathrm{X}+2+\mathrm{A}$ 的地址继续执行。  

8.基址寻址  

>#### pro：基址寻址的EA的计算（2019）  

基址寻址是指将基址寄存器（BR）的内容加上指令字中的形式地址A而形成操作数的有效地址，即 $\mathrm{EA}=(\mathrm{BR})+\mathrm{A}_{\circ}$ 其中基址寄存器既可采用专用寄存器，又可指定某个通用寄存器作为基址寄存器，如图4.9所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a34564d3543b6f2ccacb8cfb471b140348d32097e27bbf6b321ab8f9a9a2be06.jpg)  
图4.9基址寻址  

基址寄存器是面向操作系统的，其内容由操作系统或管理程序确定，主要用于解决程序逻辑空间与存储器物理空间的无关性。在程序执行过程中，基址寄存器的内容不变（作为基地址），形式地址可变（作为偏移量）。采用通用寄存器作为基址寄存器时，可由用户决定哪个寄存器作为基址寄存器，但其内容仍由操作系统确定。  

基址寻址的优点是可以扩大寻址范围（基址寄存器的位数大于形式地址A的位数）：用户不必考虑自己的程序存于主存的具体位置，因此有利于多道程序设计，并可用于编制浮动程序，但偏移量（形式地址A）的位数较短。  

9.变址寻址  

>#### pro：变址寻址的EA的计算（2013），先变址后间址方式的EA的计算（2016）  

变址寻址是指将变址寄存器（IX）的内容加上指令字中的形式地址A而形成操作数的有效地址，即 $\mathrm{EA}\,{=}\,(\mathrm{IC})+\mathrm{A}$ ，其中IX为变址寄存器（专用），也可用通用寄存器作为变址寄存器。图4.10所示为采用专用寄存器IX的变址寻址示意图。  
变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变（作为偏移量），形式地址A不变（作为基地址）。  

>#### pro：变址寻址的适用场景（2017）  

变址寻址的优点是可扩大寻址范围（变址寄存器的位数大于形式地址A的位数）：在数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器IX的内容，便可很容易形成数组中任意一个数据的地址，特别适合编制循环程序。偏移量（变址寄存器IX）的位数足以表示整个存储空间。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9f0e1bf068edf0a515fc2ed92442f6f857a8030bab1164982e17c514ba92116c.jpg)  
图4.10变址寻址  

>#### pro：变址寻址访问数组的过程（2018）  

显然，变址寻址与基址寻址的有效地址形成过程极为相似。但从本质上讲，两者有较大区别。基址寻址面向系统，主要用于为多道程序或数据分配存储空间，因此基址寄存器的内容通常由操作系统或管理程序确定，在程序的执行过程中其值不可变，而指令字中的A是可变的。变址寻址立足于用户，主要用于处理数组问题，在变址寻址中，变址寄存器的内容由用户设定，在程序执行过程中其值可变，而指令字中的A是不可变的。  

>#### pro：偏移寻址的范畴（2011）  

相对寻址、基址寻址和变址寻址三种寻址方式非常类似，都将某个寄存器的内容与一个形式地址相加而生成操作数的有效地址，通常把这三种寻址方式称为偏移寻址。  

# 10.堆栈寻址  

堆栈是存储器（或寄存器组）中一块特定的、按后进先出（LIFO）原则管理的存储区，该存储区中读/写单元的地址是用一个特定寄存器给出的，该寄存器称为堆栈指针（SP）。堆栈可分为硬堆栈和软堆栈两种。寄存器堆栈也称硬堆栈，硬堆栈的成本较高，不适合做大容量的堆栈。而从主存中划出一段区域来做堆栈是最合算且最常用的方法，这种堆栈称为软堆栈。  

在采用堆栈结构的计算机中，大部分指令表面上都表现为无操作数指令的形式，因为操作数地址都隐含使用了SP。因此在读/写堆栈的前后都伴有自动完成对SP的加减操作。  

下面简单总结寻址方式、有效地址及访存次数（不含取本条指令的访存），见表4.1。  

表4.1寻址方式、有效地址及访存次数
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c51f3e89ddc451b47a9e622c8b801b80139caf0bb46af25e8b2187d5cd2dfd58.jpg)  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e1c50194cc3786f302b53c78b63af2b45a119ca8380862b67f5dcabb0710cde4.jpg)  

  

# 4.3程序的机器级代码表示  

>#### pro：涉及过汇编代码的真题的年份（2012、2014、2015、2017、2019、2023）  

本节是2022年才新增的考点，但历年统考真题曾多次以综合题的形式考查过，难度较大，不少跨考生对此无从下手，相信通过本节的学习后，应能从容应对。统考大纲没有指定具体指令集，但历年统考真题主要考查的是x86汇编指令，因此本节主要介绍x86汇编指令。  
# 4.3.1 常用汇编指令介绍  

# 1.相关寄存器  

x86处理器中有8个32位的通用寄存器，各寄存器及说明如图4.11所示。为了向后兼容，EAX、EBX、ECX和EDX的高两位字节和低两位字节可以独立使用，E表示Extended，表示32位的寄存器。例如，EAX的低两位字节称为AX，而AX的高低字节又可分别作为两个8位寄存器，分别称为AH和AL。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/16098179b12ef23c80f73188e819d11bf3ea18af269656a719130684f2a6f922.jpg)  
图4.11x86处理器中的主要寄存器及说明  

除EBP和ESP外，其他几个寄存器的用法是比较灵活的。  

# 2.汇编指令格式  

使用不同的编程工具开发程序时，用到的汇编程序也不同，一般有两种不同的汇编格式：AT&T格式和Intel格式（统考要求掌握的是Intel格式）。它们的区别主要体现如下：  

$\textcircled{\scriptsize{1}}$ AT&T格式的指令只能用小写字母，而Intel格式的指令对大小写不敏感。  

$\circledcirc$ 在AT&T格式中，第一个为源操作数，第二个为目的操作数，方向从左到右，合乎自然：在Intel格式中，第一个为目的操作数，第二个为源操作数，方向从右向左。  

$\textcircled{3}$ 在AT&T格式中，寄存器需要加前缀 $\omega_{0}$ ”，立即数需要加前缀“ $\S$ "；在Intel格式中，寄存器和立即数都不需要加前缀。  

$\textcircled{4}$ 在内存寻址方面，AT&T格式使用“（”和“)"，而Intel格式使用“[”和“]"。  

$\circledast$ 在处理复杂寻址方式时，例如AT&T格式的内存操作数“disp(base,index,scale)”分别表示偏移量、基址寄存器、变址寄存器和比例因子，如“8(%edx,%eax,2)”表示操作数为 $\mathrm{M}[\mathrm{R}[\mathrm{edx}]+\mathrm{R}[\mathrm{eax}]^{*}2+8]$ ，其对应的Intel格式的操作数为‘ $^{*}[\mathrm{edx+ex}^{*}2+8]$  

$\circledcirc$ 在指定数据长度方面，AT&T格式指令操作码的后面紧跟一个字符，表明操作数大小，“b”表示byte（字节）、“w”表示word（字）或“1”表示long（双字）。Intel格式也有类似的语法，byte ptr、word ptr d word ptr。  

# 注意  

由于32或64位体系结构都是由16位扩展而来的，因此用word（字）表示16位。  

表4.2展示了两种格式的几条不同指令。其中，mov指令用于在内存和寄存器之间或者寄存器之间移动数据；lea指令用于将一个内存地址（而不是其所指的内容）加载到目的寄存器。  
表4.2AT&T格式指令和Imtel格式指令的对比
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/49dd1199e96b48c53ff69b24837136b50fa7439742b0d9afe5606d78dc87dc74.jpg)  
注：R[表示寄存器r的内容，M[addr]表示主存单元addr的内容，→或 $\leftarrow$ 表示信息传送方向。  

两种汇编格式的相互转换并不复杂，但历年统考真题采用的均是Intel格式。  

# 3.常用指令  

汇编指令通常可分为数据传送指令、算术和逻辑运算指令和控制流指令，下面以Intel格式为例，介绍一些常用的指令。以下用于操作数的标记分别表示寄存器、内存和常数。  

<reg>：表示任意寄存器，若其后带有数字，则指定其位数，如<reg32>表示32位寄存器（eaxebx,ecx,edx,esi,edi,esp或ebp）;；<reg16>表示16位寄存器（ax,bx，cx或dx）;<reg8>表示8位寄存器（ah,al,bh,bl,ch,cl,dh,dl）。  

<mem>:表示内存地址（如[eax]、[var $^+$ 4]或dwordptr[eax $^+$ ebx])  

<con>：表示8位、16位或32位常数。<con8>表示8位常数；<con16 $>$ 表示16位常数；<con32>表示32位常数。  

>#### pro：分析汇编指令对应的二进制代码（2010）  

$\mathrm{x86}$ 中的指令机器码长度为1字节，对同一指令的不同用途有多种编码方式，比如mov指令就有28种机内编码，用于不同操作数类型或用于特定寄存器，例如，  

movax,<conl6> #机器码为B8H moval,<con8> #机器码为BOH mov <reg16>,<reg16>/<mem16> #机器码为89H mov<reg8>/<mem8>,<reg8> #机器码为8AH mov<reg16>/<mem16>,<reg16> #机器码为8BH  

>#### pro：模仿写出简单语句的机器级指令（2012）  

（1）数据传送指令  

1）mov指令。将第二个操作数（寄存器的内容、内存中的内容或常数值）复制到第一个操作数（寄存器或内存）。  

其语法如下：  

mov<reg>,<reg> mov<reg>,<mem> mov <mem>,<reg> mov<reg>,<con> mov<mem>，<con>  

举例：  

moveax,ebx #eb x ea x mov byteptr[var],5#将5保存到var值指示的内存地址的一字节中  

双操作数指令的两个操作数不能都是内存，即mov指令不能用于直接从内存复制到内存，若需在内存之间复制，可先从内存复制到一个寄存器，再从这个寄存器复制到内存  
2）push指令。将操作数压入内存的栈，常用于函数调用。ESP是栈顶，入栈前先将ESP值减4（栈增长方向与内存地址增长方向相反），然后将操作数压入ESP指示的地址。  

其语法如下：  

push <reg32> push <mem> push <con32>  

举例（注意，栈中元素固定为32位）  

pusheax #将eax值入栈 push[var] #将var值指示的内存地址的4字节值入栈  

3）pop指令。与push指令相反，pop指令执行的是出栈工作，出栈前先将ESP指示的地址中的内容出栈，然后将ESP值加4。  

其语法如下：  

popeax #弹出栈顶元素送到eax pop[ebx]#弹出栈顶元素送到ebx值指示的内存地址的4字节中  

（2）算术和逻辑运算指令  

1）add/sub指令。add指令将两个操作数相加，相加的结果保存到第一个操作数中。sub指令用于两个操作数相减，相减的结果保存到第一个操作数中。  

它们的语法如下：  

add<reg>，<reg>/sub<reg>，<reg> add<reg>,<mem>/sub <reg>,<mem> add<mem>,<reg>/sub<mem>,<reg> add<reg>,<con>/sub <reg>，<con> add<mem>，<con>/sub<mem>，<con>  

举例：  

subeax,10 #eax-eax-10 addbyte ptr [var],10#10与var值指示的内存地址的一字节值相加，并将结果#保存在var值指示的内存地址的字节中  

2）inc/dec指令。inc、dec指令分别表示将操作数自加1、自减1。  

它们的语法如下：  

inc <reg>/dec<reg> inc<mem>/dec <mem> 举例：deceax #eax值自减1 inc dword ptr [var] #var值指示的内存地址的4字节值自加1  

3）imul指令。有符号整数乘法指令，有两种格式： $\textcircled{\scriptsize{1}}$ 两个操作数，将两个操作数相乘，将结果保存在第一个操作数中，第一个操作数必须为寄存器： $\circledcirc$ 三个操作数，将第二个和第三个操作数相乘，将结果保存在第一个操作数中，第一个操作数必须为寄存器。  

其语法如下：  

imul <reg32>,<reg32> imul <reg32>,<mem> imul<reg32>,<reg32>,<con> imul <reg32>,<mem>,<con>  

举例：  

imul eax,[var] #eax  $\leftarrow$  eax\*[var] imul esi,edi,25 #esi  $\leftarrow$  edi  $\star~{}^{25}$  

乘法操作结果可能溢出，则编译器置溢出标志 $\mathrm{OF}=1$ ，以使CPU调出溢出异常处理程序。  
4）idiv指令。有符号整数除法指令，它只有一个操作数，即除数，而被除数则为edx:eax中的内容（共64位），操作结果有两部分：商和余数，商送到eax，余数则送到edx。  

其语法如下：  

idiv <reg32> idiv<mem>  

举例：idivebx idiv dword ptr [var]  

5）and/or/xor指令。and、or、xor指令分别是逻辑与、逻辑或、逻辑异或操作指令，用于操 作数的位操作，操作结果放在第一个操作数中。  

它们的语法如下：  

and<reg>，<reg>/or<reg>，<reg>/xor<reg>，<reg> and<reg>,<mem>/or<reg>,<mem>/xor<reg>,<mem> and <mem>,<reg>/or <mem>,<reg>/xor<mem>,<reg> and<reg>,<con>/or<reg>，<con>/xor<reg>，<con> and<mem>,<con>/or<mem>,<con>/xor<mem>,<con>  

举例：  

andeax,OfH#将eax中的前28位全部置为0，最后4位保持不变xoredx,edx#置edx中的内容为0  

6）not指令。位翻转指令，将操作数中的每一位翻转，即 $_{0\to1}$ 、1一0  

其语法如下：  

not <reg> not<mem>  

举例：  

notbyteptr[var]#将var值指示的内存地址的一字节的所有位翻转  

7）neg指令。取负指令。  

其语法如下：neg <reg> neg <mem>  

举例：  

8）shil/shr指令。逻辑移位指令，shl为逻辑左移，shr为逻辑右移，第一个操作数表示被操作数，第二个操作数指示移位的位数。  

它们的语法如下：  

sh1<reg>,<con8>/shr <reg>，<con8> shl<mem>,<con8>/shr <mem>,<con8> shl<reg>，<cl>/shr<reg>，<cl> shl<mem>,<cl>/shr<mem>，<c1>  

举例：  

shleax,1#将eax值左移1位shrebx,cl#将ebx值右移n位（n为cl中的值）  

（3）控制流指令  

$\mathrm{x86}$ 处理器维持着一个指示当前执行指令的指令指针（IP），当一条指令执行后，此指针自动指向下一条指令。IP寄存器不能直接操作，但可以用控制流指令更新。通常用标签（label）指示程序中的指令地址，在x86汇编代码中，可在任何指令前加入标签。例如，  

mov esi,[ebp+8] begin: xor ecx,ecx mov eax,[esi]  
这样就用begin指示了第二条指令，控制流指令通过标签就可以实现程序指令的跳转。  

>#### pro：无条件转移指令的指令格式（2021）  

1）jmp指令。jmp指令控制IP转移到label所指示的地址（从label中取出指令执行）。其语法如下：  

jmp<label>  

举例：jmpbegin#转跳到begin标记的指令执行  

>#### pro：条件转移指令与标志位的结合（2013）  

2）jcondition指令。条件转移指令，依据CPU状态字中的一系列条件状态转移。CPU状态字中包括指示最后一个算术运算结果是否为0，运算结果是否为负数等。  

其语法如下：  

je<label>(jump whenequal) jz<label>（jump when last result was zero） jne<label>(jump when not equal）jg<label>（jump when greater than) jge<label>(jump when greater than or equal to) jl <label>(jump when less than) ile<label> (iump when less than or equal to)  

举例：  

cmpeax,ebx jledone#若eax值 $<=$ ebx值，则跳转到done执行：否则执行下一条指令  

3）cmp/test指令。cmp指令的功能相当于sub指令，用于比较两个操作数的值。test指令的功能相当于and指令，对两个操作数进行逐位与运算。与sub和and指令不同的是，这两类指令都不保存操作结果，仅根据运算结果设置CPU状态字中的条件码。  

其语法如下：  

cmp<reg>，<reg>/test<reg>,<reg> cmp<reg>,<mem>/test<reg>,<mem> cmp <mem>,<reg>/test<mem>,<reg> cmp<reg>，<con>/test<reg>,<con>  

cmp test j condition，举例：  

c mpd word ptr [var],10#将var指示的主存地址的4字节内容，与10比较jneloop#若相等则继续顺序执行：否则跳转到1oop处执行testeax,eax #测试eax是否为零 jzxxxx#为零则置标志ZF为1，转跳到xxxx处执行  

>#### pro：call指令的功能（2019）  

4）call/ret指令。分别用于实现子程序（过程、函数等）的调用及返回。其语法如下：  

call <label> ret  

call指令首先将当前执行指令地址入栈，然后无条件转移到由标签指示的指令。与其他简单 的跳转指令不同，call指令保存调用之前的地址信息（当call指令结束后，返回调用之前的地址）。ret指令实现子程序的返回机制，ret指令弹出栈中保存的指令地址，然后无条件转移到保存的指 令地址执行。call和ret是程序（函数）调用中最关键的两条指令。  
理解上述指令的语法和用途，可以更好地帮助读者解答相关题型。读者在上机调试C程序代码时，也可以尝试用编译器调试，以使更好地帮助理解机器指令的执行。  

# 4.3.2选择语句的机器级表示  

常见的选择结构语句有if-then、if-then-else等。编译器通过条件码（标志位）设置指令和各类转移指令来实现程序中的选择结构语句。条件码描述了最近的算术或逻辑运算操作的属性，可以检测这些寄存器来执行条件分支指令，最常用的条件码有CF、ZF、SF和OF。  

常见的算术逻辑运算指令（add，sub,imul，or,and，shl,inc,dec,not,sal等）会设置条件码，还 有cmp和test指令只设置条件码而不改变任何其他寄存器。  

之前介绍的jcondiion条件转跳指令，就是根据条件码ZF和SF来实现转跳的。  

if-else语句的通用形式如下：  

if(testexpr) then statement else else statement  

这里的test_expr是一个整数表达式，它的取值为0（假），或为非0（真）。两个分支语句（then statement else statement）中只会执行一个。  

这种通用形式可以被翻译成如下所示的goto语句形式：  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/99de2ec0647f045fd562ae8b7c72c2a534fddb8bc8716ce24718f9784d401682.jpg)  

对于下面的C语言函数：  

int get cont（int\*pl,int  $\star_{\mathsf{P}2}$  if(p1>p2) return\*p2; else return\*pl;  

已知p1和p2对应的实参已被压入调用函数的栈帧，它们对应的存储地址分别为 ${\mathrm{R}}[{\mathrm{ebp}}]+8$ R[ebp]+12（EBP指向当前栈帧底部），返回结果存放在EAX中。对应的汇编代码为  

mov eax,dword ptr [ebp+8] mov edx,dword ptr [ebp+12] cmp eax,edx jbe .L1 mov eax,dword ptr [edx] jmp .L2 .L1: mov eax,dword ptr [eax] .L2:  

#R[eax]-M[R[ebp]+8],即R[eax]  $\tt=p1$  #R[edx]M[R[ebp]+12],即R[edx]  $\tt=p2$  #比较p1和p2，即根据p1-p2的结果置标志

#若 $\mathtt{p1<=p2}$ ，则转标记L1处执行

#R[eax]-M[R[edx]],即R[eax]  $\tt=\tt M$  [p2]

 #无条件跳转到标记L2执行  

#R[eax]←M[R[eax]],即R[eax]  $\tt=\tt M$  [p1] p1和p2是指针型参数，所以在32位机中的长度是dwordpt，比较指令cmp的两个操作数都应来自寄存器，因此应先将p1和p2对应的实参从栈中取到通用寄存器，比较指令执行后得到各个条件码，然后根据各条件码值的组合选择执行不同的指令，因此需要用到条件转移指令。  
# 4.3.3循环语句的机器级表示  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5e9ce93948244371752a99da718858d0591e96463fdaa6dbe6dd22cbbc3cf37e.jpg)  

循环语句的机器级代码分析（2014、2017、2019、2023）  

常见的循环结构语句有while、for和do-while。汇编中没有相应的指令存在，可以用条件测试和转跳组合起来实现循环的效果，大多数编译器将这三种循环结构都转换为do-while形式来产生机器代码。在循环结构中，通常使用条件转移指令来判断循环条件的结束。  

（1）do-while循环  

do-while语句的通用形式如下：  

body statement while(test expr);  

这种通用形式可以被翻译成如下所示的条件和goto语句  

loop: body statement  $\scriptstyle\mathrm{t}=$  test_expr; if(t) goto loop;  

也就是说，每次循环，程序会执行循环体内的语句，body_statement至少会执行一次，然后执行测试表达式。若测试为真，则继续执行循环。  

（2）while循环  

while语句的通用形式如下：while(test expr)  

body statement  

与do-while，body statement，test expr，循环有可能中止。GCC通常会将其翻译成条件分支加do-while循环的方式。  

用如下模板来表达这种方法，将通用的while循环格式翻译成do-while循环：  

t=test expr; if(!t) gotodone; do body statement while(test expr); done:  

相应地，进一步将它翻译成goto语句  

t=test expr; if(!t) goto done; loop:  

body statement t=test expr; if(t) gotoloop; done:  

（3）for循环  

for循环的通用形式如下：  

for（init expr; test_expr;update expr)  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c59e1434ff34a9f2d84130def9419a860a7e3cf1681145df32fe17e1ef02bf32.jpg)  
这个for循环的行为与下面这段while循环代码的行为一样：  

init_expr; while(testexpr){ body statement update expr;  

进一步把它翻译成goto语句：  

init expr; t=test_expr; if(!t) goto done; loop: body statement update expr; t=test_expr; if(t) gotoloop; done:  

下面是一个用for循环写的自然数求和的函数：  

int nsum for（intn）{int i; int result  $\mathbf{\varepsilon}=\mathbf{\varepsilon}_{0}$  for  $\scriptstyle({\dot{\mathrm{i}}}=1;{\dot{\mathrm{i}}}<={\mathrm{n}};{\dot{\mathrm{i}}}++)$  result  $\scriptstyle+=\,\mathrm{i}$  return result;  

这段代码中的for循环的不同组成部分如下：  

initexpr  $_\perp=\!1$  test_expr  $\scriptstyle{\mathrm{i}}<={\mathrm{n}}$  update expr  $\ \ \dot{\mathbf{1}}++$  body statement result  $\scriptstyle+={\dot{\mathbf{x}}}$  

通过替换前面给出的模板中的相应位置，很容易将for循环转换为while或do-while循环。将这个函数翻译为goto语句代码后，不难得出其过程体的汇编代码：  

mov ecx,dword ptr [ebp+8] #R[ecx]-M[R[ebp]  $\mathbf{+8]}$  ，即  $\mathtt{R}\left[\mathtt{e c x}\right]\mathtt{=}\mathtt{n}$  mov eax,0 #R[eax]-0,即 result  $=\!0$  mov edx,1 #R[edx]-1，即  $_\mathrm{i}\!=\!\!1$  cmp edx,ecx #Compare R[edx]：R[ecx]，即比较i:n jgL2#Ifgreater，转跳到L2执行.L1: #loop: add eax,edx #R[eax]-R[eax]+R[edx], 即result  $\scriptstyle+=\mathrm{i}$  addedx,1#R[edx]-R[edx]+1，即 $\ \ \ \mathrm{i}_{\leftarrow}$ cmpedx,ecx#比较R[edx]和R[ecx]，即比较i：njle.L1#If lessor equal，转跳到L1执行.L2:  

已知n对应的实参已被压入调用函数的栈帧，其对应的存储地址为R[ebp]+8，过程nsum_for中的局部变量i和resut被分别分配到寄存器EDX和EAX中，返回参数在EAX中。  

# 4.3.4过程调用的机器级表示  

前面提到的call/ret指令主要用于过程调用，它们都属于一种无条件转移指令。  
假定过程P（调用者）调用过程Q（被调用者），过程调用的执行步骤如下：  

1）P将入口参数（实参）放到Q能访问到的地方。2）P将返回地址存到特定的地方，然后将控制转移到Q。3）Q保存P的现场（通用寄存器的内容），并为自己的非静态局部变量分配空间。  

4）执行过程Q。5）Q恢复P的现场，将返回结果放到P能访问到的地方，并释放局部变量所占空间。  

6）Q取出返回地址，将控制转移到P。  

步骤2）是由call指令实现的，步骤6）通过ret指令返回到过程P。在上述步骤中，需要为入口参数、返回地址、过程P的现场、过程Q的局部变量、返回结果找到存放空间。  

用户可见寄存器数量有限，调用者和被调用者需共享寄存器，若直接覆盖对方的寄存器，则会导致程序出错。因此有如下规范：寄存器EAX、ECX和EDX是调用者保存寄存器，当P调用Q时，若Q需用到这些寄存器，则由P将这些寄存器的内容保存到栈中，并在返回后由P恢复它们的值。寄存器EBX、ESI、EDI是被调用者保存寄存器，当P调用Q时，Q必须先将这些寄存器的内容保存在栈中才能使用它们，并在返回P之前先恢复它们的值。  

每个过程都有自己的栈区，称为栈帧，因此，一个栈由若干栈帧组成，寄存器EBP指示栈帧的起始位置，寄存器ESP指示栈顶，栈从高地址向低地址增长。过程执行时，ESP会随着数据的入栈而动态变化，而EBP固定不变。当前栈帧的范围在EBP和ESP指向的区域之间。  

下面用一个简单的C语言程序来说明过程调用的机器级实现。  

int add（int  $_\mathrm{x}$  ,inty）{ return  $\tt x+y$  int caller(){ int templ  $_{\cdot}=\!125$  int temp2  $_{2=80}$  int sum  $\mathrm{i}=$  add(templ,temp2）; return sum;  

经GCC编译后，caller过程对应的代码如下（#后面的文字是注释）：  

caller: push ebp mov ebp,esp sub esp,24 mov[ebp-12],125#M[R[ebp]-12]-125，即temp1 $_{\cdot}\,=\,\!1\,2\,5$ mov[ebp-8],80#M[R[ebp]-8]←80，即temp2 $\scriptstyle{:=80}$ mov eax,dword ptr [ebp-8] #R[eax]-M[R[ebp]-8]，即R[eax]  $=$  temp2 mov[esp+4],eax#M[R[esp]+4]-R[eax]，即temp2入栈mov eax,dword ptr[ebp-12] #R[eax]←M[R[ebp]-12],即]R[eax]  $=$  temp1 mov[esp],eax#M[R[esp]]←R[eax]，即templ入栈calladd#调用add，将返回值保存在eax中mov[ebp-4],eax#M[R[ebp]-4]-R[eax]，即add返回值送summoveax，dword ptr[ebp-4]#R[eax]←M[R[ebp]-4]，即sum作为返回值leave  

图4.12给出了caller栈帧的状态，假定caller被过程P调用。执行第4行的指令后，ESP所指的位置如图中所示，可以看出GCC为caller的参数分配了24字节的空间。从汇编代码中可以看出，caller中只使用了调用者保存寄存器EAX，没有使用任何被调用者保存寄存器，因此在caller栈帧中无须保存除EBP外的任何寄存器的值；caller有三个局部变量templ、temp2和sum，皆被 分配在栈顿中；在用call指令调用add函数之前，caller先将入口参数从右向左依次将temp2和temp1的值（即80和125）保存到栈中。在执行call指令时再把返回地址压入栈中。此外，在最初进入caller时，还将EBP的值压入了栈，因此caller的栈帧中用到的空间占 $4+12+8+4=28$ 字节。但是，caller的栈帧共有 $4+24+4=32$ 字节，其中浪费了4字节的空间（未使用）。这是因为GCC为保证数据的严格对齐而规定每个函数的栈帧大小必须是16字节的倍数。  
call指令执行后，add函数的返回参数存放在EAX中，因此call指令后面的两条指令中，指令“mov[ebp-4],eax”将 add 的结果存入 sum变量的存储空间，该变量的地址为R[ebp]-4；指令“moveax,dwordptr[ebp-4]”将sum变量的值作为返回值送到寄存器EAX中。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d980c64caf10e8c75223e749aaa0890e4e8f054132e40c8f446ccc6806ddab98.jpg)  
图4.12caller add  

在执行ret指令之前，应将当前栈帧释放，并恢复旧EBP的值，上述第14行leave指令实现了这个功能，leave指令功能相当于以下两条指令的功能：  

mov esp，ebp pop ebp  

其中，第一条指令使ESP指向当前EBP的位置，第二条指令执行后，EBP恢复为P中的I旧值，并使ESP指向返回地址。  

执行完leave指令后，ret指令就可从ESP所指处取返回地址，以返回P执行。当然，编译器也可通过pop指令和对ESP的内容做加法来进行退栈操作，而不一定要使用leave指令。  

add过程经GCc编译并进行链接后，对应的代码如下所示：  

8048469:55 push ebp 804846a:89e5 mov ebp,esp 804846c:8b450c mov eax,dwordptr [ebp+12] 804846f:8b5508 mov edx,dword ptr [ebp+8] 8048472:8d0402 lea eax,[edx+eax] 8048475:5d pop ebp 8048476:c3 ret  

通常，一个过程对应的机器级代码都有三个部分：准备阶段、过程体和结束阶段。  

上述第1、2行的指令构成准备阶段的代码段，这是最简单的准备阶段代码段，它通过将当前栈指针ESP传送到EBP来完成将EBP指向当前栈帧底部的任务，如图4.12所示，EBP指向add栈顿底部，从而可以方便地通过EBP获取入口参数。这里add的入口参数x和y对应的值（125和80）分别在地址为 ${\mathrm{R}}[{\mathrm{ebp}}]+8$  $\mathrm{R}[\mathsf{e b p}]+12$ 的存储单元中。  
上述第3、4、5行的指令序列是过程体的代码段，过程体结束时将返回值放在EAX中。这里好像没有加法指令，实际上第5行lea指令执行的是加法运算 $\mathrm{R[edx]+R[eax]=x+y.}$  

上述第6、7行的指令序列是结束阶段的代码段，通过将EBP弹出栈帧来恢复EBP在caller过程中的值，并在栈中退出add过程的栈帧，使得执行到ret指令时栈顶中已经是返回地址。这里的返回地址应该是caller代码中第12行的指令“mov[ebp-4],eax”的地址。  

add过程中没有用到任何被调用者保存寄存器，没有局部变量，此外，add是一个被调用过程，并且不再调用其他过程，因此也没有入口参数和返回地址要保存，因此，在add的栈帧中除了需要保存EBP，无须保留其他任何信息。  
 

# 4.4CISC RISC  

指令系统朝两个截然不同的方向的发展：一是增强原有指令的功能，设置更为复杂的新指令实现软件功能的硬化，这类机器称为复杂指令系统计算机（CISC），典型的有采用 $\mathrm{x86}$ 架构的计算机；二是减少指令种类和简化指令功能，提高指令的执行速度，这类机器称为精简指令系统计算机（RISC），典型的有ARM、MIPS架构的计算机。  
# 4.4.1复杂指令系统计算机（CISC）  

随着集成电路技术的发展，软件成本不断上升，促使人们在指令系统中增加更多、更复杂的指令，以适应不同的应用领域，这样就构成了复杂指令系统计算机（CISC）。  

>#### pro： CISC的特点(2017)  

CISC的主要特点如下：  

1）指令系统复杂庞大，指令数目一般为200条以上。  

2）指令的长度不固定，指令格式多，寻址方式多。  

3）可以访存的指令不受限制。  

4）各种指令使用频度相差很大。  

5）各种指令执行时间相差很大，大多数指令需多个时钟周期才能完成。  

6）控制器大多数采用微程序控制。有些指令非常复杂，以至于无法采用硬连线控制。  

如此庞大的指令系统，对指令的设计提出了极高的要求，研制周期变得很长。后来人们发现，一味地追求指令系统的复杂和完备程度不是提高性能的唯一途径。对传统CISC指令系统的测试表明，各种指令的使用频率相差悬殊，大概只有 $20\%$ 的简单指令被反复使用，约占整个程序的 $80\%$ 血 $80\%$ 左石的复杂指令则很少使用，约占整个程序的 $20\%$ 。从这一事实出发，人们开始用最常用的 $20\%$ 的简单指令，重组实现不常用的 $80\%$ 的指令功能，RISC随之诞生。  

# 4.4.2精简指令系统计算机（RISC）  

精简指令系统计算机（RISC）的中心思想是要求指令系统简化，尽量使用寄存器-寄存器操作指令，指令格式力求一致。RISC的主要特点如下：  

1）选取使用频率最高的一些简单指令，复杂指令的功能由简单指令的组合来实现。2）指令长度固定，指令格式种类少，寻址方式种类少。3）只有LOAD/STORE（取数/存数）指令访存，其余指令的操作都在寄存器之间进行。4）CPU中通用寄存器的数量相当多。5）一定采用指令流水线技术，大部分指令在一个时钟周期内完成。6）以硬布线控制为主，不用或少用微程序控制。7）特别重视编译优化工作，以减少程序执行时间。  

值得注意的是，从指令系统兼容性看，CISC大多能实现软件兼容，即高档机包含了低档机的全部指令，并可加以扩充。但RISC简化了指令系统，指令条数少，格式也不同于老机器，因此大多数RISC机不能与老机器兼容。由于RISC具有更强的实用性，因此应该是未来处理器的发展方向。但事实上，当今时代Intel几乎一统江湖，且早期很多软件都是根据CISC设计的，单纯的RISC将无法兼容。此外，现代CISC结构的CPU已经融合了很多RISC的成分，其性能差距已经越来越小。CISC可以提供更多的功能，这是程序设计所需要的。  

# 4.4.3 CISC RISC  

和CISC相比，RISC的优点主要体现在以下几点：1）RISC更能充分利用VLSI（超大规模集成电路）芯片的面积。CISC采用微程序控制，其  
控制存储器占CPU芯片面积的 $50\%$ 以上，而RISC采用组合逻辑控制，其硬布线逻辑只占CPU芯片面积的 $10\%$ 左右。  

2）RISC更能提高运算速度。RISC的指令数、寻址方式和指令格式种类少，又设有多个通用寄存器，采用流水线技术，所以运算速度更快，大多数指令在一个时钟周期内完成。  

3）RISC便于设计，可降低成本，提高可靠性。RISC指令系统简单，因此机器设计周期短：其逻辑简单，出错概率低，有错也易发现，因此可靠性高。  

4）RISC有利于编译程序代码优化。RISC指令类型少，寻址方式少，使编译程序容易选择更有效的指令和寻址方式，并适当地调整指令顺序，使得代码执行更高效化。  

CISC和RISC的对比见表4.3。  

表4.3 CISC RISC
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c72ca4df9a8e8d7fdeb190d640247354dcff3e2ee6fb58e6a641d46da41d6b00.jpg)  


# 4.5 本章小结  

本章开头提出的问题的参考答案如下。  

1）什么是指令？什么是指令系统？为什么要引入指令系统？  

指令就是要计算机执行某种操作的命令。一台计算机中所有机器指令的集合，称为这台计算机的指令系统。引入指令系统后，避免了用户与二进制代码直接接触，使得用户编写程序更为方便。另外，指令系统是表征一台计算机性能的重要因素，它的格式与功能不仅直接影响到机器的硬件结构，而且也直接影响到系统软件，影响到机器的适用范围。  
2）一般来说，指令分为哪些部分？每部分有什么用处？  

一条指令通常包括操作码字段和地址码字段两部分。其中，操作码指出指令中该指令应该执行什么性质的操作和具有何种功能，它是识别指令、了解指令功能与区分操作数地址内容的组成和使用方法等的关键信息。地址码用于给出被操作的信息（指令或数据）的地址，包括参加运算的一个或多个操作数所在的地址、运算结果的保存地址、程序的转移地址、被调用子程序的入口地址等。  

3）对于一个指令系统来说，寻址方式多和少有什么影响？  

寻址方式的多样化能让用户编程更为方便，但多重寻址方式会造成CPU结构的复杂化（详见下章），也不利于指令流水线的运行。而寻址方式太少虽然能够提高CPU的效率，但对于用户而言，少数几种寻址方式会使编程变得复杂，很难满足用户的需求。  

# 4.6常见问题和易混淆知识点  

1.简述各常见指令寻址方式的特点和适用情况。  

立即寻址操作数获取便捷，通常用于给寄存器赋初值。  

直接寻址相对于立即寻址，缩短了指令长度。  

间接寻址扩大了寻址范围，便于编制程序，易于完成子程序返回。  

寄存器寻址的指令字较短，指令执行速度较快。  

寄存器间接寻址扩大了寻址范围。  

基址寻址扩大了操作数寻址范围，适用于多道程序设计，常用于为程序或数据分配存储空间。  

变址寻址主要用于处理数组问题，适合编制循环程序。  

相对寻址用于控制程序的执行顺序、转移等。  

基址寻址和变址寻址的区别：两种方式有效地址的形成都是寄存器内容+偏移地址，但是在基址寻址中，程序员操作的是偏移地址，基址寄存器的内容由操作系统控制，在执行过程中是动态调整的；而在变址寻址中，程序员操作的是变址寄存器，偏移地址是固定不变的。  

# 2.一个操作数在内存可能占多个单元，怎样在指令中给出操作数的地址？  

现代计算机都采用字节编址方式，即一个内存单元只能存放一字节的信息。一个操作数（如char、int、float、double）可能是8位、16位、32位或64位等，因此可能占用1个、2个、4个或8个内存单元。也就是说，一个操作数可能有多个内存地址对应。  

有两种不同的地址指定方式：大端方式和小端方式。大端方式：指令中给出的地址是操作数最高有效字节（MSB）所在的地址。小端方式：指令中给出的地址是操作数最低有效字节（LSB）所在的地址。3.装入/存储（LOAD/STORE）型指令有什么特点？  

装入/存储型指令是用在规整型指令系统中的一种通用寄存器型指令风格。这种指令风格在RISC指令系统中较为常见。为了规整指令格式，使指令具有相同的长度，规定只有LOAD/STORE指令才能访问内存。而运算指令不能直接访问内存，只能从寄存器取数进行运算，运算的结果也只能送到寄存器。因为寄存器编号较短，而主存地址位数较长，通过某种方式可使运算指令和访存指令的长度一致。  

这种装入/存储型风格的指令系统的最大特点是，指令格式规整，指令长度一致，一般为32位。由于只有LOAD/STORE指令才能访问内存，因此程序中可能包含许多装入指令和存储指令，与一般通用寄存器型指令风格相比，其程序长度会更长。  
# 第5章中央处理器  

# 【考纲内容】  

（一）CPU的功能和基本结构  

（二）指令执行过程  

（三）数据通路的功能和基本结构  

（四）控制器的功能和工作原理  

五）异常和中断机制异常和中断的基本概念：异常和中断的分类；异常和中断的检测与响应  

（六）指令流水线指令流水线的基本概念：指令流水线的基本实现：结构冒险、数据冒险和控制冒险的处理；超标量和动态流水线的基本概念  

（七）多处理器基本概念  

SISD、SIMD、MIMD、向量处理器的基本概念：硬件多线程的基本概念：多核（multi-core）处理器的基本概念：共享内存多处理器（SMP）的基本概念  

# 【复习提示】  

中央处理器是计算机的中心，也是本书的难点。其中，数据通路的分析、指令执行阶段的节拍与控制信号的安排、流水线技术与性能分析易出综合题。而关于各种寄存器的特点、各种指令执行的周期与特点、控制器的相关概念、流水线的相关概念易出选择题。  

在学习本章时，请读者思考以下问题：  

1）指令和数据均存放在内存中，计算机如何从时间和空间上区分它们是指令还是数据？  

2）什么是指令周期、机器周期和时钟周期？它们之间有何关系？  

3）什么是微指令？它和第4章谈到的指令有什么关系？  

4）什么是指令流水线？指令流水线相对于传统体系结构的优势是什么？  

请读者在本章的学习过程中寻找答案，本章末尾会给出参考答案。  

# 5.1CPU的功能和基本结构  

# 5.1.1CPU的功能  

中央处理器（CPU）由运算器和控制器组成。其中，控制器的功能是负责协调并控制计算机各部件执行程序的指令序列：运算器的功能是对数据进行加工。CPU的具体功能包括：  

1）指令控制。完成取指令（也称取指）、分析指令和执行指令的操作，即程序的顺序控制。  
2）操作控制。产生完成一条指令所需的操作信号，把各种操作信号送到相应的部件，从而控制这些部件按指令的要求正确执行。3）时间控制。严格控制各种操作信号的出现时间、持续时间及出现的时间顺序。4）数据加工。对数据进行算术和逻辑运算。5）中断处理。对运行过程中出现的异常情况和中断请求进行处理。  

# 5.1.2CPU的基本结构  

在计算机系统中，CPU主要由运算器和控制器两大部分组成［也可将CPU分为数据通路（见5.3节）和控制部件两大组成部分]，如图5.1所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4b9660fe8f486ff3097ffb4d9a7cf8d43ce70d8af78ba631a7eee723b6a34fa0.jpg)  
图5.1中央处理器的组成  

# 1.运算器  

运算器主要由算术逻辑单元（ALU）、暂存寄存器、累加寄存器（ACC）、通用寄存器组（GPRs）程序状态字寄存器（PSW）、移位寄存器、计数器（CT）等组成。其主要功能是根据控制器送来的命令，对数据执行算术运算（加、减、乘、除）、逻辑运算（与、或、非、异或、移位、求补等）或条件测试（用于设置ZF、SF、OF和CF等标志位，作为条件转移的判断条件）。  

# 2.控制器  

控制器主要由程序计数器（PC）、指令寄存器（IR）、指令译码器（ID）、存储器地址寄存器（MAR）、存储器数据寄存器（MDR）、时序电路和微操作信号发生器等组成。其主要功能是执行指令，每条指令的执行是由控制器发出的一组微操作实现的。  

控制器的工作原理是，根据指令操作码、指令的执行步骤（微命令序列）和条件信号来形成当前计算机各部件要用到的控制信号。计算机整机各硬件系统在这些控制信号的控制下协同运行，产生预期的执行结果。控制器是整个系统的指挥中枢，在控制器的控制下，运算器、存储器和输入/输出设备等功能部件构成一个有机的整体，根据指令的要求指挥全机协调工作。  

# 5.1.3CPU的寄存器  

>#### pro：汇编程序员可见的寄存器（2010、2015、2021）  

CPU中的寄存器按汇编语言（或机器语言）程序是否可访问，可分为两类：一类是用户可见寄存器，可对这类寄存器编程，以通过使用这类寄存器减少对主存储器的访问次数，如通用寄存器组（含基址/变址寄存器）、程序状态字寄存器、程序计数器、累加寄存器、移位寄存器；另一类是用户不可见寄存器，对用户是透明的，不可对这类寄存器编程，它们被控制部件使用，以控制CPU的操作，如存储器地址寄存器、存储器数据寄存器、指令寄存器、暂存寄存器。  
>#### pro：CPU中各种寄存器的作用（2013）  

# 1.运算器中的寄存器  

1）通用寄存器组（GPRs）。用于存放操作数（包括源操作数、目的操作数及中间结果）和各种地址信息等，如AX、BX、CX、DX、SP等。在指令中要指定寄存器的编号，才能明确是对哪个寄存器进行访问。SP是堆栈指针，用于指示栈顶的地址。2）累加寄存器（ACC）。它是一个通用寄存器，用于暂时存放ALU运算的结果。3）移位寄存器（SR）。不但可用来存放操作数，而且在控制信号的作用下，寄存器中的数据可根据需要向左或向右移位。4）暂存寄存器。用于暂存从数据总线或通用寄存器送来的操作数，以便在取出下一个操作数时将其同时送入ALU。暂存寄存器对应用程序员是透明的（不可见）。5）程序状态字寄存器（PSW）。保留由算术/逻辑运算指令或测试指令的运行结果而建立的各种状态信息，如溢出标志（OF）、符号标志（SF）、零标志（ZF）、进位标志（CF）等。每个标志位通常由一位触发器来保存，这些标志位组合在一起称为程序状态字。  

# 2.控制器中的寄存器  

>#### pro：PC和IR的位数与主存储器空间和指令字长的关系（2016、2021）  

1）程序计数器（PC）。用于指出欲执行指令在主存储器中的存放地址。若PC和主存储器均按字节编址，则PC的位数等于主存储器地址位数。CPU根据PC的内容从主存储器中取指令，然后送入指令寄存器。指令通常是顺序执行的，因此PC具有自动加1的功能（这里的“1”是指一条指令的字节数）；当遇到转移类指令时，PC的新值由指令计算得到。  

2）指令寄存器（IR）。用于保存当前正在执行的指令，IR的位数等于指令字长。  

3）存储器地址寄存器（MAR）。用于存放要访问的主存储器单元的地址，MAR的位数等于主存储器地址线数，它反映了最多可寻址的存储单元的个数。  

4）存储器数据寄存器（MDR）。用于存放向主存储器写入的信息或从主存储器读出的信息，MDR的位数等于存储字长。当CPU和主存储器交换信息时，都要用到MAR和MDR。  
  

# 5.2指令执行过程  

# 5.2.1指令周期  

CPU每取出并执行一条指令所需的全部时间称为指令周期，不同指令的指令周期可能不同。指令周期通常可用若干机器周期来表示，每个指令周期内的机器周期数可以不等。图5.2反映了上述关系。图5.2（a）所示为定长的机器周期，图5.2（b）所示为不定长的机器周期。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4cdf5401a046fb5fe39af366d76c0d8889d1154a1965f8d7673571ffd1641a97.jpg)  
图5.2指令周期和机器周期的关系  

对于无条件转移指令JIMIPX，在执行时不需要访问主存，只包含取指阶段（包括取指和分析）和执行阶段，所以其指令周期仅包含取指周期和执行周期。  

对于间接寻址的指令，为了取操作数，需要先访问一次主存，取出有效地址，然后访问主存，取出操作数，所以还需包括间址周期。间址周期介于取指周期和执行周期之间。  

当CPU采用中断方式实现主机和I/O设备的信息交换时，CPU在每条指令执行结束前，都要发中断查询信号，若有中断请求，则CPU进入中断响应阶段，也称中断周期。这样，一个完整的指令周期可包括取指、间址、执行和中断4个周期，如图5.3所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f7ac4456b5579efe301d3c745f4bafd3791739991e765a528a6dd737b49f8fa6.jpg)  
图5.3带有间址周期、中断周期的指令周期  

>#### pro：指令执行的过程（2011）  

当CPU执行指令时，首先进入取指周期，从PC指出的主存单元中取出指令，送至指令寄存器，同时PC加“1”以作为下一条指令的地址。当遇到转移指令等改变执行顺序的指令时，  
在PC加“1”后会重新计算并更新PC值。然后判断是否有间接寻址，如果有，那么进入间址周期以获取操作数的有效地址。之后进人执行周期，完成取操作数、执行运算和存操作数的任务。执行周期结束后，如果CPU检测到中断请求，则进入中断周期，此时需要关中断、保存断点、修改PC值为中断服务程序的入口地址，并转向中断服务程序。关于中断的具体内容，见本章的5.5节。  

# 注意  

中断周期中的进栈操作是将SP减“1”，这和传统意义上的进栈操作相反，原因是计算机中的堆栈都是向低地址方向增长，所以进栈操作是减“1”而不是加“”。  

# 5.2.2指令周期的数据流  

数据流是根据指令要求依次访问的数据序列。在指令执行的不同阶段，要求依次访问的数据序列是不同的。而且对于不同的指令，它们的数据流往往也是不同的。  

# 1.取指周期  

取指周期的任务是根据PC中的内容从主存中取出指令代码并存放在IR中。  

取指周期的数据流如图5.4所示。PC中存放的是指令的地址，根据此地址从内存单元中取出的是指令，并放在指令寄存器IR中，取指令的同时，PC加1。  

取指周期的数据流向如下：  

1）PC  $\circledast$  MAR②地址总线存储器。 2）CU发出读命令控制总线 $\circeq$ 存储器3）主存 $\circeq$ 数据总线 $\nsupseteq$ MDR $\circledast$ IR（存放指令）4）CU发出控制信号PC内容加1。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f75084f25f382c3b663c9acfe77f401b2ea0ef4abcdf6fe2e458bbf2de1010ae.jpg)  
图5.4取指周期的数据流  

# 2.间址周期  

间址周期的任务是取操作数有效地址。以一次间址为例（见图5.5），将指令中的地址码送到MAR并送至地址总线，此后CU向存储器发出读命令，以获取有效地址并存至MDR。  

间址周期的数据流向如下：  

1）Ad（IR）（或MDR） $\circledast$ MAR $\circeq$ 地址总线存储器。2）CU发出读命令控制总线存储器。3）主存数据总线 $\nsupseteq$ MDR（存放有效地址）。  

其中，Ad（IR）表示取出IR中存放的指令字的地址字段。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a85b790d202f2b82ad10656f53199f418770f4c117771fe30b596a329d044671.jpg)  
图5.5一次间址周期的数据流  

# 3.执行周期  

执行周期的任务是取操作数，并根据IR中的指令字的操作码通过ALU操作产生执行结果。不同指令的执行周期操作不同，因此没有统一的数据流向。  

# 4.中断周期  

中断周期的任务是处理中断请求。假设程序断点存入堆栈中，并用SP指示栈顶地址，而且进栈操作是先修改栈顶指针，后存入数据，数据流如图5.6所示。  

中断周期的数据流向如下：  

1）CU控制将SP减1，SP $\circeq$ MAR②地址总线存储器。2）CU发出写命令 $\underline{{\boldsymbol{\mathfrak{A}}}}$ 控制总线 $\circeq$ 存储器3）PCMDR $\nsupseteq$ 数据总线 $\circeq$ 主存（程序断点存入存储器）。4）CU（中断服务程序的入口地址）PC。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c5e774da7c287935949863c45b6d8ed1c27c81c7ecb099690202cb499289d6e4.jpg)  
图5.6中断周期的数据流  

# 5.2.3指令执行方案  

一个指令周期通常要包括几个执行步骤，每个步骤完成指令的一部分功能，几个依次执行的步骤完成这条指令的全部功能。不同的处理器采用不同的方案来安排指令的执行步骤。  

>#### pro：单周期和多周期CPU的CPI（2020）  

# 1.单周期处理器  

>#### pro：单周期CPU的特点（2016）  

单周期处理器对所有指令都选用相同的执行时间来完成。此时每条指令都在一个时钟周期内完成（即 ${\mathrm{CPI}}=1$ ），指令之间串行执行，即下一条指令只能在前一条指令执行结束后才能启动。因此，指令周期取决于执行时间最长的指令的执行时间。对于那些本来可以在更短时间内完成的指令，仍要使用这个较长的周期来完成，会降低整个系统的运行速度。  
# 2.多周期处理器  

多周期处理器对不同类型的指令选用不同的执行步骤。指令需要几个周期就为其分配几个周期，因此可选用不同个数的时钟周期来完成不同指令的执行过程（即 $\mathrm{CPI}>1)$ ，不再要求所有指令占用相同的执行时间。多指令周期方案中指令之间仍是串行执行。  

# 3.流水线处理器  

流水线处理器采用指令之间并行执行的方案，其追求的自标是力争在每个时钟周期完成一条指令的执行过程（只在理想情况下才能达到该效果，此时 ${\mathrm{CPI}}=1$ ）。这种方案通过在每个时钟周期启动一条指令，尽量让多条指令同时运行，但各自处在不同的执行步骤中。  
  

# 5.3数据通路的功能和基本结构  

# 5.3.1数据通路的功能  

随着技术的发展，更多的功能逻辑被集成到CPU芯片中，但不论CPU的内部结构多么复杂，它都可视为由数据通路（DataPath）和控制部件（ControlUnit）两大部分组成。  

>#### pro：数据通路的组成部件（2017、2021）  

数据在指令执行过程中所经过的路径，包括路径上的部件，称为数据通路，ALU、通用寄存器、状态寄存器、异常和中断处理逻辑等都是指令执行时数据流经的部件，都属于数据通路的一部分。数据通路描述了信息从哪里开始，中间经过哪些部件，最后被传送到哪里。数据通路由控制部件控制，控制部件根据每条指令功能的不同，生成对数据通路的控制信号。  

# 5.3.2数据通路的组成  

组成数据通路的元件主要分为组合逻辑元件和时序逻辑元件两类。>#### pro：数据通路中的组合逻辑元件和时序逻辑元件（2021、2023）  

# 1.组合逻辑元件（操作元件）  

任何时刻产生的输出仅取决于当前的输入。组合电路不含存储信号的记忆单元，也不受时钟信号的控制，输出与输入之间无反馈通路，信号是单向传输的。数据通路中常用的组合逻辑元件有加法器、算术逻辑单元（ALU）、译码器、多路选择器、三态门等，如图5.7所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/96308c858ff5f7964125d669141286fa1586d651484b7c7042c3ce73a05e35c4.jpg)  
图5.7数据通路中的几种常用组合逻辑元件  

图中虚线表示控制信号，译码器可用于操作码或地址码译码， $n$ 位输入对应 $2^{n}$ 种不同组合，因此有 $2^{n}$ 个不同输出。多路选择器（MUX）需要控制信号Select来确定选择哪个输入被输出。三态门可视为一种控制开关，由控制信号EN决定信号线的通断，当 $\mathrm{EN}=1$ 时，三态门被打开，输出信号等于输入信号：当 $\mathrm{EN}\,=\,0$ 时，输出端呈高阻态（隔断态），所连寄存器与总线断开。  

# 2.时序逻辑元件（状态元件）  

任何时刻的输出不仅与该时刻的输入有关，还与该时刻以前的输入有关，因而时序电路必然包含存储信号的记忆单元。此外，时序电路必须在时钟节拍下工作。各类寄存器和存储器，如通用寄存器组、程序计数器、状态/移位/暂存/锁存寄存器等，都属于时序逻辑元件。  

# 5.3.3数据通路的基本结构  

数据通路的基本结构主要有以下几种。  

# 1.CPU内部单总线方式  

>#### pro：数据通路中的部件及连接方式（2013、2015、2022）  

将ALU及所有寄存器都连接到一条内部公共总线上，称为单总线结构的数据通路。这种结构比较简单，但数据传输存在较多的冲突现象，性能较低。此总线在CPU内部，注意不要把它与连接CPU、存储器和外设的系统总线相混淆。图5.8所示为单总线的数据通路和控制信号。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0161e7b16de00d520d62405d382e730a37430111a550273cdc1cb28934a907c8.jpg)  
图5.8单总线的数据通路和控制信号  

>#### pro：数据通路中的三态门及其作用（2015）  

在图5.8中，GPRs为通用寄存器组，rs、rd分别为所读、写的通用寄存器的编号；Y和Z为暂存器；FR为标志寄存器，用于存放ALU产生的标志信息。带箭头的虚线表示控制信号，字母加“in”表示该部件充许写入，字母加“out”表示该部件充许输出。MDRin表示内部总线上信息写入MDR，MDRout表示MDR的内容送入内部总线。能输出到总线的部件均通过一个三态门与内部总线相连，用于控制该部件与内部总线之间数据通路的连接与断开。  
# 注意  

单周期处理器（ $\mathrm{CPI}=1$ ）不能采用单总线方式，因为单总线将所有寄存器都连接到一条公共总线上，一个时钟内只允许一次操作，无法完成一条指令的所有操作。  

# 2.CPU内部多总线方式  

CPU内部有两条或更多的总线时，构成双总线结构或多总线结构。将所有寄存器的输入端和输出端都连接到多条公共通路上，相比之下单总线中一个时钟内只充许传送一个数据，因而指令执行效率很低，因此采用多总线方式，同时在多个总线上传送不同的数据，提高效率。  

>#### pro：单周期CPU的特点（2016）  

# 3.专用数据通路方式  

根据指令执行过程中的数据和地址的流动方向安排连接电路，避免使用共享的总线，性能较高，但硬件量大。  

# 注意  

内部总线是指同一部件，如CPU内部连接各寄存器及运算部件之间的总线；系统总线是指同一台计算机系统的各部件，如CPU、内存和各类I/O接口间互相连接的总线。  

# 5.3.4数据通路的操作举例  

总线是一组共享的传输信号线，它不能存储信息，任一时刻也只能有一个部件把信息送到总线上。下面以图5.8所示的单总线数据通路为例，介绍一些常见操作的流程及控制信号。  

>#### pro：指令执行的节拍及有效控制信号（2009、2015）：指令在取数和执行阶段所用到的部件（2019）  

# 1.通用寄存器之间传送数据  

在寄存器和总线之间有两个控制信号：Rin和Rout。当Rin有效时，控制将总线上的信息存到寄存器R中；当Rout有效时，控制将寄存器R的内容送至总线。下面以程序计数器PC为例，将PC的内容送至MAR。实现该操作的流程及控制信号为  

(PC)→MARPC out MARin，PC内容→MAR  

# 2.从主存读取数据  

>#### pro：取指令阶段所需时钟周期分析（2022）  

从主存中读取的信息可能是数据或指令，现以CPU从主存中取指令为例，说明数据在单总线数据通路中的传送过程。实现该操作的流程及控制信号为  

（PC）→MARPC out MARin，现行指令地址→MARMEM（MAR)→MDR，（PC)+1→PCMDRin有效，CU发出读命令，取出指令后PC+1(MDR）→IR MDR out IR in，现行指令→IR  
第一步，将PC的内容通过内部总线送至MAR，需要1个时钟周期。第二步，CU向主存发出读命令，从MAR所指主存单元读取一个字，并送至MDR；同时PC加1为取下一条指令做准备，需要1个主存周期。第三步，将MDR的内容通过内部总线送至IR，需要1个时钟周期。  

# 3.将数据写入主存  

将寄存器R1的内容写入寄存器R2所指的主存单元，完成该操作的流程及控制信号为  

(R1)→MDR Rl out MDR in (R2)→MAR R 2 out MARin MDR→MEM(MAR)MDRout有效，CU发出写命令  

# 4.执行算术或逻辑运算  

# ALU中设置暂存器的原因（2015、2022）  

在单总线数据通路中，每一时刻总线上只有一个数据有效。由于ALU是一个没有存储功能的组合逻辑元件，在其执行运算时必须保持两个输入端同时有效，因此先将一个操作数经内部总线送人暂存器Y保存，Y的内容在ALU的左输入端始终有效，再将另一个操作数经内部总线直接送到ALU的右输入端。此外，ALU的输出端也不能直接与总线相连，否则其输出会通过总线反馈到输入端，影响运算结果，因此将运算结果暂存在暂存器乙中。假设加法指令ADDACC，R1，实现将ACC的内容和R1的内容相加并写回ACC，完成该操作的流程及控制信号为  

(R1)→Y Rl out Yin，操作数→Y (ACC)  $^+$  (Y）→Z ACC out ALU in，CU ALU，结果→Z (Z)→ACC Z out ACC in，结果→ACC  

>#### pro：分析减法和自增指令执行所需的时钟周期数（2015）  

以上3步不能同时执行，否则会引起总线冲突，因此该操作需要3个时钟周期  

# 5.修改程序计数器的值  

转移指令通过修改程序计数器PC的值来达到转跳的目的。假设转移指令JIMPaddr，addr为目标转移地址，实现将IR中的地址字段写入PC，完成该操作的流程及控制信号为  

Ad(IR)→PCIR out PC in  

数据通路结构直接影响CPU内各种信息的传送路径，数据通路不同，指令执行过程的微操作序列的安排也不同，它关系着微操作信号形成部件的设计。  


# 5.4控制器的功能和工作原理  

# 5.4.1控制器的结构和功能  

从图5.9可以看到计算机硬件系统的五大功能部件及其连接关系。它们通过数据总线、地址总线和控制总线连接在一起，其中点画线框内的是控制器部件。  

现对其主要连接关系简单说明如下：  

1）运算器部件通过数据总线与内存储器、输入设备和输出设备传送数据。  

2）输入设备和输出设备通过接口电路与总线相连接。  

3）内存储器、输入设备和输出设备从地址总线接收地址信息，从控制总线得到控制信号，通过数据总线与其他部件传送数据。  

4）控制器部件从数据总线接收指令信息，从运算器部件接收指令转移地址，送出指令地址到地址总线，还要向系统中的部件提供它们运行所需要的控制信号。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d13488b4b74cc2530f08d0235bb3404b2df25c7b14a7a83dd5306035c33dd080.jpg)  
图5.9计算机硬件系统和控制器部件的组成  

控制器是计算机系统的指挥中心，控制器的主要功能有：  

1）从主存中取出一条指令，并指出下一条指令在主存中的位置。2）对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作。  

3）指挥并控制CPU、主存、输入设备和输出设备之间的数据流动方向。  

根据控制器产生微操作控制信号的方式的不同，控制器可分为硬布线控制器和微程序控制器，两类控制器中的PC和IR是相同的，但确定和表示指令执行步骤的办法及给出控制各部件运行所需要的控制信号的方案是不同的。  
# 5.4.2硬布线控制器  

硬布线控制器由复杂的组合逻辑门电路和触发器构成，也称组合逻辑控制器，其原理是根据指令的要求、当前的时序及内外部的状态，按时间的顺序发送一系列微操作控制信号。  

指令的操作码是决定控制单元（CU）发出不同控制信号的关键。为了简化CU的逻辑，将存放在 IR的 $n$ 位操作码经过译码电路产生 $2^{n}$ 个输出，每种操作码对应一个输出送至CU。如果将指令译码器和节拍发生器从CU中分离出来，便可得到简化的控制单元框图，如图5.10所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d2f55e758d9c494275dac108e2cae6bca95b683e62055bdffc92ff9c328afb53.jpg)  
图5.10带指令译码器和节拍输入的控制单元框图  

控制单元（CU）的输入信号来源如下：  

1）经指令译码器译码产生的指令信息。现行指令的操作码决定了不同指令在执行周期所需完成的不同操作，它与时钟配合产生不同的控制信号。2）时序系统产生的机器周期信号和节拍信号。为了使控制单元按一定的先后顺序、一定的节奏发出各个控制信号，控制单元必须受时钟控制。3）来自执行单元的反馈信息即标志。控制单元有时需依赖CPU当前所处的状态产生控制信号，如BAN指令，控制单元要根据上条指令的结果是否为负来产生不同的控制信号。  

图5.10中，节拍发生器产生各机器周期中的节拍信号，使不同的微操作命令 $C_{i}$ （控制信号）按时间的先后发出。个别指令的操作不仅受操作码控制，而且受到状态标志控制，因此CU的输入来自操作码译码电路ID、节拍发生器及状态标志，其输出到CPU内部或外部控制总线上。  

硬布线控制的功能由逻辑门组合实现，其速度主要取决于电路延迟，因此高速计算机中的关键核心部件CPU往往采用硬布线逻辑实现。因此，RISC一般都选用硬布线控制器。硬布线控制器的控制信号先用逻辑式列出，经化简后用电路来实现，因此显得零乱复杂，当需要修改或增加指令时就必须重新设计电路，非常麻烦。而且指令系统功能越全，微操作命令就越多，电路也就越庞杂，调试就更困难。为了克服这些缺点，便产生了微程序设计方法。  

# 5.4.3微程序控制器  

微程序控制器采用存储逻辑实现，也就是将微操作信号代码化，使每条机器指令转化成为一段微程序并存入一个专门的存储器（控制存储器）中，微操作控制信号由微指令产生。  

# 1.微程序控制的基本概念  

微程序的设计思想就是将每条机器指令编写成一个微程序，每个微程序包含若干微指令，每条微指令对应一个或几个微操作命令。因此，执行一条指令的过程就是执行一个微程序的过程，这些微程序存储在一个控制存储器中。目前，大多数计算机都采用微程序设计技术。  
微程序设计技术涉及的基本术语如下。  

（1）微命令与微操作  

在微程序控制的计算机中，控制部件向执行部件发出的各种控制命令称为微命令，它是构成控制序列的最小单位。例如，打开或关闭某个控制门的电位信号、某个寄存器的打入脉冲等。执行部件收到微命令后所进行的操作称为微操作，微命令和微操作是一一对应的。  

微命令有相容性和互斥性之分。相容性微命令是指那些可以同时出现、共同完成某一些微操作的微命令；而互斥性微命令是指在机器中不允许同时出现的微命令。  

# 注意  

硬布线控制器中也有微命令与微操作的概念，并非微程序控制器的专有概念。  

（2）微指令与微周期  

微指令是若干微命令的集合，一条微指令通常至少包含两大部分信息：  

$\textcircled{\scriptsize{1}}$ 操作控制字段，也称微操作码字段，用于产生某一步操作所需的各种操作控制信号。  

$\circledcirc$ 顺序控制字段，也称微地址码字段，用于控制产生下一条要执行的微指令地址。  

微周期是指从控制存储器中取出并执行一条微指令所需的全部时间，通常为一个时钟周期。  

（3）主存储器与控制存储器  

>#### pro：主存储器和控制存储器的区别（2017）  

主存储器用于存放程序和数据，在CPU外部，用RAM实现。控制存储器（CM）用于存放微程序，在CPU内部，用ROM实现。存放微指令的控制存储器的单元地址称为微地址。  

# （4）程序与微程序  

微程序和程序是两个不同的概念。程序是指令的有序集合，用于完成特定的功能。微程序是微指令的有序集合，用于描述机器指令，一条指令的功能由一段微程序来实现。微程序实际上是机器指令的实时解释器，是由计算机设计者事先编制好并存放在控制存储器中的，一般不提供给用户。对于程序员来说，系统中微程序的结构和功能是透明的，无须知道。程序最终由机器指令组成，并且由软件设计人员事先编制好并存放在主存储器或者辅助存储器中。  

读者应注意区分以下寄存器：  

$\textcircled{\scriptsize{1}}$ 地址寄存器（MAR）。用于存放主存的读/写地址。  

$\circledcirc$ 微指令地址寄存器（ $\upmu\mathrm{PC}$ 或CMAR)。用于存放待执行的微指令在控制存储器中的微地址。  

$\textcircled{3}$ 指令寄存器（IR）。用于存放从主存中读出的指令。  

$\textcircled{4}$ 微指令寄存器（ $\upmu\mathrm{{IR}}$ 或CMIDR）。用于存放从控制存储器中读出的微指令。  

# 2.微程序控制器的组成和工作过程  

（1）微程序控制器的基本组成  

图5.11所示为一个微程序控制器的基本结构，其主要部件包括：  

$\textcircled{\scriptsize{1}}$ 起始和转移地址形成部件（或简称微地址形成部件）。用于产生初始和后继微地址，以保证微指令的连续执行。  

$\textcircled{2}$ 微指令地址寄存器。接收微地址形成部件送来的微地址，为读取微指令做准备。  

$\textcircled{3}$ 控制存储器。它是微程序控制器的核心部件，用于存放各指令对应的微程序。  

$\textcircled{4}$ 微指令寄存器。其位数等于微指令字长。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/99c89003cac2ee2ef59dde11e4b8aa32720bdbcf83de761ecb39fd778d602223.jpg)  
图5.11微程序控制器的基本结构  

（2）微程序控制器的工作过程  

实际上就是在微程序控制器的控制下计算机执行机器指令的过程，这个过程可描述为：  

$\textcircled{\scriptsize{1}}$ 执行取指令公共操作。在机器开始运行时，自动地将取指微程序的入口地址送入 $\upmu\mathrm{PC}$ 并从CM中读出相应的微指令并送入 $\upmu\mathrm{IR}$ 。取指微程序的入口地址一般为CM的O号单元，取指微程序执行完成后，从主存中取出的机器指令就已存入指令寄存器中。 $\circledcirc$ 由机器指令的操作码字段通过微地址形成部件产生该机器指令所对应的微程序的入口地址，并送入 $\upmu\mathrm{PC}$  $\textcircled{3}$ 从CM中逐条取出对应的微指令并执行。 $\textcircled{4}$ 执行完对应于一条机器指令的一个微程序后，又回到取指微程序的入口地址，继续第 $^\mathrm{(Q)}$ 步，以完成取下一条机器指令的公共操作。以上是一条机器指令的执行过程，如此周而复始，直到整个程序执行完毕。  

# （3）微程序和机器指令  

通常，一条机器指令对应一个微程序。由于任何机器指令的取指令操作都是相同的，因此可将取指令操作的微命令统一编成一个微程序，这个微程序只负责将指令从主存单元中取出并送至指令寄存器。此外，也可编写出对应间址周期的微程序和中断周期的微程序。这样，控制存储器中的微程序个数应为机器指令数再加上对应取指、间址和中断周期等公共的微程序数。  

# 3.微指令的编码方式  

微指令的编码方式也称微指令的控制方式，是指如何对微指令的控制字段进行编码，以形成控制信号。编码的目标是在保证速度的情况下，尽量缩短微指令字长。  

（1）直接编码（直接控制）方式  

微指令的直接编码方式如图5.12所示。直接编码法无须进行译码，微指令的操作控制字段中每一位都代表一个微命令。设计微指令时，选用或不选用某个微命令，只要将表示该微命令的对应位设置成1或0即可。每个微命令对应并控制数据通路中的一个微操作。  

这种编码的优点是简单、直观，执行速度快，操作并行性好；缺点是微指令字长过长， $n$ 个微命令就要求微指令的操作字段有 $n$ 位，造成控制存储器容量极大。  

（2）字段直接编码方式  

>#### pro：字段直接控制的编码方法（2012）  

将微指令的操作控制字段分成若干小字段，把互斥性微命令放在同一字段中，把相容性微命令放在不同字段中，每个字段独立编码，每种编码代表一个微命令且各字段编码含义单独定义，与其他字段无关，这就是字段直接编码方式，如图5.13所示。这种方式可以缩短微指令字长，但因为要通过译码电路后再发出微命令，因此比直接编码方式慢。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c6e197e941e2f1058a37b511cbaa37823f47acc90dd408d7e4f2e9e15c655007.jpg)  
图5.12直接编码方式  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a8f2b917f211c35fb07f59a18310c4809c207a77d2f9e952f169ab68cecd9625.jpg)  
图5.13字段直接编码方式  

微命令字段分段的原则：  

$\textcircled{\scriptsize{1}}$ 互厅性微命令分在同一段内，相容性微命令分在不同段内。  

$\circledcirc$ 每个小段中包含的信息位不能太多，否则将增加译码电路的复杂性和译码时间。  

$\textcircled{3}$ 一般每个小段还要留出一个状态，表示本字段不发出任何微命令。因此，当某字段的长度为3位时，最多只能表示7个互斥的微命令，通常用000表示不操作。  

（3）字段间接编码方式  

一个字段的某些微命令需由另一个字段中的某些微命令来解释，由于不是靠字段直接译码发出的微命令，因此称为字段间接编码，也称隐式编码。这种方式可进一步缩短微指令字长，但因削弱了微指令的并行控制能力，因此通常作为字段直接编码方式的一种辅助手段。  

# 4.微指令的地址形成方式  

后继微地址的形成主要有以下几个基本类型：  

1）由微指令的后继地址字段（也称下地址字段）指出。在微指令格式中设置一个后继地址字段，由微指令的后继地址字段直接指出后继微指令的地址，这种方式也称断定方式。  

2）根据机器指令的操作码形成。当机器指令取自指令寄存器后，微指令的地址由操作码经微地址形成部件形成，该部件输出的是对应机器指令微程序的首地址。  

3）增量计数器法，即 $(\upmu\mathrm{PC})+1{\rightarrow}\upmu\mathrm{PC}$ ，适用于后继微指令地址是连续的情况。  

4）根据各种标志决定下一条微指令分支转移的地址  

5）由硬件直接产生微程序入口地址。电源加电后，第一条微指令的地址可由专门的硬件电路产生，并送至 $\upmu\mathrm{PC}$ ，这个地址即为取指周期微程序的入口地址。  

# 5.微指令的格式  

微指令格式与微指令的编码方式有关，通常分为水平型微指令和垂直型微指令两种。  

>#### pro： 微指令后继地址字段位数与微指令条数的关系（2014）  

（1）水平型微指令  

从编码方式看，直接编码、字段直接编码和字段间接编码都属于水平型微指令。水平型微指令的基本指令格式如图5.14所示，指令字中的一位对应一个控制信号，有输出时为1，否则为0。一条水平型微指令定义并执行多个并行操作的微命令。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b2aedaa58c557759dbd6b0fe7d9c754a7d34a84fc4317965518d9de55c2fb6a1.jpg)  

水平型微指令的优点是微程序短，并行能力强，执行速度快；缺点是微指令长，编写微程序较麻烦。  

（2）垂直型微指令  

采用类似机器指令操作码的方式，在微指令字中设置微操作码字段，垂直型微指令的基本格式如图5.15所示。一条垂直型微指令通常只能定义并执行一种微命令。  
图5.15垂直型微指令格式
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7065d0c6793931c03ff4fb46419e81a29e8a05e3dc173555b1f656c5aa397918.jpg)  

垂直型微指令的优点是微指令短、简单、规整，便于编写微程序：缺点是微程序长，执行速 度慢，效率低。  

水平型微指令和垂直型微指令的比较如下：  

$\textcircled{\scriptsize{1}}$ 水平型微指令并行操作能力强、效率高、灵活性强：垂直型微指令则较差。 $\circledcirc$ 水平型微指令执行一条指令的时间短；：垂直型微指令执行的时间长。 $\textcircled{3}$ 用水平型微指令编写的微程序，微指令字较长但微程序短；垂直型微指令正好相反。 $\textcircled{4}$ 水平型微指令难以掌握；而垂直型微指令与机器指令比较相似，相对容易掌握。  

# 6.硬布线和微程序控制器的特点  

>#### pro：硬布线控制器和微程序控制器的特点（2009）  

（1）硬布线控制器的特点  

硬布线控制器的优点是由于控制器的速度取决于电路延迟，所以速度快；缺点是由于将控制部件视为专门产生固定时序控制信号的逻辑电路，所以把用最少元件和取得最高速度作为设计自标，一旦设计完成，就不可能通过其他额外修改添加新功能。  

（2）微程序控制器的特点  

相比组合逻辑控制器，微程序控制器的优点是具有规整性、灵活性和可维护性；缺点是由于微程序控制器采用了存储程序原理，所以每条指令都要从控制存储器中取一次，影响速度。  

为便于比较，下面以表格的形式对比二者的不同，见表5.1。  

表5.1微程序控制器与硬布线控制器的对比
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5758d88c281f323689f1a57cbe9859540b34d296985c6fd404c91be129bd19f0.jpg)  


# 5.5异常和中断机制  

现代计算机中都配有完善的异常和中断处理系统，CPU的数据通路中有和应的异常检测和响应逻辑，外设接口中有相应的中断请求和控制逻辑，操作系统中有相应的中断服务程序。这些中断硬件电路和中断服务程序有机结合，共同完成异常和中断的处理过程。  

# 5.5.1异常和中断的基本概念  

# 异常事件的性质（2015）  

由CPU内部产生的意外事件被称为异常，有些教材中也称内中断。由来自CPU外部的设备向CPU发出的中断请求被称为中断，通常用于信息的输入和输出，有些教材中也称外中断。异常是CPU执行一条指令时，由CPU在其内部检测到的、与正在执行的指令相关的同步事件；中断是一种典型的由外部设备触发的、与当前正在执行的指令无关的异步事件。  

>#### pro：异常响应的时机（2023）  

异常和中断处理过程的描述如下：若CPU在执行用户程序的第 $i$ 条指令时检测到一个异常事件，或者执行第 $i$ 条指令后发现一个中断请求信号，则CPU打断当前程序，然后转去执行相应的异常或中断处理程序。若异常或中断处理程序能够解决相应的问题，则在异常或中断处理程序的最后，CPU通过执行异常或中断返回指令，回到被打断的用户程序的第 $i$ 条指令或第 $i+1$ 条指令继续执行；若异常或中断处理程序发现是不可恢复的致命错误，则终止用户程序。通常情况下，对异常和中断的具体处理过程由操作系统（和驱动程序）完成。  

异常和中断的处理过程基本是相同的，这也是有些教材将两者统称为中断的原因  

# 5.5.2异常和中断的分类  

# 1．异常的分类  

异常是由CPU内部产生的意外事件，分为硬故障中断和程序性异常。硬故障中断是由硬连线出现异常引起的，如存储器校验错、总线错误等。程序性异常也称软件中断，是指在CPU内部因执行指令而引起的异常事件。如整除0、溢出、断点、单步跟踪、非法指令、栈溢出、地址越界、缺页等。按异常发生原因和返回方式的不同，可分为故障、自陷和终止。  

（1）故障（Fault）  

>#### pro：异常或中断处理后指令重新执行的断点（2021）  

指在引起故障的指令启动后、执行结束前被检测到的异常事件。例如，指令译码时，出现“非法操作码”；取数据时，发生“缺段”或“缺页”执行整数除法指令时，发现“除数为0”等。  
对于“缺段”“缺页”等异常事件，经处理后，可将所需的段或页面从磁盘调入主存，回到发生故障的指令继续执行，断点为当前发生故障的指令；对于“非法操作码”“除数为0”等，因为无法通过异常处理程序恢复故障，因此不能回到原断点执行，必须终止进程的执行。  

(2）自陷（Trap）  

>#### pro：自陷的原理和性质（2020）  

自陷也称陷阱或陷入，它是预先安排的一种“异常”事件，就像预先设定的“陷阱”一样。通常的做法是：事先在程序中用一条特殊指令或通过某种方式设定特殊控制标志来人为设置一个“陷阱”，当执行到被设置了“陷阱”的指令时，CPU在执行完自陷指令后，自动根据不同“陷阱”类型进行相应的处理，然后返回到自陷指令的下一条指令执行。注意，当自陷指令是转移指令时，开不是返回到下一条指令执行，而是返回到转移目标指令执行。  

在x86机器中，用于程序调试“断点设置”和单步跟踪的功能就是通过陷阱机制实现的。此外，系统调用指令、条件自陷指令（如MiPS中的teq、teqi、tne、tnei等）等都属于陷阱指令，执行到这些指令时，无条件或有条件地自动调出操作系统内核程序进行执行。  

故障异常和自陷异常属于程序性异常（软件中断）。  

（3）终止（Abort）  

如果在执行指令的过程中发生了使计算机无法继续执行的硬件敌障，如控制器出错、存储器校验错、总线错误等，那么程序将无法继续执行，只能终止，此时，调出异常服务程序来重启系统。这种异常与敌障和自陷不同，不是由特定指令产生的，而是随机发生的。  

终止异常和外中断属于硬件中断。  

# 2.中断的分类  

>#### pro：对中断和异常事件的判断（2009、2016、2020）  

中断是指来自CPU外部、与CPU执行指令无关的事件引起的中断，包括I/O设备发出的I/O中断（如键盘输入、打印机缺纸等），或发生某种特殊事件（如用户按Esc键、定时器计数时间到）等。外部I/O设备通过特定的中断请求信号线向CPU提出中断请求，CPU每执行完一条指令就检查中断请求信号线，如果检测到中断请求，则进入中断响应周期。  

中断可分为可屏蔽中断和不可屏蔽中断。  

# （1）可屏蔽中断  

指通过可屏蔽中断请求线INTR向CPU发出的中断请求。CPU可以通过在中断控制器中设置相应的屏蔽字来屏蔽它或不屏蔽它，被屏蔽的中断请求将不被送到CPU。  

# （2）不可屏蔽中断  

指通过专门的不可屏蔽中断请求线NMI向CPU发出的中断请求，通常是非常紧急的硬件故障，如电源掉电等。这类中断请求信号不可被屏蔽，以让CPU快速处理这类紧急事件。  

中断和异常在本质上是一样的，但它们之间有以下两个重要的不同点：  

1）“缺页”或“溢出”等异常事件是由特定指令在执行过程中产生的，而中断不和任何指令相关联，也不阻止任何指令的完成。  

2）异常的检测由CPU自身完成，不必通过外部的某个信号通知CPU。对于中断，CPU必须通过中断请求线获取中断源的信息，才能知道哪个设备发生了何种中断。  
此外，根据识别中断服务程序地址的方式，可分为向量中断和非向量中断：根据中断处理过程是否允许被打断，还可分为单重中断和多重中断。  

# 5.5.3异常和中断响应过程  

CPU执行指令时，如果发生了异常或中断请求，必须进行相应的处理。从CPU检测到异常或中断事件，到调出相应的处理程序，整个过程称为异常和中断响应。CPU对异常和中断响应的过程可分为关中断、保存断点和程序状态、识别异常和中断并转到相应的处理程序。  

（1）关中断  

在保存断点和程序状态期间，不能被新的中断打断，因此要禁止响应新的中断，即关中断。通常通过设置“中断允许”（IF）触发器来实现，若IF置为1，则为开中断，表示允许响应中断；若F置为0，则表示关中断，表示不充许响应中断。  

（2）保存断点和程序状态  

为了能在异常和中断处理后正确返回到被中断的程序继续执行，必须将程序的断点（返回地址）送到栈或特定寄存器中。通常保存在栈中，这是为了支持异常或中断的嵌套。  

异常和中断处理后可能还要回到被中断的程序继续执行，被中断时的程序状态字寄存器PSW的内容也需要保存在栈或特定寄存器中，在异常和中断返回时恢复到PSW中。  

（3）识别异常和中断并转到相应的处理程序  

异常和中断源的识别有软件识别和硬件识别两种方式。异常和中断源的识别方式不同，异常大多采用软件识别方式，而中断可以采用软件识别方式或硬件识别方式。  

软件识别方式是指CPU设置一个异常状态寄存器，用于记录异常原因。操作系统使用一个统一的异常或中断查询程序，按优先级顺序查询异常状态寄存器，以检测异常和中断类型，先查询到的先被处理，然后转到内核中相应的处理程序。  

硬件识别方式也称向量中断，异常或中断处理程序的首地址称为中断向量，所有中断向量都存放在中断向量表中。每个异常或中断都被指定一个中断类型号。在中断向量表中，类型号和中断向量一一对应，因而可以根据类型号快速找到对应的处理程序。  

整个响应过程是不可被打断的。中断响应过程结束后，CPU就从PC中取出对应中断服务程序的第一条指令开始执行，直至中断返回，这部分任务是由CPU通过执行中断服务程序完成的，整个中断处理过程是由软/硬件协同实现的。  
 

# 5.6指令流水线  

前面介绍的指令都是在单周期处理机中采用串行方法执行的，同一时刻CPU中只有一条指令在执行，因此各功能部件的使用率不高。现代计算机普遍采用指令流水线技术，同一时刻有多条指令在CPU的不同功能部件中并发执行，大大提高了功能部件的并行性和程序的执行效率。  

# 5.6.1指令流水线的基本概念  

可从两方面提高处理机的并行性： $\textcircled{\scriptsize{1}}$ 时间上的并行技术，将一个任务分解为几个不同的子阶段，每个子阶段在不同的功能部件上并行执行，以使在同一时刻能够同时执行多个任务，进而提升系统性能，这种方法被称为流水线技术。 $\circledcirc$ 空间上的并行技术，在一个处理机内设置多个执行相同任务的功能部件，并让这些功能部件并行工作，这样的处理机被称为超标量处理机。  

一条指令的执行过程可分解为若干阶段，每个阶段由相应的功能部件完成。如果将各阶段视为相应的流水段，则指令的执行过程就构成了一条指令流水线。  

假设一条指令的执行过程分为如下5个阶段（也称功能段或流水段）?：  

·取指（IF）：从指令存储器或Cache中取指令。·译码/读寄存器（ID）：操作控制器对指令进行译码，同时从寄存器堆中取操作数。·执行/计算地址（EX）：执行运算操作或计算地址。·访存（MEM）：对存储器进行读/写操作。·写回（WB）：将指令执行结果写回寄存器堆。  
把 $k+1$ 条指令的取指阶段提前到第 $k$ 条指令的译码阶段，从而将第 $k+1$ 条指令的译码阶段与第 $k$ 条指令的执行阶段同时进行，如图5.16所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4e4d3b2fd28bf010d15ebe5c04890299db4e9d522cfa5616dd58c870df156a3c.jpg)  
图5.16一个5段指令流水线  

从图5.16看出，理想情况下，每个时钟周期都有一条指令进入流水线，每个时钟周期都有一条指令完成，每条指令的时钟周期数（即CPI）都为1。  

>#### pro：流水线对指令集的要求（2011）  

为了利于实现指令流水线，指令集应具有如下特征：  

1）指令长度应尽量一致，有利于简化取指令和指令译码操作。否则，取指令所花的时间长短不一，使得取指部件极其复杂，并且也不利于指令译码。  

2）指令格式应尽量规整，尽量保证源寄存器的位置相同，有利于在指令未知时就可取寄存器操作数，否则须译码后才能确定指令中各寄存器编号的位置。  

3）采用LOAD/STORE型指令，其他指令都不能访问存储器，这样可把LOAD/STORE指令的地址计算和运算指令的执行步骤规整在同一个周期中，有利于减少操作步骤。  

4）数据和指令在存储器中“按边界对齐”存放。这样，有利于减少访存次数，使所需数据在一个流水段内就能从存储器中得到。  

# 5.6.2流水线的基本实现  

# 1.流水线设计的原则  

在单周期实现中，虽然不是所有指令都必须经历完整的5个阶段，但只能以执行速度最慢的指令作为设计其时钟周期的依据，单周期CPU的时钟频率取决于数据通路中的最长路径。  

>#### pro：流水线时钟周期的设计（2009）  

流水线设计的原则： $\textcircled{\scriptsize{1}}$ 指令流水段个数以最复杂指令所用的功能段个数为准： $\circledcirc$ 流水段的长度以最复杂的操作所花的时间为准。假设某条指令的5个阶段所花的时间分别如下。 $\textcircled{\scriptsize{1}}$ 取指： $200\mathrm{ps}$ ； $\circledcirc$ 译码： $100\mathrm{ps}$  $\textcircled{3}$ 执行： $150\mathrm{ps}$  $\textcircled{4}$ 访存： $200\mathrm{ps}$ ； $\textcircled{5}$ 写回： $100\mathrm{ps}$ ，该指令的总执行时间为750ps。按照流水线设计原则，每个流水段的长度为 $200\mathrm{ps}$ ，所以每条指令的执行时间为1ns，反而比串行执行时增加了 $250\mathrm{ps}$ 。假设某程序有 $N$ 条指令，单周期处理机所用的时间为 $N{\times}750\mathrm{ps}$ 而流水线处理机所用的时间为 $(N+4){\times}200\mathrm{ps}$ 。由此可见，流水线方式并不能缩短单条指令的执行时间，但对于整个程序来说，执行效率得到了大幅提高。  

# 2.流水线的逻辑结构  

每个流水段后面都要增加一个流水段寄存器，用于锁存本段处理完的所有数据，以保证本段的执行结果能在下个时钟周期给下一流水段使用，如图5.17所示。各种寄存器和数据存储器均采用统一时钟CLK进行同步，每来一个时钟，各段处理完的数据都将锁存到段尾的流水段寄存器中，作为后段的输入。同时，当前段也会收到前段通过流水段寄存器传递过来的数据。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/15dad3e9b41ca386ed07524528163648ddba3b917ff3c224e8e9b044083935c5.jpg)  
图5.17流水线的逻辑结构图  

一条指令会依次进入IF、ID、EX、MEM、WB五个功能段进行处理，第一条指令进入WB段后，各流水段都包含一条不同的指令，流水线中将同时存在5条不同的指令并行执行。  

>#### pro： 存在流水段寄存器时延的时钟周期的设计（2018）  

# 注意  

在考试中，若没有明确说明，则可以不用考虑流水寄存器的时延。  

# 3.流水线的时空图表示  

通常用时空图来直观地描述流水线的执行情况，如图5.18所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8f92b2589c2fe4694603f3c9894919d540ed16f5065d6218d79024a19ab46846.jpg)  
图5.18一个5段指令流水线时空图  

在时空图中，横坐标表示时间，它被分割成长度相等的时间段 $T$ ；纵坐标为空间，表示当前指令所处的功能部件。在图5.18中，第一条指令 $\mathrm{I}_{1}$ 在时刻0进入流水线，在时刻5T流出流水线。第二条指令 $\mathrm{I}_{2}$ 在时刻 $T$ 进入流水线，在时刻6T流出流水线。以此类推，每隔一个时间 $T$ 就有一条指令进入流水线，从时刻5T开始每隔一个时间  $T$  就有一条指令流出流水线。  

>#### pro：流水线执行4条指令所需的时钟周期数（2012）  

从图5.18中可看出，在时刻 $10T$ 时，流水线上便有6条指令流出。若采用串行方式执行，在时刻10T时，只能执行2条指令，可见使用流水线方式成倍地提高了计算机的速度。  

只有大量连续任务不断输入流水线，才能充分发挥流水线的性能，而指令的执行正好是连续不断的，非常适合采用流水线技术。对于其他部件级流水线，如浮点运算流水线，同样也仅适合于提升浮点运算密集型应用的性能，对于单个运算是无法提升性能的。  

# 5.6.3流水线的冒险与处理  

>#### pro：导致流水线阻塞的各种原因（2010）  

在指令流水线中，可能会遇到一些情况使得后续指令无法正确执行而引起流水线阻塞，这利现象称为流水线冒险。根据导致冒险的原因不同分为结构冒险、数据冒险和控制冒险3种。  

不同类型指令在各流水段的操作是不同的，表5.2中列出了几类指令在各流水段中的操作。  
表5.2不同类型指令在各流水段中的操作
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0e6ae322ef1d230d3622eda619a0b7d751d40c5ad99cf6bbc3f88c1bdf5ad624.jpg)  

这几类指令将会在下面介绍流水线冲突时涉及。  

# 1.结构冒险  

>#### pro：解决结构冒险的办法（2016）  

由不同指令在同一时刻争用同一功能部件而形成的冲突，也称资源冲突，即由硬件资源竞争造成的冲突。例如，指令和数据通常都存放在同一存储器中，在第4个时钟周期，第i条LOAD指令进入MEM段时，第 $i+3$ 条指令的F段也要访存取指令，此时会发生访存冲突，为此可在前一条指令访存时，暂停（一个时钟周期）取后一条指令的操作，如表5.3所示。当然，如果第 $i$ 条指令不是LOAD指令，在IMEM段不访存，也就不会发生访存冲突。  

表5.3用暂停后续指令的方法解决访存冲突
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2db4430898a15d3389f6aa6bbb2b0286feb1c27b0fc3560cab05120628e43091.jpg)  

解决结构冲突有以下两种办法：  

1）前一指令访存时，使后一条相关指令（及其后续指令）暂停一个时钟周期。  

2）设置多个独立的部件。例如，对于寄存器访问冲突，可将寄存器的读口和写口独立开来：对于访存冲突，单独设置数据存储器和指令存储器。在现代Cache机制中，L1级Cache通常采用数据Cache和指令Cache分离的方式，从而也就避免了资源冲突的发生。  

# 2.数据冒险  

>#### pro：分析指令之间的数据冒险（2012、2014、2016、2019、2023）  

数据冒险也称数据相关。引起数据冒险的原因是，后面指令用到前面指令的结果时，前面指令的结果还没有产生。在以非乱序执行的流水线中，所有数据冒险都是由于前面指令写结果之前，后面指令就需要读取而造成的，这种数据冒险称为写后读（ReadAfterWrite，RAW）冲突。  

# 注意  

在按序执行?的流水线中（统考中通常采用这种方式），只可能出现RAW冲突。  
例如，考虑下列两条指令：  

I1 addR1,R2,R3 I2 sub R4,R1,R5 #（R2）+（R3）→R1

 #（R1)-（R5）→R4 在写后读（RAW）冲突中，指令I2的源操作数是指令I1的目的操作数。正常的读/写顺序是  

由指令IⅡ1先写入R1，再由指令12来读R1。在非流水线中，这种先写后读的顺序是自然维持的。但在流水线中，由于重叠操作，读/写的先后顺序关系发生了变化，如表5.4所示。  

表5.4add和sub指令发生先写后读（RAW）冲突
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/416a1a3afa37aaf5df2546bab8ffd540b1a22415785989ec06871e8242ff2a92.jpg)  

可以采用以下几种办法解决RAW数据冲突。  

（1）延迟执行相关指令  

把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行，可分为软件插入空操作“nop”指令和硬件阻塞（stall）两种方法。  

由表5.4可见，在第5个时钟周期，add指令才将运算结果写入Rl，但后继sub指令在第3个时钟周期就要从R1中读数，使先写后读的顺序改变为先读后写，发生了先写后读（RAW）的数据冲突。如果不采取措施，按表5.4的读/写顺序，就会导致结果出错。为此，可以暂停sub指令3个时钟周期，直至前面add指令的结果生成，如表5.5所示。  

表5.5用延迟相关指令的办法来解决RAW冲突
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/83b58f5125520e327f2952f138d8b8e3e1c011a0b53539439425dabca2d3aec6.jpg)  

对于11和12的数据相关问题，还可以通过将寄存器的写口和读口分别控制在前、后半个时钟周期内操作，使前半周期写入R1的值在后半周期马上被读出，在一个周期内读/写寄存器不会产生冲突，这样I1的WB段和I2的ID段就可重叠执行，从而只需延迟2个时钟周期。  

# （2）采用转发（旁路）技术  

设置相关转发通路，不等前一条指令把计算结果写回寄存器，下一条指令也不再从寄存器读，而将数据通路中生成的中间数据直接转发到ALU的输入端。如表5.6所示，指令I1在EX段结束时已得到R1的新值，被存放到EX/MEM流水段寄存器中，因此可以直接从该流水段寄存器中取出数据返送到ALU的输入端，这样，在指令I2执行时ALU中用的就是R1的新值。  

表5.6用转发技术来解决RAW冲突
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6e66822789ad2aac996fbfbdb4f43c39d585688d099743e0d47d9ac80812a914.jpg)  

增加转发通路后，相邻两条运算类指令之间、相隔一条的两个运算类指令之间的数据相关带来的数据冒险问题就都能解决了。  
（3）load-use数据冒险的处理  

如果1oad指令与其后紧邻的运算类指令存在数据相关问题，则无法通过转发技术来解决，通常把这种情况称为load-uise数据冒险。对于下列两条指令，由表5.2可知，load指令只有在MEM段结束时才能得到主存中的结果，然后送MEM/WB流水段寄存器，在WB段的前半周期才能存入R2的新值，但随后的add指令在EX阶段就要取R2的值，因此，得到的是旧值。  

I2 load r2,12(r1) #M[（r1)+12]→（r2) I3 add r4,r3,r2 #  $(\mathfrak{r}3)+(\mathfrak{r}2)\to(\mathfrak{r}4)$  

对于load-use数据冒险，最简单的做法是由编译器在add指令之前插入一条nop指令，这样在add指令的EX段就可以从MEM/WB流水段寄存器中取出load指令的最新结果，如表5.7所示。当然，最好的办法是在程序编译时进行优化，通过调整指令顺序以避免出现load-use现象。  

表5.7用延迟加转发技术来解决load-use冲突
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d8f74604a1f7296c5efc84ccc1b539219931dc8dd2633e2e187d4d2cf904438d.jpg)  

# 3.控制冒险  

>#### pro：分析指令之间的控制冒险（2014、2023）  

指令通常是顺序执行的，但当遇到改变指令执行顺序的情况，例如执行转移或返回指令、发生中断或异常时，会改变PC值，从而造成断流，也称控制冲突。  

对于由转移指令引起的冲突，最简单的处理方法就是推迟后续指令的执行。通常把因流水线阻塞带来的延迟时钟周期数称为延迟损失时间片 $C$ 。在下列指令中，假设R2存放常数N，R1的初值为1，bne指令在EX段通过计算设置条件码，并在MEM段确定是否将PC值更新为转移目的地址，因此仅当bne指令执行到第5个时钟结束时才能将转移目标地址送PC。为此，在数据通路检测到分支指令后，可以在分支指令后插入 $C$ (此处 $C=3$ ）条nop指令，如表5.8所示。  

I1loop:add Rl,Rl, $\#\left(\mathbb{R}\mathbb{1}\right)+\mathbb{1}\!\rightarrow\!\mathbb{R}\mathbb{1}$ I2 bne R1,R2,loop #if(R1)  $!=(\mathbb{R}^{2}$  ）goto loop  

表5.8用插入空操作的办法解决控制冲突
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5d0c7063bc5e9cb5cf392f3925551cca3ebbfb37ad2e468043801a4c994d2fcf.jpg)  

有以下几种办法解决控制冲突：  

1）对于由转移指令引起的冲突，可采用和解决数据冲突相同的软件插入“nop”指令和硬件阻塞（stall）的方法。比如，延迟损失多少时间片，就插入多少条nop指令。  

2）对转移指令进行分支预测，尽早生成转移目标地址。分支预测分为简单（静态）预测和动态预测。若静态预测的条件总是不满足，则按序继续执行分支指令的后续指令。动态 预测根据程序转移的历史情况，进行动态预测调整，有较高的预测准确率。  

# 注意  

Cache缺失的处理过程也会引起流水线阻塞。  
# 5.6.4 流水线的性能指标  

1.流水线的吞吐率>#### pro：  

流水线吞吐率的计算（2013）  

流水线的吞吐率是指在单位时间内流水线所完成的任务数量，或输出结果的数量。流水线吞吐率（TP）的最基本公式为  

$$
\mathrm{TP}\,{=}\,\frac{n}{T_{k}}
$$  

式中， $n$ 是任务数， $T_{k}$ 是处理完 $n$ 个任务所用的总时间。设 $k$ 为流水段的段数， $\Delta t$ 为时钟周期。在输入流水线中的任务连续的理想情况下，一条 $k$ 段流水线能在 $k+n-1$ 个时钟周期内完成 $n$ 个任务。得出流水线的吞吐率为  

$$
\mathrm{TP}=\frac{n}{(k+n-1)\Delta t}
$$  

连续输入的任务数 $n{\rightarrow}\infty$ 时，得到最大吞吐率为 $\mathrm{TP}_{\mathrm{max}}\,{=}1/\Delta t$  

# 2.流水线的加速比  

完成同样一批任务，不使用流水线与使用流水线所用的时间之比。  

流水线加速比（S）的基本公式为  

$$
S=\frac{T_{0}}{T_{k}}
$$  

式中， $T_{0}$ 表示不使用流水线的总时间： $T_{k}$ 表示使用流水线的总时间。一条 $k$ 段流水线完成 $n$ 个任务所需的时间为 $T_{k}=\left(k+n-1\right)\Delta t$ 。顺序执行 $n$ 个任务时，所需的总时间为 $T_{0}=\left\boldsymbol{k n}\,\Delta t\right.$ 。将 $T_{0}$ 和 $T_{k}$ 值代入上式，得出流水线的加速比为  

$$
S=\frac{k n\Delta t}{(k+n-1)\Delta t}\!=\!\frac{k n}{k+n-1}
$$  

连续输入的任务数 $n{\rightarrow}\infty$ 时，得最大加速比为 $S_{\mathrm{max}}\,{=}\,k,$  

# 5.6.5高级流水线技术  

有两种增加指令级并行的策略：一种是多发射技术，它通过采用多个内部功能部件，使流水线功能段能同时处理多条指令，处理机一次可以发射多条指令进入流水线执行：另一种是超流水线技术，它通过增加流水线级数来使更多的指令同时在流水线中重叠执行。  

# 1.超标量流水线技术  

>#### pro：  

也称动态多发射技术，每个时钟周期内可并发多条独立指令，以并行操作方式将两条或多条指令编译并执行，为此需配置多个功能部件，如图5.19所示。在简单的超标量CPU中，指令是按顺序发射执行的。为了更好地提高并行性能，多数超标量CPU都结合动态流水线调度技术，通过动态分支预测等手段，指令不按顺序执行，这种方式称为乱序执行。  

# 2.超长指令字技术  

也称静态多发射技术，由编译程序挖掘出指令间潜在的并行性，将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字（可达几百位），为此需要采用多个处理部件。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3fb915064ad6368ced430ed580e5bb36216c80da07ef16f0bb6a2923dd9be00f.jpg)  
图5.19超标量流水线技术  

# 3.超流水线技术  

如图5.20所示，流水线功能段划分得越多，时钟周期就越短，指令吞吐率也就越高，因此超流水线技术是通过提高流水线主频的方式来提升流水线性能的。但是，流水线级数越多，用于流水寄存器的开销就越大，因而流水线级数是有限制的，并不是越多越好。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/742aac8f955fdb4c6ca794363252545db1e5f37ff8e48bc846bf71986d0fa0d6.jpg)  
图5.20超流水线技术  

>#### pro：基本流水线CPU和超标量流水线CPU的CPI（2020）  

超流水线CPU在流水线充满后，每个时钟周期还是执行一条指令， ${\mathrm{CPI}}=1$ ，但其主频更高：多发射流水线CPU每个时钟周期可以处理多条指令， $\mathrm{CPI}\!<\!1$ ，但其成本更高、控制更复杂。  

 
# 5.7多处理器的基本概念  

>#### pro： 多处理器的基本概念（2022）  

# 5.7.1SISD、SIMD、MIMID的基本概念  

基于指令流的数量和数据流的数量，将计算机体系结构分为SISD、SIMD、MISD和MIMD四类。常规的单处理器属于SISD，而常规的多处理器属于MIMD。  

# 1.单指令流单数据流（SISD）结构  

SISD是传统的事行计算机结构，这种计算机通常仅包含一个处理器和一个存储器，处理器在一段时间内仅执行一条指令，按指令流规定的顺序串行执行指令流中的若干指令。为了提高速度，有些SISD计算机采用流水线的方式，因此，SISD处理器有时会设置多个功能部件，并且采用多模块交叉方式组织存储器。本书前面介绍的内容多属于SISD结构。  

# 2.单指令流多数据流（SIMID）结构  

SIMID是指一个指令流同时对多个数据流进行处理，一般称为数据级并行技术。这种结构的计算机通常由一个指令控制部件、多个处理单元组成。每个处理单元虽然执行的都是同一条指令，但是每个单元都有自己的地址寄存器，这样每个单元就都有不同的数据地址，因此，不同处理单元执行的同一条指令所处理的数据是不同的。一个顺序应用程序被编译后，既可能按SISD组织并运行于事行硬件上，又可能按SIMID组织并运行于并行硬件上。  

SIMD在使用for循环处理数组时最有效，比如，一条分别对16对数据进行运算的SIMID指令如果在16个ALU中同时运算，则只需要一次运算时间就能完成运算。SIMD在使用case或switch语句时效率最低，此时每个执行单元必须根据不同的数据执行不同的操作。  

# 3.多指令流单数据流（MISD）结构  

MISD是指同时执行多条指令，处理同一个数据，实际上不存在这样的计算机。  

# 4.多指令流多数据流（MIIMID）结构  

MIMD是指同时执行多条指令分别处理多个不同的数据，MIMID分为多计算机系统和多处理器系统。多计算机系统中的每个计算机节点都具有各自的私有存储器，并且具有独立的主存地址空间，不能通过存取指令来访问不同节点的私有存储器，而要通过消息传递进行数据传送，也称消息传递MIIMID。多处理器系统是共享存储多处理器（SMP）系统的简称，它具有共享的单一地址空间，通过存取指令来访问系统中的所有存储器，也称共享存储MIIMID。  

向量处理器是SIMID的变体，是一种实现了直接操作一维数组（向量）指令集的CPU，而串行处理器只能处理单一数据集。其基本理念是将从存储器中收集的一组数据按顺序放到一组向量寄存器中，然后以流水化的方式对它们依次操作，最后将结果写回寄存器。向量处理器在特定工作环境中极大地提升了性能，尤其是在数值模拟或者相似的领域中。  

SIMD和MIMD是两种并行计算模式，其中SIIMD是一种数据级并行模式，而MIMD是一种并行程度更高的线程级并行或线程级以上并行计算模式。  
# 5.7.2硬件多线程的基本概念  

在传统CPU中，线程的切换包含一系列开销，频繁地切换会极大影响系统的性能，为了减少线程切换过程中的开销，便诞生了硬件多线程。在支持硬件多线程的CPU中，必须为每个线程提供单独的通用寄存器组、单独的程序计数器等，线程的切换只需激活选中的寄存器，从而省略了与存储器数据交换的环节，大大减少了线程切换的开销。  

硬件多线程有3种实现方式：细粒度多线程、粗粒度多线程和同时多线程（SMT）。  

# 1.细粒度多线程  

多个线程之间轮流交叉执行指令，多个线程之间的指令是不相关的，可以乱序并行执行。在这种方式下，处理器能在每个时钟周期切换线程。例如，在时钟周期i，将线程A中的多条指令发射执行；在时钟周期 $\mathrm{i}+1$ ，将线程B中的多条指令发射执行。  

# 2.粗粒度多线程  

连续几个时钟周期都执行同一线程的指令序列，仅在当前线程出现了较大开销的阻塞时，才切换线程，如Cache缺失。在这种方式下，当发生流水线阻塞时，必须清除被阻塞的流水线，新线程的指令开始执行前需要重载流水线，因此，线程切换的开销比细粒度多线程更大。  

上述两种多线程技术都实现了指令级并行，但线程级不并行。  

# 3.同时多线程  

同时多线程（SMT）是上述两种多线程技术的变体。它在实现指令级并行的同时，实现线程级并行，也就是说，它在同一个时钟周期中，发射多个不同线程中的多条指令执行。  

图5.21分别是三种硬件多线程实现方式的调度示例。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/fe12e3816bacd5ce1624427dc34539902f856a1a779a1dfcb27e86ac5ec6d5bd.jpg)  

Intel处理器中的超线程（Hyper-threading）就是同时多线程SMT，即在一个单处理器或单个核中设置了两套线程状态部件，共享高速缓存和功能部件。  

# 5.7.3多核处理器的基本概念  

多核处理器是指将多个处理单元集成到单个CPU中，每个处理单元称为一个核（core），通常也称片上多处理器。每个核既可以有自己的Cache，又可以共享同一个Cache，所有核通常共享主存储器。图5.22是一个不共享Cache的双核CPU结构。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4e190cda79c5d3789bba4003dd4e0cf2eedc2899411a4baf8ced7fc668357302.jpg)  
图5.22不共享Cache的双核CPU结构  

在多核计算机系统中，如要充分发挥硬件的性能，必须采用多线程（或多进程）执行，使得每个核在同一时刻都有线程在执行。与单核上的多线程不同，多核上的多个线程是在物理上并行执行的，是真正意义上的并行执行，在同一时刻有多个线程在并行执行。而单核上的多线程是一种多线程交错执行，实际上在同一时刻只有一个线程在执行。  

下面通过一个例子来理解相关的概念。假设要将四颗圆石头滚到马路对面，滚动每颗石头平均需花费1分钟。串行处理器会逐一滚动每颗石头，花费4分钟。拥有两个核的多核处理器让两个人滚石头，即每人滚两颗，花费2分钟。向量处理器找到一根长木板，放在四颗石头后面，推动木板即可同时滚动四块石头，理论上只要力量够大，就只需要1分钟。多核处理器相当于拥有多名工人，而向量处理器拥有一种方法，可以同时对多件事进行相同的操作。  

# 5.7.4共享内存多处理器的基本概念  

具有共享的单一物理地址空间的多处理器称为共享内存多处理器（SIMIP）。处理器通过存储器中的共享变量互相通信，所有处理器都能通过存取指令访问存储器的任何位置。注意，即使这些系统共享同一个物理地址空间，它们仍然可在自己的虚拟地址空间中单独地运行程序。  

单一地址空间的多处理器有两种类型：  

·统一存储访问（UMA）多处理器。每个处理器对所有存储单元的访问时间是大致相同的，即访问时间与哪个处理器提出访存请求及访问哪个字无关。·非统一存储访问（NUMA）多处理器。某些存储器的访存速度要比其他的快，具体取决于哪个处理器提出访问请求及访问哪个字，这是由于主存被分割分配给了不同处理器。  

早期的计算机，内存控制器没有整合进CPU，访存操作需要经过北桥芯片（集成了内存控制器，并与内存相连），CPU通过前端总线和北桥芯片相连，这就是统一存储访问（UMA）构架。随着CPU性能提升由提高主频转到增加CPU数量（多核、多CPU），越来越多的CPU对前端总线的争用使得前端总线成为瓶颈。为了消除UMA架构的瓶颈，非统一存储访问（NUMA）构架诞生，内存控制器被集成到CPU内部，每个CPU都有独立的内存控制器。每个CPU都独立连接到一部分内存，CPU直连的这部分内存被称为本地内存。CPU之间通过QPI总线相连。CPU可以通过QPI总线访问其他CPU的远程内存。与UMA架构不同的是，在NUMA架构下，内存的访问出现了本地和远程的区别，访问本地内存明显要快于访问远程内存。  

由于可能会出现多个处理器同时访问同一共享变量的情况，在操作共享变量时需要进行同步，否则，一个处理器可能会在其他处理器尚未完成对共享变量的修改时，就开始使用该变量。常用方法是通过对共享变量加锁的方式来控制对共享变量互斥访问。在一个时刻只能有一个处理器获得锁，其他需要操作该共享变量的处理器必须等待，直到该处理器解锁该变量为止。  
第3章讨论的一致性是指Cache与主存之间的数据一致性。在UMA构架的多处理器中，所有CPU共享同一内存空间，每个CPU的Cache都是共享内存中的一部分副本，因此多核系统的Cache一致性既包括Cache和内存之间的一致性，还包括各CPU的Cache之间的一致性，也就是说，对内存同一位置的数据，不同CPU的Cache不应该有不一致的内容。  


# 5.8 本章小结  

本章开头提出的问题的参考答案如下。  

1）指令和数据均存放在内存中，计算机如何从时间和空间上区分它们是指令还是数据？  

从时间上讲，取指令事件发生在“取指周期”，取数据事件发生在“执行周期”。从空间上讲，从内存读出的指令流流向控制器（指令寄存器），从内存读出的数据流流向运算器（通用寄存器）  

2）什么是指令周期、机器周期和时钟周期？它们之间有何关系？  

CPU每取出并执行一条指令所需的全部时间称为指令周期；机器周期是在同步控制的机器中，执行指令周期中一步相对完整的操作（指令步）所需的时间，通常安排机器周期长度 $=$ 主存周期；时钟周期是指计算机主时钟的周期时间，它是计算机运行时最基本的时序单位，对应完成一个微操作所需的时间，通常时钟周期 $=$ 计算机主频的倒数。  
3）什么是微指令？它和第4章谈到的指令有什么关系？  

控制部件通过控制线向执行部件发出各种控制命令，通常把这种控制命令称为微命令，而一组实现一定操作功能的微命令的组合，构成一条微指令。许多条微指令组成的序列构成微程序， 微程序完成对指令的解释执行。指令，即指机器指令。每条指令可以完成一个独立的算术运算或逻辑运算操作。在采用微程序控制器的CPU中，一条指令对应一个微程序，一个微程序由许多微指令构成，一条微指令会发出很多不同的微命令。  

4）什么是指令流水线？指令流水线相对于传统体系结构的优势是什么？  

指令流水线是把指令分解为若干子过程，通过将每个子过程与其他子过程并行执行，来提高计算机的吞吐率的技术。采用流水线技术只需增加少量硬件就能把计算机的运算速度提高几倍，因此成为计算机中普遍使用的一种并行处理技术，通过在同一个时间段使用各功能部件，使得利用率明显提高。  

# 5.9常见问题和易混淆知识点  

1.流水线越多，并行度就越高。是否流水段越多，指令执行越快？  

错误，原因如下：  

1）流水段缓冲之间的额外开销增大。每个流水段有一些额外开销用于缓冲间传送数据、进行各种准备和发送等功能，这些开销加长了一条指令的整个执行时间，当指令间逻辑上相互依赖时，开销更大。  

2）流水段间控制逻辑变多、变复杂。用于流水线优化和存储器（或寄存器）冲突处理的控制逻辑将随流水段的增加而大增，这可能导致用于流水段之间控制的逻辑比段本身的控制逻辑更复杂。  

2.读后写（WAR）相关和写后写（WAW）相关的概念  

1）读后写（WriteAfterRead，WAR）冲突。表示当前指令读出数据后，下一条指令才能写该寄存器。否则，先写后读，读到的就是错误（新）数据。在下列指令中，寄存器R1可能存在这样的冲突，当指令12试图在指令Ⅱ1读R1之前就写入该寄存器时，指令I1就错误地读出该寄存器新的内容。  

I1 add R3,R1,R2  $\begin{array}{r l}{\#\left(\mathbb{R}{1}\right)+\left(\mathbb{R}{2}\right)\rightarrow\mathbb{R}{3}}&{{}}\\ {\#\left(\mathbb{R}{4}\right)-\left(\mathbb{R}{5}\right)\rightarrow\mathbb{R}{1}}&{{}}\end{array}$  I2 sub R1,R4,R5  

在读后写（WAR）冲突中，指令I2的目的操作数是指令I1的源操作数。  

3）写后写（WriteAfterWrite，WAW）相关。表示当前指令写入寄存器后，下一条指令才能写该寄存器。否则，下一条指令在当前指令之前写，将使寄存器的值不是最新值。在下列指令中，寄存器RI可能存在这样的冲突，当指令I2试图在指令I1之前就写入R1时，就会错误地使由指令11写入的值成为该寄存器的内容。  

I1 add R1,R2,R3  $\begin{array}{r}{\#\left(\mathbb{R}2\right)+\left(\mathbb{R}3\right)\rightarrow\mathbb{R}1}\\ {\#\left(\mathbb{R}4\right)-\left(\mathbb{R}5\right)\rightarrow\mathbb{R}1}\end{array}$  I2 sub R1,R4,R5  

在写后写（WAW）冲突中，指令I2和指令I1的目的操作数是相同的。  

# 注意  

在非按序执行的流水线中，因为允许后进入流水线的指令超过先进入流水线的指令而先流出流水线，所以既可能发生RAW相关，又可能发生WAR和WAW相关。  
# 第6章总线  

# 【考纲内容】  

总线的基本概念总线的组成及性能指标总线事务和定时  

# 【复习提示】  

本章的知识点较少，通常以选择题的形式出现，特别是总线的特点、猝发传输方式、性能指标、定时方式及常见的总线标准等。总线带宽的计算也可能结合其他章节出综合题。  

在学习本章时，请读者思考以下问题  

1）引入总线结构有什么好处？2）引入总线结构会导致什么问题？如何解决？请读者在学习本章的过程中寻找答案，本章末尾会给出参考答案。  

# 6.1总线概述  

早期计算机的各部件之间是通过单独的连线互连的，这种方式称为分散连接。但是，随着1/O设备的种类和数量越来越多，为了更好地解决1/O设备和主机之间连接的灵活性，计算机的结构从分散连接发展为总线连接。为了进一步简化设计，又提出了各类总线标准。  

# 6.1.1总线基本概念  

# 1.总线的定义  

总线是一组能为多个部件分时和共享的公共信息传送线路。分时和共享是总线的两个特点。分时是指同一时刻只充许有一个部件向总线发送信息，若系统中有多个部件，则它们只能分时地尚总线发送信息。共享是指总线上可以挂接多个部件，各个部件之间互相交换的信息都可通过这组线路分时共享，多个部件可同时从总线上接收相同的信息。  

2.总线设备  

总线上所连接的设备，按其对总线有无控制功能可分为主设备和从设备两种。  

主设备：指发出总线请求且获得总线控制权的设备。从设备：指被主设备访问的设备，它只能响应从主设备发来的各种总线命令。  

3.总线特性  

总线特性是指机械特性（尺寸、形状）、电气特性（传输方向和有效的电平范围）、功能特性（每根传输线的功能）和时间特性（信号和时序的关系）  
# 6.1.2总线的分类  

# 1.按功能层次分类  

>#### pro： 总线相关的概念与特点（2016、2017）  

1）片内总线。芯片内部的总线，用于CPU芯片内部各寄存器之间及寄存器与ALU的连接。  

2）系统总线。计算机系统内各功能部件（CPU、主存、I/O接口）之间相互连接的总线。按系统总线传输信息内容的不同，又可分为3类：数据总线、地址总线和控制总线。  

>#### pro：数据总线上传输的内容（2011）  

$\textcircled{\scriptsize{1}}$ 数据总线用来在各部件之间传输数据、指令和中断类型号等，它是双向传输总线，数据总线的位数反映一次能传送的数据的位数。 $\circledcirc$ 地址总线用来指出数据总线上源数据或目的数据所在的主存单元或 $\mathrm{I}/\mathrm{O}$ 端口的地址，它是单向传输总线，地址总线的位数反映最大的寻址空间。 $\textcircled{3}$ 控制总线用来传输各种命令、反馈和定时信号，典型的控制信号包括时钟、复位、总线请求/充许、中断请求/回答、存储器读/写、1/0读、1/O写、传输确认等。  

注意区分数据通路和数据总线：各个功能部件通过数据总线连接形成的数据传输路径称为数据通路。数据通路表示的是数据流经的路径，而数据总线是数据传输的媒介。  

3）1/0总线。主要用于连接中低速的1/0设备，通过1/0接口与系统总线相连接，目的是将低速设备与高速总线分离，以提升总线的系统性能，常见的有USB、PCI总线。  

4）通信总线。计算机系统之间或计算机系统与其他系统（如远程通信设备、测试设备）之间传送信息的总线，通信总线也称外部总线。  

2.按时序控制方式分类  

1）同步总线。总线上连接的部件或设备通过统一的时钟进行同步，在规定的时钟节拍内进行规定的总线操作，来完成部件或设备之间的信息传输。  

2）异步总线。总线上连接的部件或设备没有统一的时钟，而以信号握手的方式来协调各部件或设备之间的信息传输，总线操作时序不是固定的。  

3.按数据传输方式分类  

1）串行总线。只有一条双向传输或两条单向传输的数据线，数据按比特位串行顺序传输，其效率低于并行总线。串行传输对数据线的要求不太高，因此适合长距离通信。  

2）并行总线。有多条双向传输的数据线，可以实现多比特位的同时传输，其效率比串行总线更高。缺点是各条数据线的传输特点可能存在一些差异，比如有的信息位可能会延迟，并且数据线之间相互干扰还会造成传输错误，因此并行总线适合近距离通信。  

# 注意  

并行总线并不一定总比串行总线快，它们适合不同的场景。并行总线由于是多个数据位同时传输，需要考虑数据的协同性，以及线路之间的相互干扰，导致工作频率无法持续提高。而串行总线可通过不断提高工作频率来提高传输速度，使其速度最终超越并行总线的速度。  
# 6.1.3系统总线的结构  

# 1.单总线结构  

单总线结构将CPU、主存、I/O设备（通过1/O接口）都挂在一组总线上，充许I/O设备之间、I/O设备与主存之间直接交换信息，如图6.1所示。CPU与主存、CPU与外设之间都可以通过总线直接进行信息交换，而无须经过中间设备的干预。需要注意的是，单总线并不是指只有一根信号线，系统总线按传送信息的不同可细分为地址总线、数据总线和控制总线。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a8b75e0bcbcbe7c1e22d71e2fa26222c4fe36d1dfe9f77fe38f2dbbcd9c3075a.jpg)  
图6.1单总线结构  

优点：结构简单，成本低，易于接入新的设备。缺点：带宽低、负载重，多个部件只能争用唯一的总线，且不支持并发传送操作  

# 2.双总线结构  

双总线结构有两条总线：一条是主存总线，用于在CPU、主存和通道之间传送数据；另一条是1/0总线，用于在多个外部设备与通道之间传送数据，如图6.2所示。  

优点：将低速I/O设备从原单总线上分离出来，实现了存储器总线和1/O总线分离。  

缺点：需要增加通道等硬件设备。  

# 3.三总线结构  

三总线结构是在计算机系统各部件之间采用3条各自独立的总线来构成信息通路，这三条总线分别为主存总线、I/O总线和直接内存访问（DMA）总线，如图6.3所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d7065d4dc41e8445bd893d3f0057b7a4fbb7dfb06e816e4830f2970c62d12561.jpg)  
图6.2双总线结构  

主存总线用于在CPU和内存之间传送地址、数据和控制信息。I/O总线用于在CPU和各类外设之间通信。DMA总线用于在内存和高速外设之间直接传送数据。  

优点：提高了I/O设备的性能，使其更快地响应命令，提高系统吞吐量。缺点：任意时刻只能使用一种总线，系统工作效率较低。  

#  $^{*}6.1.4$ 常见的总线标准  

总线标准是国际上公布的互连各个模块的标准，是把各种不同的模块组成计算机系统时必须遵守的规范。IS A、EISA、VESA、PCI、AGP、PCI-ExpresS、USB 等。它们的主要区别是总线宽度、带宽、时钟频率、寻址能力、是否支持突发传送等。  
>#### pro：总线标准的英文缩写（2010）  

1）ISA，Industry Standard Architecture，工业标准体系结构。最早出现的系统总线，缺点是传输速率低、CPU占用率高、占用硬件中断资源。它属于系统总线、并行总线。  

2）EISA，Extended Industry Standard Architecture，扩展的ISA。E IS A和突发传送，EISA对ISA完全兼容。它属于系统总线、并行总线。  

>#### pro：区分设备总线和局部总线（2013）  

3）VESA，Video Electronics Standards Association，视频电子标准协会。是一个32位的局部总线，是针对多媒体PC要求高速传送活动图像的大量数据而推出的。它属于局部总线、并行总线。局部总线是在ISA总线和CPU总线之间增加的一级总线或管理层，这样就可将一些高速外设（如图形卡、硬盘控制器、网卡等）从ISA总线上卸下，而通过局部总线直接挂接到CPU总线上，使之能与高速CPU总线相匹配。4）PCI，Peripheral Component Interconnect，外部设备互连。32 64，目前常用的PCI适配器有显卡、声卡、网卡等。PCI总线是一个与处理器时钟频率无关的高速外围总线，支持即插即用。它属于局部总线、并行总线。5）AGP，AcceleratedGraphicsPort，加速图形接口。是一种视频接口标准，专用于连接主存和图形卡，用于传输视频和三维图形数据。它属于局部总线、并行总线。  

>#### pro：PCI-E总线的特点（2017）  

6）PCI-E，PCI-ExpreSS。高速串行双通道传输，其传输速率远高于PCI和AGP，且支持双向传输模式，还可以支持全双工模式。它属于局部总线、事行总线。7）RS-232C。应用于串行二进制交换的数据终端设备（DTE）和数据通信设备（DCE）之间的标准接口。它属于设备总线、串行总线。  

>#### pro：USB总线的特点（2012）  

8）USB，UniversalSerialBus，通用串行总线。一种连接外部设备的I/O总线，具有即插即用、热插拔等优点，有很强的连接能力。它属于设备总线、串行总线。9）PCMCIA，Personal Computer Memory Card International Association。应用于笔记本电脑的接口标准，通常用于扩展功能，具有即插即用功能。它属于设备总线、并行总线。10）IDE，Integrated Drive Electronics，集成设备电路。更准确地称为ATA，硬盘和光驱通过IDE接口与主板连接。它属于设备总线、并行总线。11）SCSI，Small Computer System Interface，小型计算机系统接口。一种用于计算机和周边设备之间（硬盘等）系统级接口的独立处理器标准。它属于设备总线、并行总线。12）SATA，Serial Advanced Technology Attachment，串行高级技术附件。一种基于行业标准的串行硬件驱动器接口。它属于设备总线、串行总线。  

6.1.5 总线的性能指标  

1）总线时钟周期。即机器的时钟周期。计算机有一个统一的时钟，以控制整个计算机的各个部件，总线也要受此时钟的控制。2）总线时钟频率。即机器的时钟频率，它为时钟周期的倒数。  
3）总线传输周期。指一次总线操作所需的时间，包括申请阶段、寻址阶段、传输阶段和结束阶段。总线传输周期通常由若干总线时钟周期构成。4）总线工作频率。总线上各种操作的频率，为总线周期的倒数。实际上指1秒内传送几次数据。若总线周期 $=N$ 个时钟周期，则总线的工作频率 $=$ 时钟频率/N：此外，若一个时钟周期可以传送 $K$ 次数据，则总线工作频率是总线时钟频率的 $K$ 倍。5）总线宽度。总线宽度也称总线位宽，是总线上能够同时传输的数据位数，通常指数据总线的根数，如32根称为32位总线。  

>#### pro：总线带宽的相关计算（2009、2013、2014、2019、2020）  

6）总线带宽。单位时间内总线上最多可传输数据的位数，通常用每秒传送信息的字节数来衡量，单位可用字节/秒（B/s）表示。总线带宽 $=$ 总线工作频率 $\times($ (总线宽度/8）。7）总线复用。总线复用是指一种信号线在不同的时间传输不同的信息。例如，有些总线没有单独的地址线，地址信息通过数据线来传送，这种情况称为地址/数据线复用。因此可以使用较少的线传输更多的信息，从而节省空间和成本。8）信号线数。地址总线、数据总线和控制总线3种总线数的总和称为信号线数。  

>#### pro：提高总线带宽的办法（2018）  

其中，总线最主要的性能指标为总线宽度、总线工作频率、总线带宽。总线带宽是指总线的最大数据传输速率，它是衡量总线性能的重要指标。三者的关系：总线带宽 $=$ 总线宽度 $\times$ 总线工作频率。例如，总线工作频率为22MHz，总线宽度为16位，则总线带宽 $\scriptstyle=22\mathbf{M}\times(16/8)=44\mathbf{M}\mathrm{B/s}$  

# 6.2 总线事务和定时  

# 6.2.1总线事务  

从请求总线到完成总线使用的操作序列称为总线事务，它是在一个总线周期中发生的一系列活动。典型的总线事务包括请求操作、仲裁操作、地址传输、数据传输和总线释放。  

1）请求阶段。主设备（CPU或DMA）发出总线传输请求，并且获得总线控制权。2）仲裁阶段。总线仲裁机构决定将下一个传输周期的总线使用权授予某个申请者。3）寻址阶段。主设备通过总线给出要访问的从设备地址及有关命令，启动从模块。4）传输阶段。主模块和从模块进行数据交换，可单向或双向进行数据传送，5）释放阶段。主模块的有关信息均从系统总线上撤除，让出总线使用权。  

>#### pro：非突发传送的时间分析（2023）  

总线上的数据传送方式分为非突发方式和突发方式两种。非突发传送方式在每个传送周期内都先传送地址，再传送数据，主、从设备之间通常每次只能传输一个字长的数据。  

>#### pro：突发传送的概念（2014），突发传送的时间分析（2012、2013）  

突发（发）传送方式能够进行连续成组数据的传送，其寻址阶段发送的是连续数据单元的首地址，在传输阶段传送多个连续单元的数据，每个时钟周期可以传送一个字长的信息，但是不释放总线，直到一组数据全部传送完毕后，再释放总线。  

# 6.2.2总线定时  

总线定时是指总线在双方交换数据的过程中需要时间上配合关系的控制，这种控制称为总线定时，其实质是一种协议或规则，主要有同步、异步、半同步和分离式四种定时方式。  

>#### pro：各种总线定时方式的特点（2015、2021）  

# 1.同步定时方式  

所谓同步定时方式，是指系统采用一个统一的时钟信号来协调发送和接收双方的传送定时关系。时钟产生相等的时间间隔，每个间隔构成一个总线周期。在一个总线周期中，发送方和接收方可以进行一次数据传送。因为采用统一的时钟，每个部件或设备发送或接收信息都在固定的总线传送周期中，一个总线的传送周期结束，下一个总线的传送周期开始。  

优点：传送速度快，具有较高的传输速率：总线控制逻辑简单。缺点：主从设备属于强制性同步：不能及时进行数据通信的有效性检验，可靠性较差同步通信适用于总线长度较短及总线所接部件的存取时间比较接近的系统。  

同步串行通信方式是发送方时钟直接控制接收方时钟，使双方完全同步的一种逐位传输的通信方式。使用同步串行通信时，由于收发双方的时钟严格一致，因此仅在数据块的头尾处添加了开始和结束标记，传输效率较高，但实现的硬件设备也更复杂，所以较少采用。  

# 2.异步定时方式  

在异步定时方式中，没有统一的时钟，也没有固定的时间间隔，完全依靠传送双方相互制约的“握手”信号来实现定时控制。通常，主设备提出交换信息的“请求”信号，经接口传送到从设备；从设备接到主设备的请求后，通过接口向主设备发出“回答”信号。  
优点：总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换，自动适应时间的配合。  

缺点：比同步控制方式稍复杂一些，速度比同步定时方式慢。根据“请求”和“回答”信号的撤销是否互锁，异步定时方式又分为以下3种类型。  

1）不互锁方式。主设备发出“请求”信号后，不必等到接到从设备的“回答”信号，而是经过一段时间便撤销“请求”信号。而从设备在接到“请求”信号后，发出“回答”信号，并经过一段时间后自动撤销“回答”信号。双方不存在互锁关系，如图6.4(a)所示。  

2）半互锁方式。主设备发出“请求”信号后，必须在接到从设备的“回答”信号后，才撤销“请求”信号，有互锁的关系。而从设备在接到“请求”信号后，发出“回答”信号，但不必等待获知主设备的“请求”信号已经撤销，而是隔一段时间后自动撤销“回答”信号，不存在互锁关系。半互锁方式如图6.4(b)所示。  

3）全互锁方式。主设备发出“请求”信号后，必须在从设备“回答”后才撤销“请求”信号；从设备发出“回答”信号后，必须在获知主设备“请求”信号已撤销后，再撤销其“回答”信号。双方存在互锁关系，如图6.4（c)所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e30f9589c45b2a57c15931e592518bb215f20b47d5abf20d0fd0e062b8376d2f.jpg)  
图6.4请求和回答信号的互锁  

>#### pro：异步串行通信方式的特点（2016）  

现在越来越多的总线采用异步串行通信方式，使用异步串行通信时，由于收发双方时钟不严格一致，因此每个字符都要用开始位和停止位作为字符开始和结束的标志，从而保证数据传输的准确性。异步事行通信的第一位是开始位，表示字符传送的开始。当通信线上没有数据传送时处于逻辑“1”状态，当发送方要发送一个字符时，首先发出一个逻辑“0”信号，即开始位。接收方检测到这个逻辑低电乎后，就开始准备接收数据位。在字符传送过程中，数据位从最低位开始，一位一位地传输。当字符发送完后，就可以发送奇偶校验位（可选），以用于有限的差错检测。在奇偶位或数据位之后发送的是停止位，表示一个字符数据的结束。  

# 3.半同步定时方式  

半同步定时方式保留了同步定时的特点，如所有地址、命令、数据信号的发出时间都严格参照系统时钟的某个前沿开始，而接收方都采用系统时钟后沿时刻来进行判断识别：同时，又像异步定时那样，允许不同速度的设备和谐地工作。为此增设一条Wait响应信号线。例如，某个半同步总线总是从某个时钟开始，在每个时钟到来时，采样Wait信号，若无效，则说明数据未准备好，下个时钟到来时，再采样Wait信号，直到检测到有效，再去数据线上取数据。半同步定时适用于系统工作速度不高，但又包含了由许多速度差异较大的各类设备组成的简单系统。  

优点：控制方式比异步定时简单，各模块在系统时钟的控制下同步工作，可靠性较高。缺点：系统时钟频率不能要求太高，所以从整体上来看，系统工作的速度不是很高。  

以上三种定时方式都从主设备发出地址和读/写命令开始，直到数据传输结束，在整个传输周期中，总线的使用权完全由主设备及由其选中的从设备占据。其实，从设备在准备数据的阶段，总线纯属空闲等待，为进一步挖掘总线的潜力，又提出了分离式定时方式。  
# 4.分离式定时方式  

分离式定时方式将总线事务分解为请求和应答两个子过程。在第一个子过程中，主设备A获得总线使用权后，将命令、地址等信息发到总线上，经总线传输后由从设备B接收。此过程占用总线的时间很短，主设备一且发送完，立即释放总线，以便其他设备使用。在第二个子过程中，设备B收到设备A发来的有关命令后，将设备A所需的数据准备好后，便由设备B申请总线使用权，一旦获准，设备B便将相应的数据送到总线上，由设备A接收。上述两个子过程都只有单方向的信息流，每个设备都变为主设备。  

优点：在不传送数据时释放总线，使总线可接受其他设备的请求，不存在空闲等待时间  

缺点：控制复杂，开销也大。  


# 6.3 本章小结  

本章开头提出的问题的参考答案如下。  

1）引入总线结构有什么好处？  

引入总线结构主要有以下优点： $\textcircled{\scriptsize{1}}$ 简化了系统结构，便于系统设计制造。 $\circledcirc$   $\textcircled{3}$ 便于接口设计，所有与总线连接的设备均采用类似的接口。 $\textcircled{4}$ 便于系统的扩充、更新与灵活配置，易于实现系统的模块化。 $\circledast$ 便于设备的软件设计，所有接口的软件对不同的接口地址进行操作。 $^\mathrm{\textregistered}$ 便于故障诊断和维修，同时也能降低成本。  

2）引入总线会导致什么问题？如何解决？  

引入总线后，总线上的各个设备分时共享同一总线，当总线上多个设备同时请求使用总线时就会导致冲突。为解决多个设备同时竞争总线控制权的问题，应当采用总线仲裁部件，以某种方式选择一个主设备获得总线控制权，只有获得了总线控制权的设备才能开始数据传送。  

# 6.4常见问题和易混淆知识点  

1.一个总线在某一时刻可以有多对主从设备进行通信吗？  

不可以。在某个总线周期内，总线上只有一个主设备控制总线，选择一个从设备与之进行通信（即一对一的关系），或对所有设备进行广播通信（即一对多的关系）。所以一个总线在某一时刻不能有多对主从设备进行通信，否则会发生数据冲突。  
# 第7章输入/输出系统  

# 【考纲内容】  

（一）I/O接口（I/O控制器）I/O接口的功能和基本结构；1/O端口及其编址  

（二）10方式  

程序查询方式程序中断方式：中断的基本概念；中断响应过程；中断处理过程：多重中断和中断屏蔽的概念 DMA方式：DMA控制器的组成：DMA传送过程  

# 【复习提示】  

1/O方式是本章的重点和难点，每年不仅会以选择题的形式考查基本概念和原理，而且可能会以综合题的形式考查，特别是各种17O方式效率的相关计算，中断方式的各种原理、特点、处理过程、中断屏蔽，DMA方式的特点、传输过程、与中断方式的区别等。  

在学习本章时，请读者思考以下问题：1）I/O设备有哪些编址方式？各有何特点？2）CPU响应中断应具备哪些条件？请读者在学习本章的过程中寻找答案，本章末尾将给出参考答案。  

#  $\mathbf{\lambda}^{*7.1}$ I/O系统基本概念  

#  $^{*7.1.1}$ 输入/输出系统  

输入/输出是以主机为中心而言的，将信息从外部设备传送到主机称为输入，反之称为输出。输入/输出系统解决的主要问题是对各种形式的信息进行输入和输出的控制。  

I/O系统中的几个基本概念如下：  

1）外部设备。包括输入/输出设备及通过输入/输出接口才能访问的外存储设备。2）接口。在各个外设与主机之间传输数据时进行各种协调工作的逻辑部件。协调包括传输过程中速度的匹配、电平和格式转换等。3）输入设备。用于向计算机系统输入命令和文本、数据等信息的部件。键盘和鼠标是最基本的输入设备。  
4）输出设备。用于将计算机系统中的信息输出到计算机外部进行显示、交换等的部件。显示器和打印机是最基本的输出设备。  

5）外存设备。指除计算机内存及CPU缓存等外的存储器，如硬磁盘、光盘等。一般来说，1/O系统由1/O软件和I/O硬件两部分构成：  

$\mathrm{I}/\mathrm{O}$  指令实现CPU与I/O设备的信息交换。2）I/O硬件。包括外部设备、设备控制器和接口、I/0总线等。通过设备控制器来控制I/O设备的具体动作；通过1/0接口与主机（总线）相连。  

#  $^{*7.1.2}$ 1/0控制方式  

在输入/输出系统中，经常需要进行大量的数据传输，而传输过程中有各种不同的1/O控制方式，基本的控制方式主要有以下四种：  

1）程序查询方式。由CPU通过程序不断查询I/O设备是否已做好准备，从而控制I/O设备与主机交换信息。2）程序中断方式。只在I/O设备准备就绪并向CPU发出中断请求时才予以响应。3）DMA方式。主存和I/O设备之间有一条直接数据通路，当主存和I/O设备交换信息时，无须调用中断服务程序。4）通道方式。在系统中设有通道控制部件，每个通道都挂接若干外设，主机在执行I/0命令时，只需启动有关通道，通道将执行通道程序，从而完成I/O操作。其中，方式1和方式2主要用于数据传输速率较低的外部设备，方式3和方式4主要用于数居传输速率较高的设备。  

#  $\mathbf{\ast7.1}\mathbf{.3}$ 外部设备  

最基本的外部设备主要有键盘、鼠标、显示器、打印机、磁盘存储器和光盘存储器等。  

# 1.输入设备  

（1）键盘 键盘是最常用的输入设备，通过它可发出命令或输入数据。  

(2）鼠标 鼠标是常用的定位输入设备，它把用户的操作与计算机屏幕上的位置信息相联系。  

# 2.输出设备  

（1）显示器  

（LED）显示器等。显示器属于用点阵方式运行的设备，有以下主要参数。1）屏幕大小：以对角线长度表示，单位为英寸，常用的有 $12\!\sim\!32$ 英寸等。2）分辨率：能表示的像素个数，屏幕上的每个光点就是一个像素，以宽和高的像素数的乘积表示，如 $800{\times}600$ 、 $1024\!\times\!768$ 和 $1280\!\times\!1024$ 等。3）灰度级：指黑白显示器中所显示的像素点的亮暗差别，在彩色显示器中则表现为颜色的不同，灰度级越多，图像层次越清楚、逼真，典型的有8位（256级）、16位等。4）刷新：光点只能保持极短的时间便会消失，为此必须在光点消失之前再重新扫描显示一遍，这个过程称为刷新。5）刷新频率：指单位时间内扫描整个屏幕内容的次数。按照人的视觉生理，刷新频率大于 $30\mathrm{Hz}$ 时才不会感到闪烁，通常显示器的刷新频率为 $60{\sim}120\mathrm{Hz}$  
6）显示存储器（VRAM）：也称刷新存储器，为了不断提高刷新图像的信号，必须把一帧图像信息存储在刷新存储器中。其存储容量由图像分辨率和灰度级决定，分辨率越高，灰度级越多，刷新存储器容量越大。  

VRAM容量 $=$ 分辨率×灰度级位数VRAM带宽  $=$  分辨率×灰度级位数×帧频  

（2）打印机  

用于将计算机的处理结果打印在相关介质上。按工作方式，打印机可分为点阵打印机、针式  

打印机、喷墨式打印机、激光打印机等。1）针式打印机。针式打印机擅长“多层复写打印”，实现各种票据或蜡纸等的打印。其工作原理简单，造价低廉，耗材（色带）便宜，但打印分辨率和打印速度不够高。2）喷墨式打印机。彩色喷墨打印机基于三基色原理，即分别喷射三种颜色的墨滴，按一定的比例混合出所要求的颜色。喷墨式打印机可实现高质量彩色打印。3）激光打印机。计算机输出的二进制信息，经过调制后转换为激光束，在感光鼓上形成潜像，再经过显影、转印和定影，在纸上得到所需的字符或图像。激光打印机打印质量高、速度快、处理能力强，它是将激光技术和电子显像技术相结合的产物。  

3.外部存储器（辅存）  

（1）磁表面存储器  

所谓“磁表面存储”，是指把某些磁性材料薄薄地涂在金属铝或塑料表面上作为载磁体来存储信息。磁盘存储器、磁带存储器和磁鼓存储器均属于磁表面存储器。  

（2）固态硬盘（SSD）  

微小型高档笔记本电脑采用高性能Flash存储器作为硬盘来记录数据，这种“硬盘”称为固态硬盘（SSD）。固态硬盘除需要Flash存储器外，还需要其他硬件和软件的支持。  

（3）光盘存储器  

光盘存储器是利用光学原理读/写信息的存储装置，它采用聚焦激光束对盘式介质以非接触方式记录信息。完整的光盘存储系统由光盘片、光盘驱动器、光盘控制器等组成。  


# 7.2I/O 接口  

1/0接口（也称1/O控制器）是主机和外设之间的交接界面，通过接口可以实现主机和外设之向的信息交换。外设种类繁多，且具有不同的工作特性，它们在工作方式、数据格式和工作速度等方面有着很大的差异，接口正是为了解决这些差异而设置的。  

# 7.2.1I/O接口的功能  

>#### pro：I/O接口的定义与特性（2021）  

I/O接口的主要功能如下：  

1）进行地址译码和设备选择。CPU送来选择外设的地址码后，接口必须对地址进行译码以2）实现主机和外设的通信联络控制。解决主机与外设时序配合问题，协调不同工作速度的外设和主机之间交换信息，以保证整个计算机系统能统一、协调地工作。3）实现数据缓冲。CPU与外设之间的速度往往不匹配，为消除速度差异，接口必须设置数据缓冲寄存器，用于数据的暂存，以避免因速度不一致而丢失数据。4）信号格式的转换。外设与主机两者的电平、数据格式都可能存在差异，接口应提供主机与外设的信号格式的转换功能，如电平转换、并/串或串/并转换、模/数或数/模转换等。  

5）传送控制命令和状态信息。CPU要启动某外设时，通过接口中的命令寄存器向外设发出启动命令；外设准备就绪时，则将“准备好”状态信息送回接口中的状态寄存器，并反馈给CPU。外设向CPU提出中断请求时，CPU也应有相应的响应信号反馈给外设。  

# 7.2.2I/O接口的基本结构  

>#### pro：I/O端口与CPU交换的内容（2015）图7.1所示是一个I/O接口的通用结构，I/O接口在主机侧通过 $\mathrm{I}/\mathrm{O}$ 总线与内存、CPU相连。  
数据缓冲寄存器用来暂存与CPU或内存之间传送的数据信息，状态寄存器用来记录接口和设备的状态信息，控制寄存器用来保存CPU对外设的控制信息。状态寄存器和控制寄存器在传送方向上是相反的，在访问时间上也是错开的，因此可将它们合二为一。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/75e5c6546b9bbbf454e784b0b1efb00c038b494907e65ad7039f2432158a0fc4.jpg)  
图7.1I/0接口的通用结构  

>#### pro：I/O接口的数据线上传输的内容（2012）  

I/O接口中的数据线传送的是读/写数据、状态信息、控制信息和中断类型号。地址线传送的是要访问I/O接口中的寄存器的地址。控制线传送的是读/写控制信号，以确认是读寄存器还是写寄存器，此外控制线还会传送中断请求和响应信号、仲裁信号和握手信号。  

1/0接口中的1/O控制逻辑还要能对控制寄存器中的命令字进行译码，并将译码得到的控制信号通过外设界面控制逻辑送到外设，同时将数据缓冲寄存器的数据发送到外设或从外设接收数据到数据缓冲寄存器。另外，它还要具有收集外设状态到状态寄存器的功能。  

对数据缓冲寄存器、状态/控制寄存器的访问操作是通过相应的指令来完成的，通常称这类指令为I/O指令，1/O指令只能在操作系统内核的底层1/O软件中使用，它们是一种特权指令。  

# 7.2.3I/O接口的类型  

从不同的角度看，1/0接口可以分为不同的类型。  

1）按数据传送方式（外设和接口一侧），可分为并行接口（一字节或一个字的所有位同时传送）和串行接口（一位一位地有序传送），接口要完成数据格式的转换。2）按主机访问I/O设备的控制方式，可分为程序查询接口、中断接口和DMA接口等。3）按功能选择的灵活性，可分为可编程接口（通过编程改变接口功能）和不可编程接口。  

# 7.2.41/O端口及其编址  

>#### pro：I/O端口的定义及相关特性（2014）  

I/O端口是指I/O接口电路中可被CPU直接访问的寄存器，主要有数据端口、状态端口和控制端口。通常，CPU能够对数据端口中的数据进行读/写操作；但对状态端口中的外设状态只能进行读操作，对控制端口中的各种控制命令只能进行写操作。  

# 注意  

端口和接口是两个不同的概念，端口是指接口电路中可以进行读/写的寄存器。  
I/O端口要想能够被CPU访问，就必须要对各个端口进行编址，每个端口对应一个端口地址。而对I/O端口的编址方式有与存储器独立编址和统一编址两种。  

（1）独立编址  

>#### pro：I/O指令的作用（2017）  

独立编址也称1/O映射方式，是指对所有的1/0端口单独进行编址。1/0端口的地址空间与主存地址空间是两个独立的地址空间，它们的范围可以重叠，相同地址可能属于不同的地址空间。因此需设置专门的1/O指令来表明访向的是1/0地址空间，1/0指令的地址码给出1/O端口号。  

优点：1/0端口数比主存单元数少得多，只需少量地址线，使得1/O端口译码简单，寻址速度更快。使用专用1/O指令，可使得程序更加清晰，便于理解和检查。  

缺点：I/O指令少，只提供简单的传输操作，所以程序设计的灵活性较差。此外，CPU需要提供存储器读/写、I/O设备读/写两组控制信号，增大了控制的复杂性。  

(2）统一编址  

统一编址也称存储器映射方式，是指把主存地址空间分出一部分给I/O端口进行编址，I/O端口和主存单元在同一地址空间的不同分段中，根据地址范围就能区分访问的是1/O端口还是主存单元，因此无须设置专门的1/O指令，用统一的访存指令就可访问1/0端口。  

优点：不需要专门的IO指令，使得CPU访问I/O的操作更加灵活和方便，还使端口有较大的编址空间。1/O访问的保护机制可由虚拟存储管理系统来实现，无须专门设置。  

缺点：端口地址占用了部分主存地址空间，使主存可用容量变小。此外，由于在识别1/O端口时全部地址线都需要参加译码，使得译码电路变得更复杂，降低了译码速度。  
 

# 7.31/O 方式  

输入/输出系统实现主机与I/O设备之间的数据传送，可以采用不同的控制方式，各种方式在代价、性能、解决问题的着重点等方面各不相同，常用的I/O方式有程序查询、程序中断和DMA等，其中前两种方式更依赖于CPU中程序指令的执行。  

# 7.3.1程序查询方式  

信息交换的控制直接由CPU执行程序实现。程序查询方式接口中设置一个数据缓冲寄存器（数据端口）和一个设备状态寄存器（状态端口）。主机进行1/O操作时，先读取设备的状态并根据设备状态决定下一步操作究竟是进行数据传送还是等待。  
>#### pro：程序查询方式的特点（2023）  

程序查询方式的工作流程如下（见图7.2）：  

$\textcircled{\scriptsize{1}}$ CPU执行初始化程序，并预置传送参数。 $\circledcirc$ 向1/O接口发出命令字，启动I/O设备。 $\textcircled{3}$ 从外设接口读取其状态信息。 $\textcircled{4}$  CPU周期或持续的查询设备状态，直到外设准备就绪。  $\circledast$ 传送一次数据。 $\circledcirc$ 修改地址和计数器参数。 $\circleddash$ 判断传送是否结束，若未结束转第 $\textcircled{3}$ 步，直到计数器为0。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/fca58357301e2be2277f2fb06008bb5333a1276e5841ec4934610c16e8d988f0.jpg)  
图7.2程序查询方式流程图  

根据上述流程 $^{(4)}$ 中查询方式的不同，程序查询方式可分为如下两类。  

1）独占查询。一旦设备被启动，CPU就一直持续查询接口状态，CPU花费 $100\%$ 的时间用于I/O操作，此时外设和CPU完全事行工作。  

2）定时查询。CPU周期性地查询接口状态，每次总是等到条件满足才进行一个数据的传送，传送完成后返回到用户程序。定时查询的时间间隔与设备的数据传输速率有关。  

>#### pro：定时查询的特点、效率分析及计算（2011、2018）  

【例7.1】假设计算机的主频为 ${500}\mathrm{MHz}$ ，CPI为4，某外设的数据率为2MB/s，I/O接口中有一个32位数据缓冲寄存器，采用定时查询方式，每次1/0都执行10条指令。外设最多间隔多长时间查询一次才能不丢失数据？CPU用于外设I/O的时间占CPU总时间的百分比至少是多少？  

解：  

由于端口大小有限，必须在外设传输完端口大小的数据时访问端口，以防止数据未被及时读取而丢失。外设准备32位数据所用的时间为 $4\mathrm{B}{\cdot}2\mathrm{MB/s}=2\upmu\mathrm{s}$ ，所以最多每隔 $2\upmu\mathrm{s}$ 就必须查询一次，即每秒的查询次数至少是 $1\mathrm{s}{\cdot}2\upmu\mathrm{s}=5{\times}10^{5}$ ，每秒CPU用于外设I/O的时间至少为 $5{\times}10^{5}{\times}10{\times}4$  $=2{\times}10^{7}$ 个时钟周期，占整个CPU时间的百分比至少是 $2{\times}10^{7}/500\mathbf{M}=4\%$  
程序查询方式的优点是设计简单、硬件量少。缺点是CPU要花费很多时间来查询和等待，且在一段时间内只能和一台外设交换信息，CPU与设备串行工作，效率很低。  

# 7.3.2程序中断方式  

# 1.程序中断的基本概念  

程序中断是指在计算机执行程序的过程中，出现某些急需处理的异常情况或特殊请求，CPU暂时中止现行程序，而转去对这些异常情况或特殊请求进行处理，处理完毕后再返回到原程序的断点处，继续执行原程序。早期的中断技术是为了处理数据传送。  

>#### pro：程序中断方式的特点（2022、2023）  

随着计算机的发展，中断技术不断被赋予新的功能，主要功能有：  

$\textcircled{\scriptsize{1}}$ 实现CPU与I/O设备的并行工作。 $\circledcirc$ 处理硬件故障和软件错误。 $\textcircled{3}$ 实现人机交互，用户干预机器需要用到中断系统。 $\textcircled{4}$ 实现多道程序、分时操作，多道程序的切换需借助于中断系统。 $\circledast$ 实时处理需要借助中断系统来实现快速响应。 $\textcircled{6}$ 实现应用程序和操作系统（管态程序）的切换，称为软中断。 $\circleddash$ 多处理器系统中各处理器之间的信息交流和任务切换。  

程序中断方式的思想：CPU在程序中安排好在某个时机启动某台外设，然后CPU继续执行当前的程序，不需要像查询方式那样一直等待外设准备就绪。一且外设完成数据传送的准备工作就主动向CPU发出中断请求。在可以响应中断的条件下，CPU暂时中止正在执行的程序，转去执行中断服务程序为外设服务，在中断服务程序中完成一次主机与外设之间的数据传送，传送完成后，CPU返回原来的程序。此时，外设和CPU又开始并行工作，如图7.3所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d801b68aeb041a5302c1291f1270babd69f5c5840e4f2e2e4063c194152b2d83.jpg)  
图7.3程序中断方式示意图  

>#### pro：程序中断的效率分析及相关计算（2009、2014、2016、2018、2019）  

【例7.2】假定计算机的主频为 $500\mathrm{MHz}$ ，CPI为4，某外设的数据率为 $40\mathrm{MB/s}$ ，I/0接口中有一个32位数据缓冲寄存器。在中断I/O方式下，若每次中断响应和中断处理的总时钟周期数至少为400，则该外设能否采用中断1/0方式？为什么？  

解：  

中断响应和中断处理的时间为 $400{\times}1/500\mathbf{M}=0.8\upmu\mathrm{s}$ ，只需计算外设准备32位数据的时间，若准备数据的时间小于中断响应和中断处理的时间，则数据被刷新，造成丢失。外设准备32位数据所用的时间为 $4\mathrm{B}{\cdot}40\mathrm{MB}/\mathrm{s}=0.1\upmu\mathrm{s}$ ，因此该外设不适合采用中断I/O方式。  
# 2.程序中断的工作流程  

>#### pro：  

# 中断工作流程中的相关细节（2017、2018、2021）  

（1）中断请求  

中断源是请求CPU中断的设备或事件，一台计算机允许有多个中断源。每个中断源向CPU发出中断请求的时间是随机的。为记录中断事件并区分不同的中断源，中断系统需对每个中断源设置中断请求标记触发器，当其状态为“1”时，表示该中断源有请求。这些触发器可组成中断请求标记寄存器，该寄存器可集中在CPU中，也可分散在各个中断源中。  

>#### pro：可屏蔽中断和不可屏蔽中断的特点（2020）  

通过INTR线发出的是可屏蔽中断，通过NMI线发出的是不可屏蔽中断。可屏蔽中断的优先级最低，在关中断模式下不被响应。不可屏蔽中断用于处理紧急和重要的事件，如时钟中断、电源掉电等，其优先级最高，其次是内部异常，即使在关中断模式下也被响应。  

（2）中断响应判优  

中断响应优先级是指CPU响应中断请求的先后顺序。由于许多中断源提出中断请求的时间都是随机的，因此当多个中断源同时提出请求时，需通过中断判优逻辑来确定响应哪个中断源的请求，中断响应的判优通常是通过硬件排队器（或中断查询程序）实现的。  

一般来说， $\textcircled{\scriptsize{1}}$ 不可屏蔽中断 $>$ 内部异常 $>$ 可屏蔽中断； $\circledcirc$ 在内部异常中，硬件故障 $>$ 软件中断： $\textcircled{3}$ DMA中断请求 $>\,\mathrm{I/O}$ 设备的中断请求； $\textcircled{4}$ 在1/O传送类中断请求中，高速设备 $>$ 低速设备；输入设备 $>$ 输出设备；实时设备 $>$ 普通设备。  

# 注意  

中断优先级包括响应优先级和处理优先级，响应优先级由硬件线路或查询程序的查询顺序决定，不可动态改变。处理优先级可利用中断屏蔽技术动态调整，以实现多重中断。  

（3）CPU响应中断的条件  

CPU在满足一定的条件下响应中断源发出的中断请求，并经过一些特定的操作，转去执行中断服务程序。CPU响应中断必须满足以下3个条件：  

$\textcircled{\scriptsize{1}}$ 中断源有中断请求。  

$\circledcirc$ CPU允许中断及开中断（异常和不可屏蔽中断不受此限制）。 $\textcircled{3}$ 一条指令执行完毕（异常不受此限制），且没有更紧道的任务。  

# 注意  

I/O设备的就绪时间是随机的，而CPU在统一的时刻即每条指令执行结束时，采样中断请求信号（开中断的情况下），以获取I/O的中断请求，也就是说，CPU响应中断的时间是在每条指令执行阶段的结束时刻。这里说的中断仅指1/0中断，异常不属于此类情况。  

# （4）中断响应过程  

CPU响应中断后，经过某些操作，转去执行中断服务程序。这些操作是由硬件直接实现的，我们将它称为中断隐指令。中断隐指令并不是指令系统中的一条真正的指令，只是一种虚拟的说法，本质上是硬件的一系列自动操作。它所完成的操作如下：  

1）关中断。CPU响应中断后，首先要保护程序的断点和现场信息，在保护断点和现场的过  
程中，CPU不能响应更高级中断源的中断请求。否则，若断点或现场保存不完整，在中断服务程序结束后，就不能正确地恢复并继续执行现行程序。  

2）保存断点。为保证在中断服务程序执行完后能正确地返回到原来的程序，必须将原程序的断点（指令无法直接读取的PC和PSW的内容）保存在栈或特定寄存器中?。注意异常和中断的差异：异常指令通常并没有执行成功，异常处理后要重新执行，所以其断点通常是当前指令的地址。中断的断点则是下一条指令的地址。  

3）引出中断服务程序。识别中断源，将对应的服务程序入口地址送入程序计数器PC。有两种方法识别中断源：硬件向量法和软件查询法。本节主要讨论比较常用的向量中断。  

（5）中断向量  

中断识别分为向量中断和非向量中断两种。非向量中断即软件查询法，第5章已介绍。  

每个中断源都有一个唯一的类型号，每个中断类型号都对应一个中断服务程序，每个中断服务程序都有一个入口地址，即中断向量，CPU必须找到入口地址。把系统中的全部中断向量集中存放到存储器的某个区域内，这个存放中断尚量的存储区就称为中断向量表。  

>#### pro：中断向量表的数据结构（2023）  

CPU响应中断后，通过识别中断源获得中断类型号，然后据此计算出对应中断向量的地址：再根据该地址从中断向量表中取出中断服务程序的入口地址，并送入程序计数器PC，以转去执行中断服务程序，这种方法被称为中断向量法，采用中断向量法的中断被称为向量中断。  

# 注意  

中断请求和响应信号是在IO总线的控制线上传送的。CPU响应某一中断后，就从数据线上获取该中断源的中断类型号，并据此计算对应中断向量在中断向量表中的位置。  

（6）中断处理过程  

不同计算机的中断处理过程各具特色，图7.4所示为一个可嵌套中断的典型处理流程。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ab84db701920d4fe3e864b31bb3c16635e25ae9907717b89a42118448e2e3e09.jpg)  
图7.4可嵌套中断的处理流程  
中断处理流程如下：  

$\textcircled{\scriptsize{1}}$ 关中断。 $\circledcirc$ 保存断点。 $\textcircled{3}$ 中断服务程序寻址。  

$\textcircled{4}$ 保存现场和屏蔽字。进入中断服务程序后首先要保存现场和中断屏蔽字，现场信息是指用户可见的工作寄存器的内容，它存放程序执行到断点处的现行值。  

# 注意  

现场和断点，这两类信息都不能被中断服务程序破坏。由于现场信息用指令可直接访问，因此通常在中断服务程序中通过指令把它们保存到栈中，即由软件实现。而断点信息由CPU在中断响应时自动保存到栈或指定的寄存器中，即由硬件实现。  

$\circledast$ 开T卧。儿计史向级中断请小付划响应，以关现中断联县。  

$^\mathrm{\textregistered}$ 执行中断服务程序。这是中断请求的目的。 $\circleddash$ 关中断。保证在恢复现场和屏蔽字时不被中断。 $\circledast$ 恢复现场和屏蔽字。将现场和屏蔽字恢复到原来的状态。 $\circledcirc$ 开中断、中断返回。中断服务程序的最后一条指令通常是一条中断返回指令，使其返到原程序的断点处，以便继续执行原程序。  

其中， $\textcircled{\scriptsize{1}}\!\sim\!\textcircled{\scriptsize{3}}$ 由中断隐指令（硬件自动）完成： $\textcircled{4}\!\sim\!\textcircled{9}$ 由中断服务程序完成。  

>#### pro：单级中断的处理流程（2010）  

# 注意  

若是单重中断（或称单级中断），则在上述流程中去掉 $\circledast$ 和 $\circledast$ 即可。  

# 3.多重中断和中断屏蔽技术  

>#### pro：多重中断的中断屏蔽字相关的性质（2017、2020、2021）  

在CPU执行中断服务程序的过程中，若又出现了新的优先级更高的中断请求，而CPU对新的中断请求不予响应，则称这种中断为单重中断，如图7.5（a）所示。若CPU暂停现行的中断服务程序，转去处理新的中断请求，则称这种中断为多重中断，也称中断嵌套，如图7.5b所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1d3d8beb712bf54344e3605d581c5a8d10e4944f258311c805ffa316f694c414.jpg)  
图7.5单重中断和多重中断示意图  

在图7.5（b）中，CPU在执行主程序时发生中断请求1，主程序未屏蔽任何中断，因此响应中断请求1，将主程序的断点压栈保存，然后转去执行中断服务程序1。在执行中断服务程序1时，又发生中断请求2，而其处理优先级比中断请求1的更高，此时须中止中断请求1的处理，响应中断请求2，将中断服务程序1的断点压栈保存，然后转去执行中断服务程序2。同样，拥有更高处理优先级的中断请求3可以打断中断请求2的处理。当中断请求3处理完后，CPU从栈顶取出断点信息，回到中断服务程序2的断点（ $\mathrm{K}3+1)$ ）处继续执行。以此类推，直到所有中断服务程序执行完毕，最终回到原程序的断点（ $.\mathrm{K}1+1)$ ）处继续执行主程序。  
CPU要具备多重中断的功能，必须满足下列条件：  

$\textcircled{\scriptsize{1}}$ 在中断服务程序中提前设置开中断指令。 $\circledcirc$ 优先级别高的中断源有权中断优先级别低的中断源。  

中断处理优先级是指多重中断的实际优先级处理次序，可以利用中断屏蔽技术动态调整，从而可以灵活地调整中断服务程序的优先级，使中断处理更加灵活。若不使用中断屏蔽技术，则处理优先级和响应优先级相同。现代计算机一般使用中断屏蔽技术，每个中断源都有一个屏蔽触发器（MASK），1表示屏蔽该中断源的请求，0表示可以正常请求，所有屏蔽触发器组合在一起便构成一个屏蔽字寄存器，屏蔽字寄存器的内容称为屏蔽字。  

关于中断屏蔽字的设置及多重中断程序执行的轨迹，下面通过实例说明。  

【例7.3】设某机有4个中断源A、B、C、D，其硬件排队优先次序为 $\mathrm{A}\,{>}\,\mathrm{B}\,{>}\,\mathrm{C}\,{>}\,\mathrm{D}$ ，现要求将中断处理次序改为  $\mathrm{D}\,{>}\,\mathrm{A}\,{>}\,\mathrm{C}\,{>}\,\mathrm{B}$  ，写出每个中断源对应的屏蔽字。  

解：  

在中断处理次序改为 $\mathrm{D}\,{>}\,\mathrm{A}\,{>}\,\mathrm{C}\,{>}\,\mathrm{B}$ 后，D具有最高优先级，可以屏蔽其他所有中断，且不能中断自身，因此D对应的屏蔽字为1111；A具有次高优先级，只能被D中断，因此A对应的屏蔽字为1110，以此类推，得到4个中断源的屏蔽字，见表7.1。  

表7.1中断源对应的中断屏蔽字
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c51e363202806c9ac2a1ac35db7cc75e6bd5d697fae775c075ea07369b546fcc.jpg)  

从宏观上看，虽然程序中断方式克服了程序查询方式中CPU的等待现象，提高了CPU的利用率。但从微观操作分析，CPU在处理中断时，仍需暂停原程序的运行，尤其是当高速设备频繁成批地与主存交换信息时，需要不断打断CPU执行现行程序而去执行中断服务程序。  

# 7.3.3DMA方式  

DMA方式是一种完全由硬件进行成组信息传送的控制方式，它具有程序中断方式的优点，即在数据准备阶段，CPU与外设并行工作。DMA方式在外设与内存之间开辟了一条“直接数据通路”，信息传送不再经过CPU，降低了CPU在传送数据时的开销，因此称为直接存储器存取方式。由于数据传送不经过CPU，因此不需要保护、恢复CPU现场等烦琐操作。  

这种方式适用于磁盘、显卡、声卡、网卡等高速设备大批量数据的传送，它的硬件开销比较大。在DMA方式中，中断的作用仅限于故障和正常传送结束时的处理。  

# 1.DMA方式的特点  

主存和DMA接口之间有一条直接数据通路。由于DMA方式传送数据不需要经过CPU，因此不必中断现行程序，I/O与主机并行工作，程序和传送并行工作。  
DMA方式具有下列特点：  

1）它使主存与CPU的固定联系脱钩，主存既可被CPU访问，又可被外设访问。2）在数据块传送时，主存地址的确定、传送数据的计数等都由硬件电路直接实现。3）主存中要开辟专用缓冲区，以及时提供和接收外设的数据。4）DMA传送速度快，CPU和外设并行工作，提高了系统效率。5）DMA在传送开始前要通过程序进行预处理，结束后要通过中断方式进行后处理。  

# 2.DMA控制器的组成  

在DMA方式中，对数据传送过程进行控制的硬件称为DMA控制器（DMA接口）。当I/O设备需要进行数据传送时，通过DMA控制器向CPU提出DMA传送请求，CPU响应之后将让出系统总线，由DMA控制器接管总线进行数据传送。其主要功能如下：  

1）接受外设发出的DMA请求，并向CPU发出总线请求。2）CPU响应并发出总线响应信号，DMA接管总线控制权，进入DMA操作周期。3）确定传送数据的主存起始地址及长度，并自动修改主存地址计数和传送长度计数。4）规定数据在主存和外设间的传送方向，发出读/写等控制信号，执行数据传送操作。5）向CPU报告DMA操作结束。  

图7.6给出了一个简单的DMA控制器。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8522cd40675adcad448679876eac85a3951fa26a1116a5b156080131b7de7bcf.jpg)  
图7.6简单的DMA控制器  

·主存地址计数器：存放要交换数据的主存地址。在传送前，其保存的是传送数据的主存起始地址；每传送一个字，地址寄存器的内容就加1，直至该批数据传送完毕。  

·传送长度计数器：记录传送数据的总长度。在传送前，其记录的是该批数据的总字数；每传送一个字，计数器就减1，直至计数器为0，表示该批数据传送完毕。  

·数据缓冲寄存器：暂存每次传送的数据。通常，DMA接口与主存之间的传送单位为字，而DMA与设备之间的传送单位可能为字节或位。  

·DMA请求触发器：每当I/O设备准备好数据后，发出一个控制信号，使DMA请求触发器置位。  

）“控制/状态”逻辑：用于指定传送方向，修改传送参数，并对DMA请求信号、CPU响应信号进行协调和同步。  

·中断机构：当一批数据传送完毕后触发中断机构，向CPU提出中断请求。  
在DMA传送过程中，DMA控制器接管系统总线。而当DMA传送结束后，将恢复CPU的一切权利并开始执行其操作。由此可见，DMA控制器必须具有控制系统总线的能力。  

# 3.DMA的传送方式  

主存和I/O设备之间交换信息时，不通过CPU。但当I/O设备和CPU同时访问主存时，可能发生冲突，为了有效地使用主存，DMA与CPU通常采用以下3种方式使用主存。  

# （1）停止CPU访存  

当I/O设备有DMA请求时，由DMA接口向CPU发送一个停止信号，使CPU放弃总线控制权，停止访问主存，直到DMA传送一块数据结束，如图7.7所示。数据传送结束后，DMA接口通知CPU可以使用主存，并把总线控制权交回给CPU。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6ec983e624318edc13175044b2d5cebc2b11509fa61e7d5aa190149951d0aa44.jpg)  
图7.7停止CPU访存  

优点：控制简单，适用于数据传输速率很高的I/O设备实现成组数据的传送。  

缺点：DMA在访问主存时，CPU基本上处于不工作状态。  

（2）周期挪用  

>#### pro：周期挪用的特点及挪用次数分析（2012、2020、2022）  

由于I/O访存的优先级高于CPU访存（I/O不立即访存就可能丢失数据），因此由I/O设备挪用一个存取周期，传送完一个数据字后立即释放总线，如图7.8所示。它是一种单字传送方式。当I/O设备有DMA请求时，会遇到3种情况： $\textcircled{\scriptsize{1}}$ 此时CPU不在访存，因此I/O的访存请求与CPU未发生冲突； $\circledcirc$ CPU正在访存，此时必须待存取周期结束后，CPU再将总线占有权让出； $\textcircled{3}$ I/O和CPU同时请求访存，出现访存冲突，此时CPU要暂时放弃总线占有权。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f1cb1aeae481f0ba9014acc77c9a136f81250ae56fe2f1afdbaaae40727dad9f.jpg)  
图7.8周期挪用  

优点：既实现了I/O传送，又较好地发挥了主存与CPU的效率。  

缺点：每挪用一个主存周期，DMA接口都要申请、建立和归还总线控制权。  

（3）DMA与CPU交替访存  

将CPU的工作周期分成两个时间片，一个给CPU访存，另一个给DMA访存，这样在每个CPU周期内，CPU和DMA就都可以轮流访存，如图7.9所示。这种方式适用于CPU的工作周期比主存存取周期长的情况。例如，若CPU的工作周期是 $1.2\upmu\mathrm{s}$ ，主存的存取周期小于 $0.6\upmu\mathrm{s}$ ，则可将一个CPU周期分为 $\mathbf{C}_{1}$ 和 $\mathbf{C}_{2}$ 两个周期，其中 $\mathbf{C}_{1}$ 专供DMA访存， $C_{2}$ 专供CPU访存。这种方式不需要申请、建立和归还总线使用权，总线使用权是通过 $C_{1}$ 和 $\mathrm{C}_{2}$ 分时控制的。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ffcf3f4a552e1dfafa466c4a36585fb69c056f358e0b653e960ca62e1a3344ba.jpg)  
图7.9DMA与CPU交替访存  

优点：不需要总线控制权的申请、建立和归还过程，具有很高的传送速率。  

缺点：相应的硬件逻辑变得更复杂。  

DMA方式的效率分析及相关计算（2011、2018）  

【例7.4】假定计算机的主频为 $500\mathrm{MHz}$ ，CPI为4，某外设的数据率为 $40\mathrm{MB/s}$ ，I/IO接口中的数据端口为32位，采用DMA方式，每次DMA传送块大小为1000B，且DMA预处理和后处理的总时钟周期数为500，则CPU用于该外设I/O的时间占CPU总时间的百分比是多少？  

解：  

外设每秒的DMA次数为 $\mathrm{40MB/s^{\pm}1000B=40000}$ ，在DMA方式中，只有预处理和后处理需要CPU处理，数据传送全程由DMA控制。CPU用于外设I/O的总时间为 $40000{\times}500=2{\times}10^{7}$ 个时钟周期，占CPU总时间的百分比为 $2\!\times\!10^{7}\!\div\!500\mathbf{M}=4\%.$  

# 4.DMA的传送过程  

>#### pro：DMA方式的传送过程（2019）  

图7.10所示为DMA的数据传送流程，分为预处理、数据传送和后处理3个阶段。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a3b3e6b4a23a187f89eda625719dd33923705cfd841a0f99f9153f246e978d6b.jpg)  
图7.10DMA的传送流程  

（1）预处理  

由CPU完成一些必要的准备工作。首先，初始化DMA控制器中的有关寄存器、设置传送方尚、测试并启动设备等。然后，CPU继续执行原程序，直到I/O设备准备好发送的数据（输入情况）或接收的数据（输出情况）时，I/O设备向DMA控制器发送DMA请求，再由DMA控制器向CPU发出总线请求（这两个过程也可统称DMA请求），用以传输数据。  
（2）数据传送  

DMA以数据块为基本传送单位。DMA占用总线后的数据输入/输出操作都是通过循环来实现的，这一循环也是由DMA控制器实现的，即数据传送阶段完全由DMA（硬件）控制。  

（3）后处理  

DMA控制器向CPU发送中断请求，CPU执行中断服务程序做DMA结束处理，包括校验数据（出错则转诊断程序）等后处理工作。在DMA方式下，整个数据块的传送过程都不需要CPU参与，CPU只在最初的DMA控制器初始化和最后的DMA结束处理时才介入，因此CPU用于I/O的开销非常小。  

# 5.DMA方式和中断方式的区别  

>#### pro：中断方式与DMA方式的区别（2013、2023）  

DMA万式和中断万式的重要区别如下：  

$\textcircled{\scriptsize{1}}$ 中断方式是程序的切换，需要保护和恢复现场；而DMA方式不中断现行程序，无需保护现场，除了预处理和后处理，其他时候不占用任何CPU资源。 $\circledcirc$ 对中断请求的响应只能发生在每条指令执行结束时（执行周期后）：而对DMA请求的响应可以发生在任意一个机器周期结束时（取指、间址、执行周期后均可）。 $\textcircled{3}$ 中断传送过程需要CPU的干预：而DMA传送过程不需要CPU的干预，因此数据传输速率非常高，适合于高速外设的成组数据传送。  

>#### pro：DMA与CPU请求总线的优先级对比（2012、2022）  

$\textcircled{4}$ DMA请求的优先级高于中断请求。 $\circledast$ 中断方式具有处理异常事件的能力，而DMA方式仅局限于大批数据的传送。 $\circledcirc$ 从数据传送来看，中断方式靠程序传送，DMA方式靠硬件传送。  


# 7.4 本章小结  

本章开头提出的问题的参考答案如下。  

1）1/O设备有哪些编址方式？各有何特点？  

统一编址和独立编址。统一编址是在主存地址中划出一定的范围作为I/O地址，以便通过访存指令即可实现对1/O的访问，但主存的容量相应减少。独立编址是指1/O地址和主存是分开的，I/O地址不占主存空间，但访存需专门的I/O指令。  

2）CPU响应中断应具备哪些条件？  

$\textcircled{\scriptsize{1}}$ 在CPU内部设置的中断屏蔽触发器必须是开放的。 $\circledcirc$ 外设有中断请求时，中断请求触发器必须处于“1”状态，保持中断请求信号。 $\textcircled{3}$ 外设（接口）中断允许触发器必须为“1”，这样才能把外设中断请求送至CPU。具备上述三个条件时，CPU在现行指令结束的最后一个状态周期响应中断。  

# 7.5常见问题和易混淆知识点  

在开中断情况下，CPU总在每条指令执行结束时采样中断信号，此时若检测到中断请求信号，则会立即响应。即便是多重中断，CPU正在处理某个中断的过程中，由于币断屏蔽字的存在，CPU检测不到处理优先级更低的中断请求信号，因此若检测到中断请求信号，则说明新中断源的处理优先级更高，同样也会立即响应。  
# 2.向量中断、中断向量、向量地址三个概念是什么关系？  

中断向量：每个中断源都有对应的处理程序，这个处理程序称为中断服务程序，其入口地址称为中断向量。所有中断的中断服务程序入口地址构成一个表，称为中断向量表；也有的机器把中断服务程序入口的跳转指令构成一张表，称为中断向量跳转表。  

向量地址：中断向量表或中断向量跳转表中每个表项所在的内存地址或表项的索引值，称为向量地址或中断类型号。  

向量中断：指一种识别中断源的技术或方式。识别中断源的目的是找到中断源对应的中断服务程序的入口地址的地址，即获得向量地址。  

3.程序中断和调用子程序有何区别？  

两者的根本区别主要表现在服务时间和服务对象上不一样。  

1）调用子程序过程发生的时间是已知的和固定的，即在主程序中的调用指令（CALL）执行时发生主程序调用子程序过程，调用指令所在位置是已知的和固定的。而中断过程发生的时间一般是随机的，CPU在执行某个主程序时收到中断源提出的中断申请，就发生中断过程，而中断申请一般由硬件电路产生，申请提出时间是随机的。也可以说，调用子程序是程序设计者事先安排的，而执行中断服务程序是由系统工作环境随机决定的。2）子程序完全为主程序服务，两者属于主从关系。主程序需要子程序时就去调用子程序，并把调用结果带回主程序继续执行。而中断服务程序与主程序二者一般是无关的，不存在谁为谁服务的问题，两者是平行关系。3）主程序调用子程序的过程完全属于软件处理过程，不需要专门的硬件电路；而中断处理系统是一个软/硬件结合的系统，需要专门的硬件电路才能完成中断处理的过程。4）子程序嵌套可实现若干级，嵌套的最多级数受计算机内存开辟的堆栈大小限制；而中断 嵌套级数主要由中断优先级来决定，一般优先级数不会很大。  
