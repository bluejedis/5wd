# above

## 【考纲内容】  

（一）CPU的功能和基本结构  

（二）指令执行过程  

（三）数据通路的功能和基本结构  

（四）控制器的功能和工作原理  

五）异常和中断机制异常和中断的基本概念：异常和中断的分类；异常和中断的检测与响应  

（六）指令流水线指令流水线的基本概念：指令流水线的基本实现：结构冒险、数据冒险和控制冒险的处理；超标量和动态流水线的基本概念  

（七）多处理器基本概念  

SISD、SIMD、MIMD、向量处理器的基本概念：硬件多线程的基本概念：多核（multi-core）处理器的基本概念：共享内存多处理器（SMP）的基本概念  

## 【复习提示】  

中央处理器是计算机的中心，也是本书的难点。其中，数据通路的分析、指令执行阶段的节拍与控制信号的安排、流水线技术与性能分析易出综合题。而关于各种寄存器的特点、各种指令执行的周期与特点、控制器的相关概念、流水线的相关概念易出选择题。  

在学习本章时，请读者思考以下问题：  

1）指令和数据均存放在内存中，计算机如何从时间和空间上区分它们是指令还是数据？  

2）什么是指令周期、机器周期和时钟周期？它们之间有何关系？  

3）什么是微指令？它和第4章谈到的指令有什么关系？  

4）什么是指令流水线？指令流水线相对于传统体系结构的优势是什么？  

请读者在本章的学习过程中寻找答案，本章末尾会给出参考答案。  

# CPU的功能和基本结构  

## CPU的功能  

中央处理器（CPU）由运算器和控制器组成。其中，控制器的功能是负责协调并控制计算机各部件执行程序的指令序列：运算器的功能是对数据进行加工。CPU的具体功能包括：  

1）指令控制。完成取指令（也称取指）、分析指令和执行指令的操作，即程序的顺序控制。  
2）操作控制。产生完成一条指令所需的操作信号，把各种操作信号送到相应的部件，从而控制这些部件按指令的要求正确执行。3）时间控制。严格控制各种操作信号的出现时间、持续时间及出现的时间顺序。4）数据加工。对数据进行算术和逻辑运算。5）中断处理。对运行过程中出现的异常情况和中断请求进行处理。  

## CPU的基本结构  

在计算机系统中，CPU主要由运算器和控制器两大部分组成［也可将CPU分为数据通路（见5.3节）和控制部件两大组成部分]，如图5.1所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4b9660fe8f486ff3097ffb4d9a7cf8d43ce70d8af78ba631a7eee723b6a34fa0.jpg)  
图5.1中央处理器的组成  

### 运算器  

运算器主要由算术逻辑单元（ALU）、暂存寄存器、累加寄存器（ACC）、通用寄存器组（GPRs）程序状态字寄存器（PSW）、移位寄存器、计数器（CT）等组成。其主要功能是根据控制器送来的命令，对数据执行算术运算（加、减、乘、除）、逻辑运算（与、或、非、异或、移位、求补等）或条件测试（用于设置ZF、SF、OF和CF等标志位，作为条件转移的判断条件）。  

### 控制器  

控制器主要由程序计数器（PC）、指令寄存器（IR）、指令译码器（ID）、存储器地址寄存器（MAR）、存储器数据寄存器（MDR）、时序电路和微操作信号发生器等组成。其主要功能是执行指令，每条指令的执行是由控制器发出的一组微操作实现的。  

控制器的工作原理是，根据指令操作码、指令的执行步骤（微命令序列）和条件信号来形成当前计算机各部件要用到的控制信号。计算机整机各硬件系统在这些控制信号的控制下协同运行，产生预期的执行结果。控制器是整个系统的指挥中枢，在控制器的控制下，运算器、存储器和输入/输出设备等功能部件构成一个有机的整体，根据指令的要求指挥全机协调工作。  

## CPU的寄存器  

>#### pro：汇编程序员可见的寄存器（2010、2015、2021）  

CPU中的寄存器按汇编语言（或机器语言）程序是否可访问，可分为两类：一类是用户可见寄存器，可对这类寄存器编程，以通过使用这类寄存器减少对主存储器的访问次数，如通用寄存器组（含基址/变址寄存器）、程序状态字寄存器、程序计数器、累加寄存器、移位寄存器；另一类是用户不可见寄存器，对用户是透明的，不可对这类寄存器编程，它们被控制部件使用，以控制CPU的操作，如存储器地址寄存器、存储器数据寄存器、指令寄存器、暂存寄存器。  
>#### pro：CPU中各种寄存器的作用（2013）  

### 运算器中的寄存器  

1）通用寄存器组（GPRs）。用于存放操作数（包括源操作数、目的操作数及中间结果）和各种地址信息等，如AX、BX、CX、DX、SP等。在指令中要指定寄存器的编号，才能明确是对哪个寄存器进行访问。SP是堆栈指针，用于指示栈顶的地址。2）累加寄存器（ACC）。它是一个通用寄存器，用于暂时存放ALU运算的结果。3）移位寄存器（SR）。不但可用来存放操作数，而且在控制信号的作用下，寄存器中的数据可根据需要向左或向右移位。4）暂存寄存器。用于暂存从数据总线或通用寄存器送来的操作数，以便在取出下一个操作数时将其同时送入ALU。暂存寄存器对应用程序员是透明的（不可见）。5）程序状态字寄存器（PSW）。保留由算术/逻辑运算指令或测试指令的运行结果而建立的各种状态信息，如溢出标志（OF）、符号标志（SF）、零标志（ZF）、进位标志（CF）等。每个标志位通常由一位触发器来保存，这些标志位组合在一起称为程序状态字。  

### 控制器中的寄存器  

>#### pro：PC和IR的位数与主存储器空间和指令字长的关系（2016、2021）  

1）程序计数器（PC）。用于指出欲执行指令在主存储器中的存放地址。若PC和主存储器均按字节编址，则PC的位数等于主存储器地址位数。CPU根据PC的内容从主存储器中取指令，然后送入指令寄存器。指令通常是顺序执行的，因此PC具有自动加1的功能（这里的“1”是指一条指令的字节数）；当遇到转移类指令时，PC的新值由指令计算得到。  

2）指令寄存器（IR）。用于保存当前正在执行的指令，IR的位数等于指令字长。  

3）存储器地址寄存器（MAR）。用于存放要访问的主存储器单元的地址，MAR的位数等于主存储器地址线数，它反映了最多可寻址的存储单元的个数。  

4）存储器数据寄存器（MDR）。用于存放向主存储器写入的信息或从主存储器读出的信息，MDR的位数等于存储字长。当CPU和主存储器交换信息时，都要用到MAR和MDR。  
  

# 指令执行过程  

## 指令周期  

CPU每取出并执行一条指令所需的全部时间称为指令周期，不同指令的指令周期可能不同。指令周期通常可用若干机器周期来表示，每个指令周期内的机器周期数可以不等。图5.2反映了上述关系。图5.2（a）所示为定长的机器周期，图5.2（b）所示为不定长的机器周期。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4cdf5401a046fb5fe39af366d76c0d8889d1154a1965f8d7673571ffd1641a97.jpg)  
图5.2指令周期和机器周期的关系  

对于无条件转移指令JIMIPX，在执行时不需要访问主存，只包含取指阶段（包括取指和分析）和执行阶段，所以其指令周期仅包含取指周期和执行周期。  

对于间接寻址的指令，为了取操作数，需要先访问一次主存，取出有效地址，然后访问主存，取出操作数，所以还需包括间址周期。间址周期介于取指周期和执行周期之间。  

当CPU采用中断方式实现主机和I/O设备的信息交换时，CPU在每条指令执行结束前，都要发中断查询信号，若有中断请求，则CPU进入中断响应阶段，也称中断周期。这样，一个完整的指令周期可包括取指、间址、执行和中断4个周期，如图5.3所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f7ac4456b5579efe301d3c745f4bafd3791739991e765a528a6dd737b49f8fa6.jpg)  
图5.3带有间址周期、中断周期的指令周期  

>#### pro：指令执行的过程（2011）  

当CPU执行指令时，首先进入取指周期，从PC指出的主存单元中取出指令，送至指令寄存器，同时PC加“1”以作为下一条指令的地址。当遇到转移指令等改变执行顺序的指令时，  
在PC加“1”后会重新计算并更新PC值。然后判断是否有间接寻址，如果有，那么进入间址周期以获取操作数的有效地址。之后进人执行周期，完成取操作数、执行运算和存操作数的任务。执行周期结束后，如果CPU检测到中断请求，则进入中断周期，此时需要关中断、保存断点、修改PC值为中断服务程序的入口地址，并转向中断服务程序。关于中断的具体内容，见本章的5.5节。  

>##### attention:  

中断周期中的进栈操作是将SP减“1”，这和传统意义上的进栈操作相反，原因是计算机中的堆栈都是向低地址方向增长，所以进栈操作是减“1”而不是加“”。  

## 指令周期的数据流  

数据流是根据指令要求依次访问的数据序列。在指令执行的不同阶段，要求依次访问的数据序列是不同的。而且对于不同的指令，它们的数据流往往也是不同的。  

### 取指周期  

取指周期的任务是根据PC中的内容从主存中取出指令代码并存放在IR中。  

取指周期的数据流如图5.4所示。PC中存放的是指令的地址，根据此地址从内存单元中取出的是指令，并放在指令寄存器IR中，取指令的同时，PC加1。  

取指周期的数据流向如下：  

1）PC  $\circledast$  MAR②地址总线存储器。 2）CU发出读命令控制总线 $\circeq$ 存储器3）主存 $\circeq$ 数据总线 $\nsupseteq$ MDR $\circledast$ IR（存放指令）4）CU发出控制信号PC内容加1。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f75084f25f382c3b663c9acfe77f401b2ea0ef4abcdf6fe2e458bbf2de1010ae.jpg)  
图5.4取指周期的数据流  

### 间址周期  

间址周期的任务是取操作数有效地址。以一次间址为例（见图5.5），将指令中的地址码送到MAR并送至地址总线，此后CU向存储器发出读命令，以获取有效地址并存至MDR。  

间址周期的数据流向如下：  

1）Ad（IR）（或MDR） $\circledast$ MAR $\circeq$ 地址总线存储器。2）CU发出读命令控制总线存储器。3）主存数据总线 $\nsupseteq$ MDR（存放有效地址）。  

其中，Ad（IR）表示取出IR中存放的指令字的地址字段。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a85b790d202f2b82ad10656f53199f418770f4c117771fe30b596a329d044671.jpg)  
图5.5一次间址周期的数据流  

### 执行周期  

执行周期的任务是取操作数，并根据IR中的指令字的操作码通过ALU操作产生执行结果。不同指令的执行周期操作不同，因此没有统一的数据流向。  

### 中断周期  

中断周期的任务是处理中断请求。假设程序断点存入堆栈中，并用SP指示栈顶地址，而且进栈操作是先修改栈顶指针，后存入数据，数据流如图5.6所示。  

中断周期的数据流向如下：  

1）CU控制将SP减1，SP $\circeq$ MAR②地址总线存储器。2）CU发出写命令 $\underline{{\boldsymbol{\mathfrak{A}}}}$ 控制总线 $\circeq$ 存储器3）PCMDR $\nsupseteq$ 数据总线 $\circeq$ 主存（程序断点存入存储器）。4）CU（中断服务程序的入口地址）PC。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c5e774da7c287935949863c45b6d8ed1c27c81c7ecb099690202cb499289d6e4.jpg)  
图5.6中断周期的数据流  

## 指令执行方案  

一个指令周期通常要包括几个执行步骤，每个步骤完成指令的一部分功能，几个依次执行的步骤完成这条指令的全部功能。不同的处理器采用不同的方案来安排指令的执行步骤。  

>#### pro：单周期和多周期CPU的CPI（2020）  

### 单周期处理器  

>#### pro：单周期CPU的特点（2016）  

单周期处理器对所有指令都选用相同的执行时间来完成。此时每条指令都在一个时钟周期内完成（即 ${\mathrm{CPI}}=1$ ），指令之间串行执行，即下一条指令只能在前一条指令执行结束后才能启动。因此，指令周期取决于执行时间最长的指令的执行时间。对于那些本来可以在更短时间内完成的指令，仍要使用这个较长的周期来完成，会降低整个系统的运行速度。  
### 多周期处理器  

多周期处理器对不同类型的指令选用不同的执行步骤。指令需要几个周期就为其分配几个周期，因此可选用不同个数的时钟周期来完成不同指令的执行过程（即 $\mathrm{CPI}>1)$ ，不再要求所有指令占用相同的执行时间。多指令周期方案中指令之间仍是串行执行。  

### 流水线处理器  

流水线处理器采用指令之间并行执行的方案，其追求的自标是力争在每个时钟周期完成一条指令的执行过程（只在理想情况下才能达到该效果，此时 ${\mathrm{CPI}}=1$ ）。这种方案通过在每个时钟周期启动一条指令，尽量让多条指令同时运行，但各自处在不同的执行步骤中。  
  

# 数据通路的功能和基本结构  

## 数据通路的功能  

随着技术的发展，更多的功能逻辑被集成到CPU芯片中，但不论CPU的内部结构多么复杂，它都可视为由数据通路（DataPath）和控制部件（ControlUnit）两大部分组成。  

>#### pro：数据通路的组成部件（2017、2021）  

数据在指令执行过程中所经过的路径，包括路径上的部件，称为数据通路，ALU、通用寄存器、状态寄存器、异常和中断处理逻辑等都是指令执行时数据流经的部件，都属于数据通路的一部分。数据通路描述了信息从哪里开始，中间经过哪些部件，最后被传送到哪里。数据通路由控制部件控制，控制部件根据每条指令功能的不同，生成对数据通路的控制信号。  

## 数据通路的组成  

组成数据通路的元件主要分为组合逻辑元件和时序逻辑元件两类。>#### pro：数据通路中的组合逻辑元件和时序逻辑元件（2021、2023）  

### 组合逻辑元件（操作元件）  

任何时刻产生的输出仅取决于当前的输入。组合电路不含存储信号的记忆单元，也不受时钟信号的控制，输出与输入之间无反馈通路，信号是单向传输的。数据通路中常用的组合逻辑元件有加法器、算术逻辑单元（ALU）、译码器、多路选择器、三态门等，如图5.7所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/96308c858ff5f7964125d669141286fa1586d651484b7c7042c3ce73a05e35c4.jpg)  
图5.7数据通路中的几种常用组合逻辑元件  

图中虚线表示控制信号，译码器可用于操作码或地址码译码， $n$ 位输入对应 $2^{n}$ 种不同组合，因此有 $2^{n}$ 个不同输出。多路选择器（MUX）需要控制信号Select来确定选择哪个输入被输出。三态门可视为一种控制开关，由控制信号EN决定信号线的通断，当 $\mathrm{EN}=1$ 时，三态门被打开，输出信号等于输入信号：当 $\mathrm{EN}\,=\,0$ 时，输出端呈高阻态（隔断态），所连寄存器与总线断开。  

### 时序逻辑元件（状态元件）  

任何时刻的输出不仅与该时刻的输入有关，还与该时刻以前的输入有关，因而时序电路必然包含存储信号的记忆单元。此外，时序电路必须在时钟节拍下工作。各类寄存器和存储器，如通用寄存器组、程序计数器、状态/移位/暂存/锁存寄存器等，都属于时序逻辑元件。  

## 数据通路的基本结构  

数据通路的基本结构主要有以下几种。  

### CPU内部单总线方式  

>#### pro：数据通路中的部件及连接方式（2013、2015、2022）  

将ALU及所有寄存器都连接到一条内部公共总线上，称为单总线结构的数据通路。这种结构比较简单，但数据传输存在较多的冲突现象，性能较低。此总线在CPU内部，注意不要把它与连接CPU、存储器和外设的系统总线相混淆。图5.8所示为单总线的数据通路和控制信号。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0161e7b16de00d520d62405d382e730a37430111a550273cdc1cb28934a907c8.jpg)  
图5.8单总线的数据通路和控制信号  

>#### pro：数据通路中的三态门及其作用（2015）  

在图5.8中，GPRs为通用寄存器组，rs、rd分别为所读、写的通用寄存器的编号；Y和Z为暂存器；FR为标志寄存器，用于存放ALU产生的标志信息。带箭头的虚线表示控制信号，字母加“in”表示该部件充许写入，字母加“out”表示该部件充许输出。MDRin表示内部总线上信息写入MDR，MDRout表示MDR的内容送入内部总线。能输出到总线的部件均通过一个三态门与内部总线相连，用于控制该部件与内部总线之间数据通路的连接与断开。  
>##### attention:  

单周期处理器（ $\mathrm{CPI}=1$ ）不能采用单总线方式，因为单总线将所有寄存器都连接到一条公共总线上，一个时钟内只允许一次操作，无法完成一条指令的所有操作。  

### CPU内部多总线方式  

CPU内部有两条或更多的总线时，构成双总线结构或多总线结构。将所有寄存器的输入端和输出端都连接到多条公共通路上，相比之下单总线中一个时钟内只充许传送一个数据，因而指令执行效率很低，因此采用多总线方式，同时在多个总线上传送不同的数据，提高效率。  

>#### pro：单周期CPU的特点（2016）  

### 专用数据通路方式  

根据指令执行过程中的数据和地址的流动方向安排连接电路，避免使用共享的总线，性能较高，但硬件量大。  

>##### attention:  

内部总线是指同一部件，如CPU内部连接各寄存器及运算部件之间的总线；系统总线是指同一台计算机系统的各部件，如CPU、内存和各类I/O接口间互相连接的总线。  

## 数据通路的操作举例  

总线是一组共享的传输信号线，它不能存储信息，任一时刻也只能有一个部件把信息送到总线上。下面以图5.8所示的单总线数据通路为例，介绍一些常见操作的流程及控制信号。  

>#### pro：指令执行的节拍及有效控制信号（2009、2015）：指令在取数和执行阶段所用到的部件（2019）  

### 通用寄存器之间传送数据  

在寄存器和总线之间有两个控制信号：Rin和Rout。当Rin有效时，控制将总线上的信息存到寄存器R中；当Rout有效时，控制将寄存器R的内容送至总线。下面以程序计数器PC为例，将PC的内容送至MAR。实现该操作的流程及控制信号为  

(PC)→MARPC out MARin，PC内容→MAR  

### 从主存读取数据  

>#### pro：取指令阶段所需时钟周期分析（2022）  

从主存中读取的信息可能是数据或指令，现以CPU从主存中取指令为例，说明数据在单总线数据通路中的传送过程。实现该操作的流程及控制信号为  

（PC）→MARPC out MARin，现行指令地址→MARMEM（MAR)→MDR，（PC)+1→PCMDRin有效，CU发出读命令，取出指令后PC+1(MDR）→IR MDR out IR in，现行指令→IR  
第一步，将PC的内容通过内部总线送至MAR，需要1个时钟周期。第二步，CU向主存发出读命令，从MAR所指主存单元读取一个字，并送至MDR；同时PC加1为取下一条指令做准备，需要1个主存周期。第三步，将MDR的内容通过内部总线送至IR，需要1个时钟周期。  

### 将数据写入主存  

将寄存器R1的内容写入寄存器R2所指的主存单元，完成该操作的流程及控制信号为  

(R1)→MDR Rl out MDR in (R2)→MAR R 2 out MARin MDR→MEM(MAR)MDRout有效，CU发出写命令  

### 执行算术或逻辑运算  

>#### pro: ALU中设置暂存器的原因（2015、2022）  

在单总线数据通路中，每一时刻总线上只有一个数据有效。由于ALU是一个没有存储功能的组合逻辑元件，在其执行运算时必须保持两个输入端同时有效，因此先将一个操作数经内部总线送人暂存器Y保存，Y的内容在ALU的左输入端始终有效，再将另一个操作数经内部总线直接送到ALU的右输入端。此外，ALU的输出端也不能直接与总线相连，否则其输出会通过总线反馈到输入端，影响运算结果，因此将运算结果暂存在暂存器乙中。假设加法指令ADDACC，R1，实现将ACC的内容和R1的内容相加并写回ACC，完成该操作的流程及控制信号为  

(R1)→Y Rl out Yin，操作数→Y (ACC)  $^+$  (Y）→Z ACC out ALU in，CU ALU，结果→Z (Z)→ACC Z out ACC in，结果→ACC  

>#### pro：分析减法和自增指令执行所需的时钟周期数（2015）  

以上3步不能同时执行，否则会引起总线冲突，因此该操作需要3个时钟周期  

### 修改程序计数器的值  

转移指令通过修改程序计数器PC的值来达到转跳的目的。假设转移指令JIMPaddr，addr为目标转移地址，实现将IR中的地址字段写入PC，完成该操作的流程及控制信号为  

Ad(IR)→PCIR out PC in  

数据通路结构直接影响CPU内各种信息的传送路径，数据通路不同，指令执行过程的微操作序列的安排也不同，它关系着微操作信号形成部件的设计。  


# 控制器的功能和工作原理  

## 控制器的结构和功能  

从图5.9可以看到计算机硬件系统的五大功能部件及其连接关系。它们通过数据总线、地址总线和控制总线连接在一起，其中点画线框内的是控制器部件。  

现对其主要连接关系简单说明如下：  

1）运算器部件通过数据总线与内存储器、输入设备和输出设备传送数据。  

2）输入设备和输出设备通过接口电路与总线相连接。  

3）内存储器、输入设备和输出设备从地址总线接收地址信息，从控制总线得到控制信号，通过数据总线与其他部件传送数据。  

4）控制器部件从数据总线接收指令信息，从运算器部件接收指令转移地址，送出指令地址到地址总线，还要向系统中的部件提供它们运行所需要的控制信号。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d13488b4b74cc2530f08d0235bb3404b2df25c7b14a7a83dd5306035c33dd080.jpg)  
图5.9计算机硬件系统和控制器部件的组成  

控制器是计算机系统的指挥中心，控制器的主要功能有：  

1）从主存中取出一条指令，并指出下一条指令在主存中的位置。2）对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作。  

3）指挥并控制CPU、主存、输入设备和输出设备之间的数据流动方向。  

根据控制器产生微操作控制信号的方式的不同，控制器可分为硬布线控制器和微程序控制器，两类控制器中的PC和IR是相同的，但确定和表示指令执行步骤的办法及给出控制各部件运行所需要的控制信号的方案是不同的。  
## 硬布线控制器  

硬布线控制器由复杂的组合逻辑门电路和触发器构成，也称组合逻辑控制器，其原理是根据指令的要求、当前的时序及内外部的状态，按时间的顺序发送一系列微操作控制信号。  

指令的操作码是决定控制单元（CU）发出不同控制信号的关键。为了简化CU的逻辑，将存放在 IR的 $n$ 位操作码经过译码电路产生 $2^{n}$ 个输出，每种操作码对应一个输出送至CU。如果将指令译码器和节拍发生器从CU中分离出来，便可得到简化的控制单元框图，如图5.10所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d2f55e758d9c494275dac108e2cae6bca95b683e62055bdffc92ff9c328afb53.jpg)  
图5.10带指令译码器和节拍输入的控制单元框图  

控制单元（CU）的输入信号来源如下：  

1）经指令译码器译码产生的指令信息。现行指令的操作码决定了不同指令在执行周期所需完成的不同操作，它与时钟配合产生不同的控制信号。2）时序系统产生的机器周期信号和节拍信号。为了使控制单元按一定的先后顺序、一定的节奏发出各个控制信号，控制单元必须受时钟控制。3）来自执行单元的反馈信息即标志。控制单元有时需依赖CPU当前所处的状态产生控制信号，如BAN指令，控制单元要根据上条指令的结果是否为负来产生不同的控制信号。  

图5.10中，节拍发生器产生各机器周期中的节拍信号，使不同的微操作命令 $C_{i}$ （控制信号）按时间的先后发出。个别指令的操作不仅受操作码控制，而且受到状态标志控制，因此CU的输入来自操作码译码电路ID、节拍发生器及状态标志，其输出到CPU内部或外部控制总线上。  

硬布线控制的功能由逻辑门组合实现，其速度主要取决于电路延迟，因此高速计算机中的关键核心部件CPU往往采用硬布线逻辑实现。因此，RISC一般都选用硬布线控制器。硬布线控制器的控制信号先用逻辑式列出，经化简后用电路来实现，因此显得零乱复杂，当需要修改或增加指令时就必须重新设计电路，非常麻烦。而且指令系统功能越全，微操作命令就越多，电路也就越庞杂，调试就更困难。为了克服这些缺点，便产生了微程序设计方法。  

## 微程序控制器  

微程序控制器采用存储逻辑实现，也就是将微操作信号代码化，使每条机器指令转化成为一段微程序并存入一个专门的存储器（控制存储器）中，微操作控制信号由微指令产生。  

### 微程序控制的基本概念  

微程序的设计思想就是将每条机器指令编写成一个微程序，每个微程序包含若干微指令，每条微指令对应一个或几个微操作命令。因此，执行一条指令的过程就是执行一个微程序的过程，这些微程序存储在一个控制存储器中。目前，大多数计算机都采用微程序设计技术。  
微程序设计技术涉及的基本术语如下。  

#### (1）微命令与微操作  

在微程序控制的计算机中，控制部件向执行部件发出的各种控制命令称为微命令，它是构成控制序列的最小单位。例如，打开或关闭某个控制门的电位信号、某个寄存器的打入脉冲等。执行部件收到微命令后所进行的操作称为微操作，微命令和微操作是一一对应的。  

微命令有相容性和互斥性之分。相容性微命令是指那些可以同时出现、共同完成某一些微操作的微命令；而互斥性微命令是指在机器中不允许同时出现的微命令。  

>##### attention:  

硬布线控制器中也有微命令与微操作的概念，并非微程序控制器的专有概念。  

#### （2）微指令与微周期  

微指令是若干微命令的集合，一条微指令通常至少包含两大部分信息：  

$\textcircled{\scriptsize{1}}$ 操作控制字段，也称微操作码字段，用于产生某一步操作所需的各种操作控制信号。  

$\circledcirc$ 顺序控制字段，也称微地址码字段，用于控制产生下一条要执行的微指令地址。  

微周期是指从控制存储器中取出并执行一条微指令所需的全部时间，通常为一个时钟周期。  

#### （3）主存储器与控制存储器  

>#### pro：主存储器和控制存储器的区别（2017）  

主存储器用于存放程序和数据，在CPU外部，用RAM实现。控制存储器（CM）用于存放微程序，在CPU内部，用ROM实现。存放微指令的控制存储器的单元地址称为微地址。  

####  （4）程序与微程序  

微程序和程序是两个不同的概念。程序是指令的有序集合，用于完成特定的功能。微程序是微指令的有序集合，用于描述机器指令，一条指令的功能由一段微程序来实现。微程序实际上是机器指令的实时解释器，是由计算机设计者事先编制好并存放在控制存储器中的，一般不提供给用户。对于程序员来说，系统中微程序的结构和功能是透明的，无须知道。程序最终由机器指令组成，并且由软件设计人员事先编制好并存放在主存储器或者辅助存储器中。  

读者应注意区分以下寄存器：  

$\textcircled{\scriptsize{1}}$ 地址寄存器（MAR）。用于存放主存的读/写地址。  

$\circledcirc$ 微指令地址寄存器（ $\upmu\mathrm{PC}$ 或CMAR)。用于存放待执行的微指令在控制存储器中的微地址。  

$\textcircled{3}$ 指令寄存器（IR）。用于存放从主存中读出的指令。  

$\textcircled{4}$ 微指令寄存器（ $\upmu\mathrm{{IR}}$ 或CMIDR）。用于存放从控制存储器中读出的微指令。  

### 微程序控制器的组成和工作过程  

#### （1）微程序控制器的基本组成  

图5.11所示为一个微程序控制器的基本结构，其主要部件包括：  

$\textcircled{\scriptsize{1}}$ 起始和转移地址形成部件（或简称微地址形成部件）。用于产生初始和后继微地址，以保证微指令的连续执行。  

$\textcircled{2}$ 微指令地址寄存器。接收微地址形成部件送来的微地址，为读取微指令做准备。  

$\textcircled{3}$ 控制存储器。它是微程序控制器的核心部件，用于存放各指令对应的微程序。  

$\textcircled{4}$ 微指令寄存器。其位数等于微指令字长。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/99c89003cac2ee2ef59dde11e4b8aa32720bdbcf83de761ecb39fd778d602223.jpg)  
图5.11微程序控制器的基本结构  

#### （2）微程序控制器的工作过程  

实际上就是在微程序控制器的控制下计算机执行机器指令的过程，这个过程可描述为：  

$\textcircled{\scriptsize{1}}$ 执行取指令公共操作。在机器开始运行时，自动地将取指微程序的入口地址送入 $\upmu\mathrm{PC}$ 并从CM中读出相应的微指令并送入 $\upmu\mathrm{IR}$ 。取指微程序的入口地址一般为CM的O号单元，取指微程序执行完成后，从主存中取出的机器指令就已存入指令寄存器中。 $\circledcirc$ 由机器指令的操作码字段通过微地址形成部件产生该机器指令所对应的微程序的入口地址，并送入 $\upmu\mathrm{PC}$  $\textcircled{3}$ 从CM中逐条取出对应的微指令并执行。 $\textcircled{4}$ 执行完对应于一条机器指令的一个微程序后，又回到取指微程序的入口地址，继续第 $^\mathrm{(Q)}$ 步，以完成取下一条机器指令的公共操作。以上是一条机器指令的执行过程，如此周而复始，直到整个程序执行完毕。  

####  （3）微程序和机器指令  

通常，一条机器指令对应一个微程序。由于任何机器指令的取指令操作都是相同的，因此可将取指令操作的微命令统一编成一个微程序，这个微程序只负责将指令从主存单元中取出并送至指令寄存器。此外，也可编写出对应间址周期的微程序和中断周期的微程序。这样，控制存储器中的微程序个数应为机器指令数再加上对应取指、间址和中断周期等公共的微程序数。  

### 微指令的编码方式  

微指令的编码方式也称微指令的控制方式，是指如何对微指令的控制字段进行编码，以形成控制信号。编码的目标是在保证速度的情况下，尽量缩短微指令字长。  

#### （1）直接编码（直接控制）方式  

微指令的直接编码方式如图5.12所示。直接编码法无须进行译码，微指令的操作控制字段中每一位都代表一个微命令。设计微指令时，选用或不选用某个微命令，只要将表示该微命令的对应位设置成1或0即可。每个微命令对应并控制数据通路中的一个微操作。  

这种编码的优点是简单、直观，执行速度快，操作并行性好；缺点是微指令字长过长， $n$ 个微命令就要求微指令的操作字段有 $n$ 位，造成控制存储器容量极大。  

#### （2）字段直接编码方式  

>#### pro：字段直接控制的编码方法（2012）  

将微指令的操作控制字段分成若干小字段，把互斥性微命令放在同一字段中，把相容性微命令放在不同字段中，每个字段独立编码，每种编码代表一个微命令且各字段编码含义单独定义，与其他字段无关，这就是字段直接编码方式，如图5.13所示。这种方式可以缩短微指令字长，但因为要通过译码电路后再发出微命令，因此比直接编码方式慢。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c6e197e941e2f1058a37b511cbaa37823f47acc90dd408d7e4f2e9e15c655007.jpg)  
图5.12直接编码方式  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a8f2b917f211c35fb07f59a18310c4809c207a77d2f9e952f169ab68cecd9625.jpg)  
图5.13字段直接编码方式  

微命令字段分段的原则：  

$\textcircled{\scriptsize{1}}$ 互厅性微命令分在同一段内，相容性微命令分在不同段内。  

$\circledcirc$ 每个小段中包含的信息位不能太多，否则将增加译码电路的复杂性和译码时间。  

$\textcircled{3}$ 一般每个小段还要留出一个状态，表示本字段不发出任何微命令。因此，当某字段的长度为3位时，最多只能表示7个互斥的微命令，通常用000表示不操作。  

#### （3）字段间接编码方式  

一个字段的某些微命令需由另一个字段中的某些微命令来解释，由于不是靠字段直接译码发出的微命令，因此称为字段间接编码，也称隐式编码。这种方式可进一步缩短微指令字长，但因削弱了微指令的并行控制能力，因此通常作为字段直接编码方式的一种辅助手段。  

### 微指令的地址形成方式  

后继微地址的形成主要有以下几个基本类型：  

1）由微指令的后继地址字段（也称下地址字段）指出

在微指令格式中设置一个后继地址字段，由微指令的后继地址字段直接指出后继微指令的地址，这种方式也称断定方式。  

2）根据机器指令的操作码形成

当机器指令取自指令寄存器后，微指令的地址由操作码经微地址形成部件形成，该部件输出的是对应机器指令微程序的首地址。  

3）增量计数器法，即 $(\upmu\mathrm{PC})+1{\rightarrow}\upmu\mathrm{PC}$ ，适用于后继微指令地址是连续的情况。  

4）根据各种标志决定下一条微指令分支转移的地址  

5）由硬件直接产生微程序入口地址。电源加电后，第一条微指令的地址可由专门的硬件电路产生，并送至 $\upmu\mathrm{PC}$ ，这个地址即为取指周期微程序的入口地址。  

### 微指令的格式  

微指令格式与微指令的编码方式有关，通常分为水平型微指令和垂直型微指令两种。  

>#### pro： 微指令后继地址字段位数与微指令条数的关系（2014）  

（1）水平型微指令  

从编码方式看，直接编码、字段直接编码和字段间接编码都属于水平型微指令。水平型微指令的基本指令格式如图5.14所示，指令字中的一位对应一个控制信号，有输出时为1，否则为0。一条水平型微指令定义并执行多个并行操作的微命令。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b2aedaa58c557759dbd6b0fe7d9c754a7d34a84fc4317965518d9de55c2fb6a1.jpg)  

水平型微指令的优点是微程序短，并行能力强，执行速度快；缺点是微指令长，编写微程序较麻烦。  

（2）垂直型微指令  

采用类似机器指令操作码的方式，在微指令字中设置微操作码字段，垂直型微指令的基本格式如图5.15所示。一条垂直型微指令通常只能定义并执行一种微命令。  
图5.15垂直型微指令格式
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7065d0c6793931c03ff4fb46419e81a29e8a05e3dc173555b1f656c5aa397918.jpg)  

垂直型微指令的优点是微指令短、简单、规整，便于编写微程序：缺点是微程序长，执行速 度慢，效率低。  

水平型微指令和垂直型微指令的比较如下：  

$\textcircled{\scriptsize{1}}$ 水平型微指令并行操作能力强、效率高、灵活性强：垂直型微指令则较差。 $\circledcirc$ 水平型微指令执行一条指令的时间短；：垂直型微指令执行的时间长。 $\textcircled{3}$ 用水平型微指令编写的微程序，微指令字较长但微程序短；垂直型微指令正好相反。 $\textcircled{4}$ 水平型微指令难以掌握；而垂直型微指令与机器指令比较相似，相对容易掌握。  

### 硬布线和微程序控制器的特点  

>#### pro：硬布线控制器和微程序控制器的特点（2009）  

（1）硬布线控制器的特点  

硬布线控制器的优点是由于控制器的速度取决于电路延迟，所以速度快；缺点是由于将控制部件视为专门产生固定时序控制信号的逻辑电路，所以把用最少元件和取得最高速度作为设计自标，一旦设计完成，就不可能通过其他额外修改添加新功能。  

（2）微程序控制器的特点  

相比组合逻辑控制器，微程序控制器的优点是具有规整性、灵活性和可维护性；缺点是由于微程序控制器采用了存储程序原理，所以每条指令都要从控制存储器中取一次，影响速度。  

为便于比较，下面以表格的形式对比二者的不同，见表5.1。  

表5.1微程序控制器与硬布线控制器的对比
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5758d88c281f323689f1a57cbe9859540b34d296985c6fd404c91be129bd19f0.jpg)  


# 异常和中断机制  

现代计算机中都配有完善的异常和中断处理系统，CPU的数据通路中有和应的异常检测和响应逻辑，外设接口中有相应的中断请求和控制逻辑，操作系统中有相应的中断服务程序。这些中断硬件电路和中断服务程序有机结合，共同完成异常和中断的处理过程。  

## 基本概念  

>#### pro： 异常事件的性质（2015）  

由CPU内部产生的意外事件被称为异常，有些教材中也称内中断。由来自CPU外部的设备向CPU发出的中断请求被称为中断，通常用于信息的输入和输出，有些教材中也称外中断。异常是CPU执行一条指令时，由CPU在其内部检测到的、与正在执行的指令相关的同步事件；中断是一种典型的由外部设备触发的、与当前正在执行的指令无关的异步事件。  

>#### pro：异常响应的时机（2023）  

异常和中断处理过程的描述如下：若CPU在执行用户程序的第 $i$ 条指令时检测到一个异常事件，或者执行第 $i$ 条指令后发现一个中断请求信号，则CPU打断当前程序，然后转去执行相应的异常或中断处理程序。若异常或中断处理程序能够解决相应的问题，则在异常或中断处理程序的最后，CPU通过执行异常或中断返回指令，回到被打断的用户程序的第 $i$ 条指令或第 $i+1$ 条指令继续执行；若异常或中断处理程序发现是不可恢复的致命错误，则终止用户程序。通常情况下，对异常和中断的具体处理过程由操作系统（和驱动程序）完成。  

异常和中断的处理过程基本是相同的，这也是有些教材将两者统称为中断的原因  

## 分类  

### 异常的分类  

异常是由CPU内部产生的意外事件，分为硬故障中断和程序性异常。硬故障中断是由硬连线出现异常引起的，如存储器校验错、总线错误等。程序性异常也称软件中断，是指在CPU内部因执行指令而引起的异常事件。如整除0、溢出、断点、单步跟踪、非法指令、栈溢出、地址越界、缺页等。按异常发生原因和返回方式的不同，可分为故障、自陷和终止。  

#### （1）故障（Fault）  

>#### pro：异常或中断处理后指令重新执行的断点（2021）  

指在引起故障的指令启动后、执行结束前被检测到的异常事件。例如，指令译码时，出现“非法操作码”；取数据时，发生“缺段”或“缺页”执行整数除法指令时，发现“除数为0”等。  
对于“缺段”“缺页”等异常事件，经处理后，可将所需的段或页面从磁盘调入主存，回到发生故障的指令继续执行，断点为当前发生故障的指令；对于“非法操作码”“除数为0”等，因为无法通过异常处理程序恢复故障，因此不能回到原断点执行，必须终止进程的执行。  

#### (2）自陷（Trap）  

>#### pro：自陷的原理和性质（2020）  

自陷也称陷阱或陷入，它是预先安排的一种“异常”事件，就像预先设定的“陷阱”一样。通常的做法是：事先在程序中用一条特殊指令或通过某种方式设定特殊控制标志来人为设置一个“陷阱”，当执行到被设置了“陷阱”的指令时，CPU在执行完自陷指令后，自动根据不同“陷阱”类型进行相应的处理，然后返回到自陷指令的下一条指令执行。注意，当自陷指令是转移指令时，开不是返回到下一条指令执行，而是返回到转移目标指令执行。  

在x86机器中，用于程序调试“断点设置”和单步跟踪的功能就是通过陷阱机制实现的。此外，系统调用指令、条件自陷指令（如MiPS中的teq、teqi、tne、tnei等）等都属于陷阱指令，执行到这些指令时，无条件或有条件地自动调出操作系统内核程序进行执行。  

故障异常和自陷异常属于程序性异常（软件中断）。  

#### （3）终止（Abort）  

如果在执行指令的过程中发生了使计算机无法继续执行的硬件敌障，如控制器出错、存储器校验错、总线错误等，那么程序将无法继续执行，只能终止，此时，调出异常服务程序来重启系统。这种异常与敌障和自陷不同，不是由特定指令产生的，而是随机发生的。  

终止异常和外中断属于硬件中断。  

### 中断的分类  

>#### pro：对中断和异常事件的判断（2009、2016、2020）  

中断是指来自CPU外部、与CPU执行指令无关的事件引起的中断，包括I/O设备发出的I/O中断（如键盘输入、打印机缺纸等），或发生某种特殊事件（如用户按Esc键、定时器计数时间到）等。外部I/O设备通过特定的中断请求信号线向CPU提出中断请求，CPU每执行完一条指令就检查中断请求信号线，如果检测到中断请求，则进入中断响应周期。  

中断可分为可屏蔽中断和不可屏蔽中断。  

####  （1）可屏蔽中断  

指通过可屏蔽中断请求线INTR向CPU发出的中断请求。CPU可以通过在中断控制器中设置相应的屏蔽字来屏蔽它或不屏蔽它，被屏蔽的中断请求将不被送到CPU。  

####  （2）不可屏蔽中断  

指通过专门的不可屏蔽中断请求线NMI向CPU发出的中断请求，通常是非常紧急的硬件故障，如电源掉电等。这类中断请求信号不可被屏蔽，以让CPU快速处理这类紧急事件。  

中断和异常在本质上是一样的，但它们之间有以下两个重要的不同点：  

1）“缺页”或“溢出”等异常事件是由特定指令在执行过程中产生的，而中断不和任何指令相关联，也不阻止任何指令的完成。  

2）异常的检测由CPU自身完成，不必通过外部的某个信号通知CPU。对于中断，CPU必须通过中断请求线获取中断源的信息，才能知道哪个设备发生了何种中断。  
此外，根据识别中断服务程序地址的方式，可分为向量中断和非向量中断：根据中断处理过程是否允许被打断，还可分为单重中断和多重中断。  

## 异常和中断响应过程  

CPU执行指令时，如果发生了异常或中断请求，必须进行相应的处理。从CPU检测到异常或中断事件，到调出相应的处理程序，整个过程称为异常和中断响应。CPU对异常和中断响应的过程可分为关中断、保存断点和程序状态、识别异常和中断并转到相应的处理程序。  

（1）关中断  

在保存断点和程序状态期间，不能被新的中断打断，因此要禁止响应新的中断，即关中断。通常通过设置“中断允许”（IF）触发器来实现，若IF置为1，则为开中断，表示允许响应中断；若F置为0，则表示关中断，表示不充许响应中断。  

（2）保存断点和程序状态  

为了能在异常和中断处理后正确返回到被中断的程序继续执行，必须将程序的断点（返回地址）送到栈或特定寄存器中。通常保存在栈中，这是为了支持异常或中断的嵌套。  

异常和中断处理后可能还要回到被中断的程序继续执行，被中断时的程序状态字寄存器PSW的内容也需要保存在栈或特定寄存器中，在异常和中断返回时恢复到PSW中。  

（3）识别异常和中断并转到相应的处理程序  

异常和中断源的识别有软件识别和硬件识别两种方式。异常和中断源的识别方式不同，异常大多采用软件识别方式，而中断可以采用软件识别方式或硬件识别方式。  

软件识别方式是指CPU设置一个异常状态寄存器，用于记录异常原因。操作系统使用一个统一的异常或中断查询程序，按优先级顺序查询异常状态寄存器，以检测异常和中断类型，先查询到的先被处理，然后转到内核中相应的处理程序。  

硬件识别方式也称向量中断，异常或中断处理程序的首地址称为中断向量，所有中断向量都存放在中断向量表中。每个异常或中断都被指定一个中断类型号。在中断向量表中，类型号和中断向量一一对应，因而可以根据类型号快速找到对应的处理程序。  

整个响应过程是不可被打断的。中断响应过程结束后，CPU就从PC中取出对应中断服务程序的第一条指令开始执行，直至中断返回，这部分任务是由CPU通过执行中断服务程序完成的，整个中断处理过程是由软/硬件协同实现的。  
 

# 指令流水线  

前面介绍的指令都是在单周期处理机中采用串行方法执行的，同一时刻CPU中只有一条指令在执行，因此各功能部件的使用率不高。现代计算机普遍采用指令流水线技术，同一时刻有多条指令在CPU的不同功能部件中并发执行，大大提高了功能部件的并行性和程序的执行效率。  

## 基本概念
可从两方面提高处理机的并行性： $\textcircled{\scriptsize{1}}$ 时间上的并行技术，将一个任务分解为几个不同的子阶段，每个子阶段在不同的功能部件上并行执行，以使在同一时刻能够同时执行多个任务，进而提升系统性能，这种方法被称为流水线技术。 $\circledcirc$ 空间上的并行技术，在一个处理机内设置多个执行相同任务的功能部件，并让这些功能部件并行工作，这样的处理机被称为超标量处理机。  

一条指令的执行过程可分解为若干阶段，每个阶段由相应的功能部件完成。如果将各阶段视为相应的流水段，则指令的执行过程就构成了一条指令流水线。  

假设一条指令的执行过程分为如下5个阶段（也称功能段或流水段）?：  

·取指（IF）：从指令存储器或Cache中取指令。·译码/读寄存器（ID）：操作控制器对指令进行译码，同时从寄存器堆中取操作数。·执行/计算地址（EX）：执行运算操作或计算地址。·访存（MEM）：对存储器进行读/写操作。·写回（WB）：将指令执行结果写回寄存器堆。  
把 $k+1$ 条指令的取指阶段提前到第 $k$ 条指令的译码阶段，从而将第 $k+1$ 条指令的译码阶段与第 $k$ 条指令的执行阶段同时进行，如图5.16所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4e4d3b2fd28bf010d15ebe5c04890299db4e9d522cfa5616dd58c870df156a3c.jpg)  
图5.16一个5段指令流水线  

从图5.16看出，理想情况下，每个时钟周期都有一条指令进入流水线，每个时钟周期都有一条指令完成，每条指令的时钟周期数（即CPI）都为1。  

>#### pro：流水线对指令集的要求（2011）  

为了利于实现指令流水线，指令集应具有如下特征：  

1）指令长度应尽量一致，有利于简化取指令和指令译码操作。否则，取指令所花的时间长短不一，使得取指部件极其复杂，并且也不利于指令译码。  

2）指令格式应尽量规整，尽量保证源寄存器的位置相同，有利于在指令未知时就可取寄存器操作数，否则须译码后才能确定指令中各寄存器编号的位置。  

3）采用LOAD/STORE型指令，其他指令都不能访问存储器，这样可把LOAD/STORE指令的地址计算和运算指令的执行步骤规整在同一个周期中，有利于减少操作步骤。  

4）数据和指令在存储器中“按边界对齐”存放。这样，有利于减少访存次数，使所需数据在一个流水段内就能从存储器中得到。  

## 基本实现  

### 设计原则  

在单周期实现中，虽然不是所有指令都必须经历完整的5个阶段，但只能以执行速度最慢的指令作为设计其时钟周期的依据，单周期CPU的时钟频率取决于数据通路中的最长路径。  

>#### pro：流水线时钟周期的设计（2009）  

流水线设计的原则： $\textcircled{\scriptsize{1}}$ 指令流水段个数以最复杂指令所用的功能段个数为准： $\circledcirc$ 流水段的长度以最复杂的操作所花的时间为准。假设某条指令的5个阶段所花的时间分别如下。 $\textcircled{\scriptsize{1}}$ 取指： $200\mathrm{ps}$ ； $\circledcirc$ 译码： $100\mathrm{ps}$  $\textcircled{3}$ 执行： $150\mathrm{ps}$  $\textcircled{4}$ 访存： $200\mathrm{ps}$ ； $\textcircled{5}$ 写回： $100\mathrm{ps}$ ，该指令的总执行时间为750ps。按照流水线设计原则，每个流水段的长度为 $200\mathrm{ps}$ ，所以每条指令的执行时间为1ns，反而比串行执行时增加了 $250\mathrm{ps}$ 。假设某程序有 $N$ 条指令，单周期处理机所用的时间为 $N{\times}750\mathrm{ps}$ 而流水线处理机所用的时间为 $(N+4){\times}200\mathrm{ps}$ 。由此可见，流水线方式并不能缩短单条指令的执行时间，但对于整个程序来说，执行效率得到了大幅提高。  

### 逻辑结构  

每个流水段后面都要增加一个流水段寄存器，用于锁存本段处理完的所有数据，以保证本段的执行结果能在下个时钟周期给下一流水段使用，如图5.17所示。各种寄存器和数据存储器均采用统一时钟CLK进行同步，每来一个时钟，各段处理完的数据都将锁存到段尾的流水段寄存器中，作为后段的输入。同时，当前段也会收到前段通过流水段寄存器传递过来的数据。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/15dad3e9b41ca386ed07524528163648ddba3b917ff3c224e8e9b044083935c5.jpg)  
图5.17流水线的逻辑结构图  

一条指令会依次进入IF、ID、EX、MEM、WB五个功能段进行处理，第一条指令进入WB段后，各流水段都包含一条不同的指令，流水线中将同时存在5条不同的指令并行执行。  

>#### pro： 存在流水段寄存器时延的时钟周期的设计（2018）  

>##### attention:  

在考试中，若没有明确说明，则可以不用考虑流水寄存器的时延。  

### 时空图表示  

通常用时空图来直观地描述流水线的执行情况，如图5.18所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8f92b2589c2fe4694603f3c9894919d540ed16f5065d6218d79024a19ab46846.jpg)  
图5.18一个5段指令流水线时空图  

在时空图中，横坐标表示时间，它被分割成长度相等的时间段 $T$ ；纵坐标为空间，表示当前指令所处的功能部件。在图5.18中，第一条指令 $\mathrm{I}_{1}$ 在时刻0进入流水线，在时刻5T流出流水线。第二条指令 $\mathrm{I}_{2}$ 在时刻 $T$ 进入流水线，在时刻6T流出流水线。以此类推，每隔一个时间 $T$ 就有一条指令进入流水线，从时刻5T开始每隔一个时间  $T$  就有一条指令流出流水线。  

>#### pro：流水线执行4条指令所需的时钟周期数（2012）  

从图5.18中可看出，在时刻 $10T$ 时，流水线上便有6条指令流出。若采用串行方式执行，在时刻10T时，只能执行2条指令，可见使用流水线方式成倍地提高了计算机的速度。  

只有大量连续任务不断输入流水线，才能充分发挥流水线的性能，而指令的执行正好是连续不断的，非常适合采用流水线技术。对于其他部件级流水线，如浮点运算流水线，同样也仅适合于提升浮点运算密集型应用的性能，对于单个运算是无法提升性能的。  

## 冒险与处理  

>#### pro：导致流水线阻塞的各种原因（2010）  

在指令流水线中，可能会遇到一些情况使得后续指令无法正确执行而引起流水线阻塞，这利现象称为流水线冒险。根据导致冒险的原因不同分为结构冒险、数据冒险和控制冒险3种。  

不同类型指令在各流水段的操作是不同的，表5.2中列出了几类指令在各流水段中的操作。  
表5.2不同类型指令在各流水段中的操作
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0e6ae322ef1d230d3622eda619a0b7d751d40c5ad99cf6bbc3f88c1bdf5ad624.jpg)  

这几类指令将会在下面介绍流水线冲突时涉及。  

### 结构冒险  

>#### pro：解决结构冒险的办法（2016）  

由不同指令在同一时刻争用同一功能部件而形成的冲突，也称资源冲突，即由硬件资源竞争造成的冲突。例如，指令和数据通常都存放在同一存储器中，在第4个时钟周期，第i条LOAD指令进入MEM段时，第 $i+3$ 条指令的F段也要访存取指令，此时会发生访存冲突，为此可在前一条指令访存时，暂停（一个时钟周期）取后一条指令的操作，如表5.3所示。当然，如果第 $i$ 条指令不是LOAD指令，在IMEM段不访存，也就不会发生访存冲突。  

表5.3用暂停后续指令的方法解决访存冲突
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2db4430898a15d3389f6aa6bbb2b0286feb1c27b0fc3560cab05120628e43091.jpg)  

解决结构冲突有以下两种办法：  

1）前一指令访存时，使后一条相关指令（及其后续指令）暂停一个时钟周期。  

2）设置多个独立的部件。例如，对于寄存器访问冲突，可将寄存器的读口和写口独立开来：对于访存冲突，单独设置数据存储器和指令存储器。在现代Cache机制中，L1级Cache通常采用数据Cache和指令Cache分离的方式，从而也就避免了资源冲突的发生。  

### 数据冒险  

>#### pro：分析指令之间的数据冒险（2012、2014、2016、2019、2023）  

数据冒险也称数据相关。引起数据冒险的原因是，后面指令用到前面指令的结果时，前面指令的结果还没有产生。在以非乱序执行的流水线中，所有数据冒险都是由于前面指令写结果之前，后面指令就需要读取而造成的，这种数据冒险称为写后读（ReadAfterWrite，RAW）冲突。  

>##### attention:  

在按序执行?的流水线中（统考中通常采用这种方式），只可能出现RAW冲突。  
例如，考虑下列两条指令：  

I1 addR1,R2,R3 I2 sub R4,R1,R5 #（R2）+（R3）→R1

 #（R1)-（R5）→R4 在写后读（RAW）冲突中，指令I2的源操作数是指令I1的目的操作数。正常的读/写顺序是  

由指令IⅡ1先写入R1，再由指令12来读R1。在非流水线中，这种先写后读的顺序是自然维持的。但在流水线中，由于重叠操作，读/写的先后顺序关系发生了变化，如表5.4所示。  

表5.4add和sub指令发生先写后读（RAW）冲突
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/416a1a3afa37aaf5df2546bab8ffd540b1a22415785989ec06871e8242ff2a92.jpg)  

可以采用以下几种办法解决RAW数据冲突。  

（1）延迟执行相关指令  

把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行，可分为软件插入空操作“nop”指令和硬件阻塞（stall）两种方法。  

由表5.4可见，在第5个时钟周期，add指令才将运算结果写入Rl，但后继sub指令在第3个时钟周期就要从R1中读数，使先写后读的顺序改变为先读后写，发生了先写后读（RAW）的数据冲突。如果不采取措施，按表5.4的读/写顺序，就会导致结果出错。为此，可以暂停sub指令3个时钟周期，直至前面add指令的结果生成，如表5.5所示。  

表5.5用延迟相关指令的办法来解决RAW冲突
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/83b58f5125520e327f2952f138d8b8e3e1c011a0b53539439425dabca2d3aec6.jpg)  

对于11和12的数据相关问题，还可以通过将寄存器的写口和读口分别控制在前、后半个时钟周期内操作，使前半周期写入R1的值在后半周期马上被读出，在一个周期内读/写寄存器不会产生冲突，这样I1的WB段和I2的ID段就可重叠执行，从而只需延迟2个时钟周期。  

（2）采用转发（旁路）技术  

设置相关转发通路，不等前一条指令把计算结果写回寄存器，下一条指令也不再从寄存器读，而将数据通路中生成的中间数据直接转发到ALU的输入端。如表5.6所示，指令I1在EX段结束时已得到R1的新值，被存放到EX/MEM流水段寄存器中，因此可以直接从该流水段寄存器中取出数据返送到ALU的输入端，这样，在指令I2执行时ALU中用的就是R1的新值。  

表5.6用转发技术来解决RAW冲突
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6e66822789ad2aac996fbfbdb4f43c39d585688d099743e0d47d9ac80812a914.jpg)  

增加转发通路后，相邻两条运算类指令之间、相隔一条的两个运算类指令之间的数据相关带来的数据冒险问题就都能解决了。  
（3）load-use数据冒险的处理  

如果1oad指令与其后紧邻的运算类指令存在数据相关问题，则无法通过转发技术来解决，通常把这种情况称为load-uise数据冒险。对于下列两条指令，由表5.2可知，load指令只有在MEM段结束时才能得到主存中的结果，然后送MEM/WB流水段寄存器，在WB段的前半周期才能存入R2的新值，但随后的add指令在EX阶段就要取R2的值，因此，得到的是旧值。  

I2 load r2,12(r1) #M[（r1)+12]→（r2) I3 add r4,r3,r2 #  $(\mathfrak{r}3)+(\mathfrak{r}2)\to(\mathfrak{r}4)$  

对于load-use数据冒险，最简单的做法是由编译器在add指令之前插入一条nop指令，这样在add指令的EX段就可以从MEM/WB流水段寄存器中取出load指令的最新结果，如表5.7所示。当然，最好的办法是在程序编译时进行优化，通过调整指令顺序以避免出现load-use现象。  

表5.7用延迟加转发技术来解决load-use冲突
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d8f74604a1f7296c5efc84ccc1b539219931dc8dd2633e2e187d4d2cf904438d.jpg)  

### 控制冒险  

>#### pro：分析指令之间的控制冒险（2014、2023）  

指令通常是顺序执行的，但当遇到改变指令执行顺序的情况，例如执行转移或返回指令、发生中断或异常时，会改变PC值，从而造成断流，也称控制冲突。  

对于由转移指令引起的冲突，最简单的处理方法就是推迟后续指令的执行。通常把因流水线阻塞带来的延迟时钟周期数称为延迟损失时间片 $C$ 。在下列指令中，假设R2存放常数N，R1的初值为1，bne指令在EX段通过计算设置条件码，并在MEM段确定是否将PC值更新为转移目的地址，因此仅当bne指令执行到第5个时钟结束时才能将转移目标地址送PC。为此，在数据通路检测到分支指令后，可以在分支指令后插入 $C$ (此处 $C=3$ ）条nop指令，如表5.8所示。  

I1loop:add Rl,Rl, $\#\left(\mathbb{R}\mathbb{1}\right)+\mathbb{1}\!\rightarrow\!\mathbb{R}\mathbb{1}$ I2 bne R1,R2,loop #if(R1)  $!=(\mathbb{R}^{2}$  ）goto loop  

表5.8用插入空操作的办法解决控制冲突
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5d0c7063bc5e9cb5cf392f3925551cca3ebbfb37ad2e468043801a4c994d2fcf.jpg)  

有以下几种办法解决控制冲突：  

1）对于由转移指令引起的冲突，可采用和解决数据冲突相同的软件插入“nop”指令和硬件阻塞（stall）的方法。比如，延迟损失多少时间片，就插入多少条nop指令。  

2）对转移指令进行分支预测，尽早生成转移目标地址。分支预测分为简单（静态）预测和动态预测。若静态预测的条件总是不满足，则按序继续执行分支指令的后续指令。动态 预测根据程序转移的历史情况，进行动态预测调整，有较高的预测准确率。  

>##### attention:  

Cache缺失的处理过程也会引起流水线阻塞。  
## 性能指标  

1.流水线的吞吐率
>#### pro：  流水线吞吐率的计算（2013）  

流水线的吞吐率是指在单位时间内流水线所完成的任务数量，或输出结果的数量。流水线吞吐率（TP）的最基本公式为  

$$
\mathrm{TP}\,{=}\,\frac{n}{T_{k}}
$$  

式中， $n$ 是任务数， $T_{k}$ 是处理完 $n$ 个任务所用的总时间。设 $k$ 为流水段的段数， $\Delta t$ 为时钟周期。在输入流水线中的任务连续的理想情况下，一条 $k$ 段流水线能在 $k+n-1$ 个时钟周期内完成 $n$ 个任务。得出流水线的吞吐率为  

$$
\mathrm{TP}=\frac{n}{(k+n-1)\Delta t}
$$  

连续输入的任务数 $n{\rightarrow}\infty$ 时，得到最大吞吐率为 $\mathrm{TP}_{\mathrm{max}}\,{=}1/\Delta t$  

### 流水线的加速比  

完成同样一批任务，不使用流水线与使用流水线所用的时间之比。  

流水线加速比（S）的基本公式为  

$$
S=\frac{T_{0}}{T_{k}}
$$  

式中， $T_{0}$ 表示不使用流水线的总时间： $T_{k}$ 表示使用流水线的总时间。一条 $k$ 段流水线完成 $n$ 个任务所需的时间为 $T_{k}=\left(k+n-1\right)\Delta t$ 。顺序执行 $n$ 个任务时，所需的总时间为 $T_{0}=\left\boldsymbol{k n}\,\Delta t\right.$ 。将 $T_{0}$ 和 $T_{k}$ 值代入上式，得出流水线的加速比为  

$$
S=\frac{k n\Delta t}{(k+n-1)\Delta t}\!=\!\frac{k n}{k+n-1}
$$  

连续输入的任务数 $n{\rightarrow}\infty$ 时，得最大加速比为 $S_{\mathrm{max}}\,{=}\,k,$  

## 高级流水线技术  

有两种增加指令级并行的策略：一种是多发射技术，它通过采用多个内部功能部件，使流水线功能段能同时处理多条指令，处理机一次可以发射多条指令进入流水线执行：另一种是超流水线技术，它通过增加流水线级数来使更多的指令同时在流水线中重叠执行。  

### 超标量流水线技术  

>#### pro：  

也称动态多发射技术，每个时钟周期内可并发多条独立指令，以并行操作方式将两条或多条指令编译并执行，为此需配置多个功能部件，如图5.19所示。在简单的超标量CPU中，指令是按顺序发射执行的。为了更好地提高并行性能，多数超标量CPU都结合动态流水线调度技术，通过动态分支预测等手段，指令不按顺序执行，这种方式称为乱序执行。  

### 超长指令字技术  

也称静态多发射技术，由编译程序挖掘出指令间潜在的并行性，将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字（可达几百位），为此需要采用多个处理部件。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3fb915064ad6368ced430ed580e5bb36216c80da07ef16f0bb6a2923dd9be00f.jpg)  
图5.19超标量流水线技术  

### 超流水线技术  

如图5.20所示，流水线功能段划分得越多，时钟周期就越短，指令吞吐率也就越高，因此超流水线技术是通过提高流水线主频的方式来提升流水线性能的。但是，流水线级数越多，用于流水寄存器的开销就越大，因而流水线级数是有限制的，并不是越多越好。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/742aac8f955fdb4c6ca794363252545db1e5f37ff8e48bc846bf71986d0fa0d6.jpg)  
图5.20超流水线技术  

>#### pro：基本流水线CPU和超标量流水线CPU的CPI（2020）  

超流水线CPU在流水线充满后，每个时钟周期还是执行一条指令， ${\mathrm{CPI}}=1$ ，但其主频更高：多发射流水线CPU每个时钟周期可以处理多条指令， $\mathrm{CPI}\!<\!1$ ，但其成本更高、控制更复杂。  

 
# 多处理器的基本概念  

>#### pro： 多处理器的基本概念（2022）  

## SISD、SIMD、MIMID的基本概念  

基于指令流的数量和数据流的数量，将计算机体系结构分为SISD、SIMD、MISD和MIMD四类。常规的单处理器属于SISD，而常规的多处理器属于MIMD。  

### 单指令流单数据流（SISD）结构  

SISD是传统的事行计算机结构，这种计算机通常仅包含一个处理器和一个存储器，处理器在一段时间内仅执行一条指令，按指令流规定的顺序串行执行指令流中的若干指令。为了提高速度，有些SISD计算机采用流水线的方式，因此，SISD处理器有时会设置多个功能部件，并且采用多模块交叉方式组织存储器。本书前面介绍的内容多属于SISD结构。  

### 单指令流多数据流（SIMID）结构  

SIMID是指一个指令流同时对多个数据流进行处理，一般称为数据级并行技术。这种结构的计算机通常由一个指令控制部件、多个处理单元组成。每个处理单元虽然执行的都是同一条指令，但是每个单元都有自己的地址寄存器，这样每个单元就都有不同的数据地址，因此，不同处理单元执行的同一条指令所处理的数据是不同的。一个顺序应用程序被编译后，既可能按SISD组织并运行于事行硬件上，又可能按SIMID组织并运行于并行硬件上。  

SIMD在使用for循环处理数组时最有效，比如，一条分别对16对数据进行运算的SIMID指令如果在16个ALU中同时运算，则只需要一次运算时间就能完成运算。SIMD在使用case或switch语句时效率最低，此时每个执行单元必须根据不同的数据执行不同的操作。  

### 多指令流单数据流（MISD）结构  

MISD是指同时执行多条指令，处理同一个数据，实际上不存在这样的计算机。  

### 多指令流多数据流（MIIMID）结构  

MIMD是指同时执行多条指令分别处理多个不同的数据，MIMID分为多计算机系统和多处理器系统。多计算机系统中的每个计算机节点都具有各自的私有存储器，并且具有独立的主存地址空间，不能通过存取指令来访问不同节点的私有存储器，而要通过消息传递进行数据传送，也称消息传递MIIMID。多处理器系统是共享存储多处理器（SMP）系统的简称，它具有共享的单一地址空间，通过存取指令来访问系统中的所有存储器，也称共享存储MIIMID。  

向量处理器是SIMID的变体，是一种实现了直接操作一维数组（向量）指令集的CPU，而串行处理器只能处理单一数据集。其基本理念是将从存储器中收集的一组数据按顺序放到一组向量寄存器中，然后以流水化的方式对它们依次操作，最后将结果写回寄存器。向量处理器在特定工作环境中极大地提升了性能，尤其是在数值模拟或者相似的领域中。  

SIMD和MIMD是两种并行计算模式，其中SIIMD是一种数据级并行模式，而MIMD是一种并行程度更高的线程级并行或线程级以上并行计算模式。  
## 硬件多线程的基本概念  

在传统CPU中，线程的切换包含一系列开销，频繁地切换会极大影响系统的性能，为了减少线程切换过程中的开销，便诞生了硬件多线程。在支持硬件多线程的CPU中，必须为每个线程提供单独的通用寄存器组、单独的程序计数器等，线程的切换只需激活选中的寄存器，从而省略了与存储器数据交换的环节，大大减少了线程切换的开销。  

硬件多线程有3种实现方式：细粒度多线程、粗粒度多线程和同时多线程（SMT）。  

### 细粒度多线程  

多个线程之间轮流交叉执行指令，多个线程之间的指令是不相关的，可以乱序并行执行。在这种方式下，处理器能在每个时钟周期切换线程。例如，在时钟周期i，将线程A中的多条指令发射执行；在时钟周期 $\mathrm{i}+1$ ，将线程B中的多条指令发射执行。  

### 粗粒度多线程  

连续几个时钟周期都执行同一线程的指令序列，仅在当前线程出现了较大开销的阻塞时，才切换线程，如Cache缺失。在这种方式下，当发生流水线阻塞时，必须清除被阻塞的流水线，新线程的指令开始执行前需要重载流水线，因此，线程切换的开销比细粒度多线程更大。  

上述两种多线程技术都实现了指令级并行，但线程级不并行。  

### 同时多线程  

同时多线程（SMT）是上述两种多线程技术的变体。它在实现指令级并行的同时，实现线程级并行，也就是说，它在同一个时钟周期中，发射多个不同线程中的多条指令执行。  

图5.21分别是三种硬件多线程实现方式的调度示例。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/fe12e3816bacd5ce1624427dc34539902f856a1a779a1dfcb27e86ac5ec6d5bd.jpg)  

Intel处理器中的超线程（Hyper-threading）就是同时多线程SMT，即在一个单处理器或单个核中设置了两套线程状态部件，共享高速缓存和功能部件。  

## 多核处理器的基本概念  

多核处理器是指将多个处理单元集成到单个CPU中，每个处理单元称为一个核（core），通常也称片上多处理器。每个核既可以有自己的Cache，又可以共享同一个Cache，所有核通常共享主存储器。图5.22是一个不共享Cache的双核CPU结构。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4e190cda79c5d3789bba4003dd4e0cf2eedc2899411a4baf8ced7fc668357302.jpg)  
图5.22不共享Cache的双核CPU结构  

在多核计算机系统中，如要充分发挥硬件的性能，必须采用多线程（或多进程）执行，使得每个核在同一时刻都有线程在执行。与单核上的多线程不同，多核上的多个线程是在物理上并行执行的，是真正意义上的并行执行，在同一时刻有多个线程在并行执行。而单核上的多线程是一种多线程交错执行，实际上在同一时刻只有一个线程在执行。  

下面通过一个例子来理解相关的概念。假设要将四颗圆石头滚到马路对面，滚动每颗石头平均需花费1分钟。串行处理器会逐一滚动每颗石头，花费4分钟。拥有两个核的多核处理器让两个人滚石头，即每人滚两颗，花费2分钟。向量处理器找到一根长木板，放在四颗石头后面，推动木板即可同时滚动四块石头，理论上只要力量够大，就只需要1分钟。多核处理器相当于拥有多名工人，而向量处理器拥有一种方法，可以同时对多件事进行相同的操作。  

## 共享内存多处理器的基本概念  

具有共享的单一物理地址空间的多处理器称为共享内存多处理器（SIMIP）。处理器通过存储器中的共享变量互相通信，所有处理器都能通过存取指令访问存储器的任何位置。注意，即使这些系统共享同一个物理地址空间，它们仍然可在自己的虚拟地址空间中单独地运行程序。  

单一地址空间的多处理器有两种类型：  

·统一存储访问（UMA）多处理器。每个处理器对所有存储单元的访问时间是大致相同的，即访问时间与哪个处理器提出访存请求及访问哪个字无关。·非统一存储访问（NUMA）多处理器。某些存储器的访存速度要比其他的快，具体取决于哪个处理器提出访问请求及访问哪个字，这是由于主存被分割分配给了不同处理器。  

早期的计算机，内存控制器没有整合进CPU，访存操作需要经过北桥芯片（集成了内存控制器，并与内存相连），CPU通过前端总线和北桥芯片相连，这就是统一存储访问（UMA）构架。随着CPU性能提升由提高主频转到增加CPU数量（多核、多CPU），越来越多的CPU对前端总线的争用使得前端总线成为瓶颈。为了消除UMA架构的瓶颈，非统一存储访问（NUMA）构架诞生，内存控制器被集成到CPU内部，每个CPU都有独立的内存控制器。每个CPU都独立连接到一部分内存，CPU直连的这部分内存被称为本地内存。CPU之间通过QPI总线相连。CPU可以通过QPI总线访问其他CPU的远程内存。与UMA架构不同的是，在NUMA架构下，内存的访问出现了本地和远程的区别，访问本地内存明显要快于访问远程内存。  

由于可能会出现多个处理器同时访问同一共享变量的情况，在操作共享变量时需要进行同步，否则，一个处理器可能会在其他处理器尚未完成对共享变量的修改时，就开始使用该变量。常用方法是通过对共享变量加锁的方式来控制对共享变量互斥访问。在一个时刻只能有一个处理器获得锁，其他需要操作该共享变量的处理器必须等待，直到该处理器解锁该变量为止。  
第3章讨论的一致性是指Cache与主存之间的数据一致性。在UMA构架的多处理器中，所有CPU共享同一内存空间，每个CPU的Cache都是共享内存中的一部分副本，因此多核系统的Cache一致性既包括Cache和内存之间的一致性，还包括各CPU的Cache之间的一致性，也就是说，对内存同一位置的数据，不同CPU的Cache不应该有不一致的内容。  


#  本章小结  

本章开头提出的问题的参考答案如下。  

1）指令和数据均存放在内存中，计算机如何从时间和空间上区分它们是指令还是数据？  

从时间上讲，取指令事件发生在“取指周期”，取数据事件发生在“执行周期”。从空间上讲，从内存读出的指令流流向控制器（指令寄存器），从内存读出的数据流流向运算器（通用寄存器）  

2）什么是指令周期、机器周期和时钟周期？它们之间有何关系？  

CPU每取出并执行一条指令所需的全部时间称为指令周期；机器周期是在同步控制的机器中，执行指令周期中一步相对完整的操作（指令步）所需的时间，通常安排机器周期长度 $=$ 主存周期；时钟周期是指计算机主时钟的周期时间，它是计算机运行时最基本的时序单位，对应完成一个微操作所需的时间，通常时钟周期 $=$ 计算机主频的倒数。  
3）什么是微指令？它和第4章谈到的指令有什么关系？  

控制部件通过控制线向执行部件发出各种控制命令，通常把这种控制命令称为微命令，而一组实现一定操作功能的微命令的组合，构成一条微指令。许多条微指令组成的序列构成微程序， 微程序完成对指令的解释执行。指令，即指机器指令。每条指令可以完成一个独立的算术运算或逻辑运算操作。在采用微程序控制器的CPU中，一条指令对应一个微程序，一个微程序由许多微指令构成，一条微指令会发出很多不同的微命令。  

4）什么是指令流水线？指令流水线相对于传统体系结构的优势是什么？  

指令流水线是把指令分解为若干子过程，通过将每个子过程与其他子过程并行执行，来提高计算机的吞吐率的技术。采用流水线技术只需增加少量硬件就能把计算机的运算速度提高几倍，因此成为计算机中普遍使用的一种并行处理技术，通过在同一个时间段使用各功能部件，使得利用率明显提高。  

# 常见问题和易混淆知识点  

1.流水线越多，并行度就越高。是否流水段越多，指令执行越快？  

错误，原因如下：  

1）流水段缓冲之间的额外开销增大。每个流水段有一些额外开销用于缓冲间传送数据、进行各种准备和发送等功能，这些开销加长了一条指令的整个执行时间，当指令间逻辑上相互依赖时，开销更大。  

2）流水段间控制逻辑变多、变复杂。用于流水线优化和存储器（或寄存器）冲突处理的控制逻辑将随流水段的增加而大增，这可能导致用于流水段之间控制的逻辑比段本身的控制逻辑更复杂。  

2.读后写（WAR）相关和写后写（WAW）相关的概念  

1）读后写（WriteAfterRead，WAR）冲突。表示当前指令读出数据后，下一条指令才能写该寄存器。否则，先写后读，读到的就是错误（新）数据。在下列指令中，寄存器R1可能存在这样的冲突，当指令12试图在指令Ⅱ1读R1之前就写入该寄存器时，指令I1就错误地读出该寄存器新的内容。  

I1 add R3,R1,R2  $\begin{array}{r l}{\#\left(\mathbb{R}{1}\right)+\left(\mathbb{R}{2}\right)\rightarrow\mathbb{R}{3}}&{{}}\\ {\#\left(\mathbb{R}{4}\right)-\left(\mathbb{R}{5}\right)\rightarrow\mathbb{R}{1}}&{{}}\end{array}$  I2 sub R1,R4,R5  

在读后写（WAR）冲突中，指令I2的目的操作数是指令I1的源操作数。  

3）写后写（WriteAfterWrite，WAW）相关。表示当前指令写入寄存器后，下一条指令才能写该寄存器。否则，下一条指令在当前指令之前写，将使寄存器的值不是最新值。在下列指令中，寄存器RI可能存在这样的冲突，当指令I2试图在指令I1之前就写入R1时，就会错误地使由指令11写入的值成为该寄存器的内容。  

I1 add R1,R2,R3  $\begin{array}{r}{\#\left(\mathbb{R}2\right)+\left(\mathbb{R}3\right)\rightarrow\mathbb{R}1}\\ {\#\left(\mathbb{R}4\right)-\left(\mathbb{R}5\right)\rightarrow\mathbb{R}1}\end{array}$  I2 sub R1,R4,R5  

在写后写（WAW）冲突中，指令I2和指令I1的目的操作数是相同的。  

>##### attention:  

在非按序执行的流水线中，因为允许后进入流水线的指令超过先进入流水线的指令而先流出流水线，所以既可能发生RAW相关，又可能发生WAR和WAW相关。 