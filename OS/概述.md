
# above  

## 【考纲内容】  

（一）操作系统的基本概念  

（二）操作系统的发展历程  

（三）程序运行环境  

CPU运行模式：内核模式与用户模式：中断和异常的处理：系统调用：程序的链接与装入：程序运行时内存映像与地址空间  

（四）操作系统结构分层、模块化、宏内核、微内核、外核  

（五）操作系统引导  

（六）虚拟机  

## 【复习提示】  

常以选择题的形式考查，重点考查操作系统的功能、运行环境和提供的服务。

要求：
- 宏观：操作系统各部分的功能
- 微观：细微的知识点

thus，复习操作系统时，首先要形成大体框架，并通过反复复习和做题巩固知识体系，然后将操作系统的所有内容串成一个整体。

本章的内容有助于读者整体上初步认识操作系统，为后面掌握各章节的知识点奠定基础，moreover整体把握课程，不要因为本章的内容在历年考题中出现的比例不高而忽视它。  

# 基本概念  

## 概念  
- 操作系统（OperatingSystem，OS）
  - 控制和管理整个计算机系统的硬件与软件资源
  - 合理地组织、调度计算机的工作与资源的分配
  - moreover为用户和其他软件提供方便接口与环境的**程序集合**

- OS：计算机系统中 最**基本** 的 系统软件
- 计算机系统(自下而上)
  - 硬件
  - **OS**
    - 管理各种计算机硬件，为应用程序提供**基础**，并且充当计算机硬件与用户之间的**中介** 
    - 控制和协调各用户的应用程序对硬件的分配与使用，提供了正确使用这些资源的**方法**  
  - 应用程序和用户
  
  （这里的划分与 计算机组成原理中的分层不同）

---

硬件（中央处理器、内存、输入/输出设备等）提供基本的**计算资源**

应用程序（字处理程序、电子制表软件、编译器、网络浏览器等）规定按何种**方式**使用这些资源来解决用户的计算问题





## 特征/基本特征 

操作系统是一种**系统软件**，但与其他系统软件和应用软件有很大的不同，它有自己的特殊性即基本特征。
  

### 并发（Concurrence）  

- **两**个或**多**个事件在 <u>同一时间间隔</u> 内发生

多道程序环境下：
在内存中同时装有若干道程序，以便当运行某道程序时，利用其因I/O操作而暂停执行时的CPU空档时间，再调度另一道程序运行，从而实现多道程序交替运行，使CPU保持忙碌状态

>#### pro：并行性的定义及分析（2009）  

- 在<u>同一时刻</u>能完成两种或两种以上的工作（同时进行运算或操作的特性）

支持<u>多道</u>程序的 <u>单处理机</u>环境下：

For a while，
宏观上有多道程序在同时执行，而在每个时刻，实际仅能有一道程序执行，thus微观上这些程序仍是分时交替执行的。

可见，操作系统的并发性是通过分时得以实现的。而CPU与I/O设备、I/O设备和I/O设备则能实现真正的并行。若要实现进程的并行则需要有相关硬件的支持，如多流水线或多处理机环境。  

>##### attention：同一时间间隔（并发）和同一时刻（并行）的区别

eg：在9:00一9:10仅吃面包，在9:10一9:20仅写字，在9:20一9:30仅吃面包，在9:30一10:00仅写字，那么在9:00一10:00吃面包和写字这两种行为就是并发执行的：再如，如果你在9：00一10：00右手写字，左手同时拿着面包吃，那么这两个动作就是并行执行的。  

引入进程的目的是使程序能并发执行。  

### 共享（Sharing）  

资源共享即共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。资源共享主要可分为互斥共享和同时访问两种方式。  

#### 互斥共享方式  

系统中的某些资源，如打印机、磁带机，虽然可供多个进程使用，但为使得所打印或记录的结果不致造成混淆，应规定在一段时间内只充许一个进程访问该资源。  

为此，当进程A访问某个资源时，必须先提出请求，若此时该资源空闲，则系统便将之分配给A使用，此后有其他进程也要访问该资源时（只要A未用完）就必须等待。仅当A访问完并释放该资源后，才允许另一个进程对该资源进行访问。我们将这种资源共享方式称为互式共享，而将在一段时间内只充许一个进程访问的资源称为临界资源。计算机系统中的大多数物理设备及某些软件中所用的栈、变量和表格，都属于临界资源，它们都要求被互斥地共享。  

#### 同时访问方式  

系统中还有另一类资源，这类资源充许在一段时间内由多个进程“同时”访问。这里所说的“同时”通常是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问即“分时共享”的。可供多个进程“同时”访问的典型资源是磁盘设备，一些用重入代码编写的文件也可被“同时”共享，即允许若干用户同时访问该文件。  
注意，互斥共享要求一种资源在一段时间内（哪怕是一段很短的时间）只能满足一个请求，否则就会出现严重的向题（你能想象打印机第一行打印文档A的内容、第二行打印文档B的内容的效果吗？），而同时访问共享通常要求一个请求分几个时间片段间隔地完成，其效果与连续完成的效果相同。  

并发和共享是操作系统两个最基本的特征，两者之间互为存在的条件： $\textcircled{\scriptsize{1}}$ 资源共享是以程序的并发为条件的，若系统不充许程序并发执行，则自然不存在资源共享问题； $\circledcirc$ 若系统不能对资源共享实施有效的管理，则必将影响到程序的并发执行，甚至根本无法并发执行。  

### 虚拟（Virtual)  

虚拟是指将一个物理上的实体变为若干逻辑上的对应物。物理实体（前者）是实的，即实际存在的；而后者是虚的，是用户感觉上的事物。用于实现虚拟的技术称为虚拟技术。操作系统的虚拟技术可归纳为：时分复用技术，如虚拟处理器；空分复用技术，如虚拟存储器。  

通过多道程序设计技术，让多道程序并发执行，来分时使用一个处理器。此时，虽然只有一个处理器，但它能同时为多个用户服务，使每个终端用户都感觉有一个CPU在专门为它服务。利用多道程序设计技术将一个物理上的CPU虚拟为多个逻辑上的CPU，称为虚拟处理器。  

采用虚拟存储器技术将一台机器的物理存储器变为虚拟存储器，以便从逻辑上扩充存储器的容量。当然，这时用户所感觉到的内存容量是虚的。我们将用户感觉到（但实际不存在）的存储器称为虚拟存储器。  

还可采用虚拟设备技术将一台物理1/0设备虚拟为多台逻辑上的1/O设备，并充许每个用户占用一台逻辑上的I/O设备，使原来仅充许在一段时间内由一个用户访问的设备（临界资源）变为在一段时间内充许多个用户同时访问的共享设备。  

### 异步（A synchro n is m）  

多道程序环境允许多个程序并发执行，但由于资源有限，进程的执行并不是一贯到底的，而是走走停停的，它以不可预知的速度向前推进，这就是进程的异步性。  

异步性使得操作系统运行在一种随机的环境下，可能导致进程产生与时间有关的错误（就像对全局变量的访问顺序不当会导致程序出错一样）。然而，只要运行环境相同，操作系统就须保证多次运行进程后都能获得相同的结果。  

## 目标和功能  

为了给多道程序提供良好的运行环境，操作系统应具有以下几方面的功能：处理机管理、存储器管理、设备管理和文件管理。为了方便用户使用操作系统，还必须向用户提供接口。同时，操作系统可用来扩充机器，以提供更方便的服务、更高的资源利用率。  

我们用一个直观的例子来理解这种情况。例如，用户是雇主，操作系统是工人（用来操作机器），计算机是机器（由处理机、存储器、设备、文件几个部件构成），工人有熟练的技能，能够控制和协调各个部件的工作，这就是操作系统对资源的管理；同时，工人必须接收雇主的命令，这就是“接口”；有了工人，机器就能发挥更大的作用，thus工人就成了“扩充机器”。  

### 操作系统作为计算机系统资源的管理者  

#### 处理机管理  

在多道程序环境下，处理机的分配和运行都以进程（或线程）为基本单位，因而对处理机的管理可归结为对进程的管理。并发是指在计算机内同时运行多个进程，thus进程何时创建、何时撤销、如何管理、如何避免冲突、合理共享就是进程管理的最主要的任务。进程管理的主要功能包括进程控制、进程同步、进程通信、死锁处理、处理机调度等。  
#### 存储器管理  

存储器管理是为了给多道程序的运行提供良好的环境，方便用户使用及提高内存的利用率，主要包括内存分配与回收、地址映射、内存保护与共享和内存扩充等功能。  

#### 文件管理  

计算机中的信息都是以文件的形式存在的，操作系统中负责文件管理的部分称为文件系统。文件管理包括文件存储空间的管理、目录管理及文件读写管理和保护等。  

#### 设备管理  

设备管理的主要任务是完成用户的1/O请求，方便用户使用各种设备，并提高设备的利用率，主要包括缓冲管理、设备分配、设备处理和虚拟设备等功能。  

这些工作都由“工人”负责，“雇主”无须关注。  

### 操作系统作为用户与计算机硬件系统之间的接口  

为了让用户方便、快捷、可靠地操纵计算机硬件并运行自己的程序，操作系统还提供了用户接口。操作系统提供的接口主要分为两类：一类是命令接口，用户利用这些操作命令来组织和控制作业的执行；另一类是程序接口，编程人员可以使用它们来请求操作系统服务。  

#### 命令接口  

使用命令接口进行作业控制的主要方式有两种，即联机控制方式和脱机控制方式。按作业控制方式的不同，可将命令接口分为联机命令接口和脱机命令接口。  

联机命令接口又称交互式命令接口，适用于分时或实时系统的接口。它由一组键盘操作命令组成。用户通过控制台或终端输入操作命令，向系统提出各种服务要求。用户每输入一条命令，控制权就转给操作系统的命令解释程序，然后由命令解释程序解释并执行输入的命令，完成指定的功能。之后，控制权转回控制台或终端，此时用户又可输入下一条命令。联机命令接口可以这样理解：“雇主”说一句话，“工人”做一件事，并做出反馈，这就强调了交互性。  

脱机命令接口又称批处理命令接口，适用于批处理系统，它由一组作业控制命令组成。脱机用户不能直接干预作业的运行，而应事先用相应的作业控制命令写成一份作业操作说明书，连同作业一起提交给系统。系统调度到该作业时，由系统中的命令解释程序逐条解释执行作业说明书上的命令，从而间接地控制作业的运行。脱机命令接口可以这样理解：“雇主”将要“工人”做的事写在清单上，“工人”按照清单命令逐条完成这些事，这就是批处理。  

#### 程序接口  

>#### pro：操作系统为应用程序提供的接口（2010）  

程序接口由一组系统调用（也称广义指令）组成。用户通过在程序中使用这些系统调用来请求操作系统为其提供服务，如使用各种外部设备、审请分配和回收内存及其他各种要求。  

当前最流行的是图形用户界面（GUI），即图形接口。GUI最终是通过调用程序接口实现的，用户通过鼠标和键盘在图形界面上单击或使用快捷键，就能很方便地使用操作系统。严格来说图形接口不是操作系统的一部分，但图形接口所调用的系统调用命令是操作系统的一部分。  

### 操作系统实现了对计算机资源的扩充  

没有任何软件支持的计算机称为裸机，它仅构成计算机系统的物质基础，而实际呈现在用户面前的计算机系统是经过若干层软件改造的计算机。裸机在最里层，其外面是操作系统。操作系统所提供的资源管理功能和方便用户的各种服务功能，将裸机改造成功能更强、使用更方便的机器；thus，我们通常将覆盖了软件的机器称为扩充机器或虚拟机。  
“工人”操作机器，机器就有更大的作用，于是“工人”便成了“扩充机器”。注意，本课程所关注的内容是操作系统如何控制和协调处理机、存储器、设备和文件，而不关注接口和扩充机器，后两者读者只需要有个印象，能理解即可。  
  

# 发展历程  

## 手工操作阶段（此阶段无操作系统）  

用户在计算机上算题的所有工作都要人工干预，如程序的装入、运行、结果的输出等。随着计算机硬件的发展，人机矛盾（速度和资源利用）越来越大，必须寻求新的解决办法。  

手工操作阶段有两个突出的缺点： $\textcircled{\scriptsize{1}}$ 用户独占全机，虽然不会出现因资源已被其他用户占用而等待的现象，但资源利用率低。 $\circledcirc$ CPU等待手工操作，CPU的利用不充分。  

唯一的解决办法就是用高速的机器代替相对较慢的手工操作来对作业进行控制。  

## 批处理阶段（操作系统开始出现）  

为了解决人机矛盾及CPU和I/O设备之间速度不匹配的矛盾，出现了批处理系统。按发展历程又分为单道批处理系统、多道批处理系统（多道程序设计技术出现以后）。  
>#### pro：批处理系统的特点（2016）  

### 单道批处理系统  

为实现对作业的连续处理，需要先将一批作业以脱机方式输入磁带，并在系统中配上监督程序（Monitor），在其控制下，使这批作业能一个接一个地连续处理。虽然系统对作业的处理是成批进行的，但内存中始终保持一道作业。单道批处理系统的主要特征如下：  

1）自动性。在顺利的情况下，磁带上的一批作业能自动地逐个运行，而无须人工干预。2）顺序性。磁带上的各道作业顺序地进入内存，先调入内存的作业先完成。  

3）单道性。内存中仅有一道程序运行，即监督程序每次从磁带上只调入一道程序进入内存运行，当该程序完成或发生异常情况时，才换入其后继程序进入内存运行。  

此时面临的问题是：每次主机内存中仅存放一道作业，每当它在运行期间（注意这里是“运行时”而不是“完成后"）发出输入/输出请求后，高速的CPU便处于等待低速的I/O完成的状态。为了进一步提高资源的利用率和系统的吞吐量，引入了多道程序技术。  

### 多道批处理系统  

用户所提交的作业都先存放在外存上并排成一个队列，作业调度程序按一定的算法从后备队列中选择若干作业调入内存，它们在管理程序的控制下相互穿插地运行，共享系统中的各种硬软件资源。当某道程序因请求I/O操作而暂停运行时，CPU使立即转去运行另一道程序，这是通过中断机制实现的。它让系统的各个组成部分都尽量的“忙”，切换任务所花费的时间很少，因而可实现系统各部件之间的并行工作，使其在单位时间内的效率翻倍。  

>#### pro：多道批处理系统的特点（2017、2018、2022）  

多道程序设计的特点是多道、宏观上并行、微观上事行。1）多道。计算机内存中同时存放多道相互独立的程序。2）宏观上并行。同时进入系统的多道程序都处于运行过程中，但都未运行完毕3）微观上串行。内存中的多道程序轮流占有CPU，交替执行。多道程序设计技术的实现需要解决下列问题：  

1）如何分配处理器。2）多道程序的内存分配问题。3）IO设备如何分配。  

4）如何组织和存放大量的程序和数据，以方便用户使用并保证其安全性与一致性。  

在批处理系统中采用多道程序设计技术就形成了多道批处理操作系统。该系统将用户提交的作业成批地送入计算机内存，然后由作业调度程序自动地选择作业运行。  

优点：资源利用率高，多道程序共享计算机资源，从而使各种资源得到充分利用：系统吞吐量大，CPU和其他资源保持“忙碌”状态。缺点：用户响应的时间较长；不提供人机交互能力，用户既不能了解自己的程序的运行情况，又不能控制计算机。  

>##### attention:  

2018年真题考查的多任务操作系统可视为具有交互性的多道批处理系统。  

## 分时操作系统  

所谓分时技术，是指将处理器的运行时间分成很短的时间片，按时间片轮流将处理器分配给各联机作业使用。若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时停正运行，将处理器让给其他作业使用，等待下一轮再继续运行。由于计算机速度很快，作业运行轮转得也很快，thus给每个用户的感觉就像是自己独占一台计算机。  
分时操作系统是指多个用户通过终端同时共享一台主机，这些终端连接在主机上，用户可以同时与主机进行交互操作而互不干扰。thus，实现分时系统的关键问题是如何使用户能与自己的作业进行交互，即当用户在自己的终端上键入命令时，系统应能及时接收并及时处理该命令，再将结果返回用户。分时系统也是支持多道程序设计的系统，但它不同于多道批处理系统。多道批处理是实现作业自动控制而无须人工干预的系统，而分时系统是实现人机交互的系统，这使得分时系统具有与批处理系统不同的特征。分时系统的主要特征如下：  

1）同时性。同时性也称多路性，指允许多个终端用户同时使用一台计算机。  

2）交互性。用户通过终端采用人机对话的方式直接控制程序运行，与同程序进行交互。3）独立性。系统中多个用户可以彼此独立地进行操作，互不干扰，单个用户感觉不到别人也在使用这台计算机，好像只有自己单独使用这台计算机一样。4）及时性。用户请求能在很短时间内获得响应。  

虽然分时操作系统较好地解决了人机交互问题，但在一些应用场合，需要系统能对外部的信息在规定的时间（比时间片的时间还短）内做出处理（比如飞机订票系统或导弹制导系统），thus，实时操作系统应运而生。  

## 实时操作系统  

为了能在某个时间限制内完成某些紧急任务而不需要时间片排队，诞生了实时操作系统。这里的时间限制可以分为两种情况：若某个动作必须绝对地在规定的时刻（或规定的时间范围）发生，则称为硬实时系统，如飞行器的飞行自动控制系统，这类系统必须提供绝对保证，让某个特定的动作在规定的时间内完成。若能够接受偶尔违反时间规定且不会引起任何永久性的损害，则称为软实时系统，如飞机订票系统、银行管理系统。  

在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并在严格的时限内处理完接收的事件。实时操作系统的主要特点是及时性和可靠性。  

## 网络操作系统和分布式计算机系统  

网络操作系统将计算机网络中的各台计算机有机地结合起来，提供一种统一、经济而有效的使用各台计算机的方法，实现各台计算机之间数据的互相传送。网络操作系统最主要的特点是网络中各种资源的共享及各台计算机之间的通信。  

分布式计算机系统是由多台计算机组成并满足下列条件的系统：系统中任意两台计算机通过通信方式交换信息；系统中的每台计算机都具有同等的地位，即没有主机也没有从机；每台计算机上的资源为所有用户共享；系统中的任意台计算机都可以构成一个子系统，并且还能重构：任何工作都可以分布在几台计算机上，由它们并行工作、协同完成。用于管理分布式计算机系统的操作系统称为分布式计算机系统。该系统的主要特点是：分布性和并行性。分布式操作系统与网络操作系统的本质不同是，分布式操作系统中的若干计算机相互协同完成同一任务。  

## 个人计算机操作系统  

个人计算机操作系统是目前使用最广泛的操作系统，它广泛应用于文字处理、电子表格、游戏中，常见的有Windows、Linux和MacOS等。操作系统的发展历程如图1.1所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f0b0a74fe593824117427da27a54272d9549040a746ec72171a717ad41491567.jpg)  
图1.1操作系统的发展历程  

此外，还有嵌入式操作系统、服务器操作系统、智能手机操作系统等  





# 运行环境  

## 处理器运行模式“  

在计算机系统中，通常CPU执行两种不同性质的程序：一种是操作系统内核程序；另一种是用户自编程序（系统外层的应用程序，简称应用程序）。对操作系统而言，这两种程序的作用不同，前者是后者的管理者，thus“管理程序”（内核程序）要执行一些特权指令，而“被管理程序”（用户自编程序）出于安全考虑不能执行这些特权指令。  

>#### pro：特权指令和非特权指令的特点（2022）  

1）特权指令，是指不允许用户直接使用的指令，如1/0指令、关中断指令、内存清零指令，存取用于内存保护的寄存器、送PSW到程序状态字寄存器等的指令。2）非特权指令，是指允许用户直接使用的指令，它不能直接访问系统中的软硬件资源，仅限于访问用户的地址空间，这也是为了防止用户程序对系统造成破坏。  

>#### pro：内核态执行的指令分析（2021）  

>#### pro：用户态发生或执行的事件分析（2011、2012、2014）  

在具体实现上，将CPU的运行模式划分为用户态（目态）和核心态（又称管态、内核态）。可以理解为CPU内部有一个小开关，当小开关为O时，CPU处于核心态，此时CPU可以执行特权指令，切换到用户态的指令也是特权指令。当小开关为1时，CPU处于用户态，此时CPU只能执行非特权指令。应用程序运行在用户态，操作系统内核程序运行在核心态。应用程序向操作系统请求服务时通过使用访管指令，访管指令是在用户态执行的，thus是非特权指令。  

在软件工程思想和结构化程序设计方法影响下诞生的现代操作系统，几乎都是分层式的结构。操作系统的各项功能分别被设置在不同的层次上。一些与硬件关联较紧密的模块，如时钟管理、中断处理、设备驱动等处于最低层。其次是运行频率较高的程序，如进程管理、存储器管理和设备管理等。这两部分内容构成了操作系统的内核。这部分内容的指令运行在核心态。  

内核是计算机上配置的底层软件，它管理着系统的各种资源，可以看作是连接应用程序和硬件的一座桥梁，大多数操作系统的内核包括4方面的内容。  

### 时钟管理  

>#### pro：时钟中断服务的内容（2018）  

在计算机的各种部件中，时钟是关键设备。时钟的第一功能是计时，操作系统需要通过时钟管理，向用户提供标准的系统时间。另外，通过时钟中断的管理，可以实现进程的切换。例如，在分时操作系统中采用时间片轮转调度，在实时系统中按截止时间控制运行，在批处理系统中通过时钟管理来衡量一个作业的运行程度等。thus，系统管理的方方面面无不依赖于时钟。  
### 中断机制  

>#### pro：中断机制在多道程序设计中的作用（2016）  

引入中断技术的初衷是提高多道程序运行时的CPU利用率，使CPU可以在I/O操作期间执行其他指令。后来逐步得到发展，形成了多种类型，成为操作系统各项操作的基础。例如，键盘或鼠标信息的输入、进程的管理和调度、系统功能的调用、设备驱动、文件访问等，无不依赖于中断机制。可以说，现代操作系统是靠中断驱动的软件。  

中断机制中，只有一小部分功能属于内核，它们负责保护和恢复中断现场的信息，转移控制权到相关的处理程序。这样可以减少中断的处理时间，提高系统的并行处理能力。  

### 原语  

按层次结构设计的操作系统，底层必然是一些可被调用的公用小程序，它们各自完成一个规定的操作，通常将具有这些特点的程序称为原语（AtomicOperation）。它们的特点如下：  

1）处于操作系统的底层，是最接近硬件的部分。2）这些程序的运行具有原子性，其操作只能一气呵成（出于系统安全性和便于管理考虑）。3）这些程序的运行时间都较短，而且调用频繁。  

定义原语的直接方法是关中断，让其所有动作不可分割地完成后再打开中断。系统中的设备驱动、CPU切换、进程通信等功能中的部分操作都可定义为原语，使它们成为内核的组成部分。  

### 系统控制的数据结构及处理  

系统中用来登记状态信息的数据结构很多，如作业控制块、进程控制块（PCB）、设备控制块、各类链表、消息队列、缓冲区、空闲区登记表、内存分配表等。为了实现有效的管理，系统需要一些基本的操作，常见的操作有以下3种：  

1）进程管理。进程状态管理、进程调度和分派、创建与撤销进程控制块等。2）存储器管理。存储器的空间分配和回收、内存信息保护程序、代码对换程序等。3）设备管理。缓冲区管理、设备分配和回收等。可见，核心态指令实际上包括系统调用类指令和一些针对时钟、中断和原语的操作指令。  

## 中断和异常的概念“  

>#### pro：用户态切换到内核态的事件分析（2013、2015）  

在操作系统中引入核心态和用户态这两种工作状态后，就需要考虑这两种状态之间如何切换。操作系统内核工作在核心态，而用户程序工作在用户态。系统不充许用户程序实现核心态的功能，而它们又必须使用这些功能。thus，需要在核心态建立一些“门”，以便实现从用户态进入核心态。在实际操作系统中，CPU运行用户程序时唯一能进入这些“门”的途径就是通过中断或异常。发生中断或异常时，运行用户态的CPU会立即进入核心态，这是通过硬件实现的（例如，用一个特殊寄存器的一位来表示CPU所处的工作状态，0表示核心态，1表示用户态。若要进入核心态，则只需将该位置0即可）。中断是操作系统中非常重要的一个概念，对一个运行在计算机上的实用操作系统而言，缺少了中断机制，将是不可想象的。原因是，操作系统的发展过程大体上就是一个想方设法不断提高资源利用率的过程，而提高资源利用率就需要在程序并未使用某种资源时，将它对那种资源的占有权释放，而这一行为就需要通过中断实现。  
### 中断和异常的定义  

pro： 可能引发中断或异常的指令分析（2013、2015）  

中断（Interruption）也称外中断，是指来自CPU执行指令外部的事件，通常用于信息输入/输出（见第5章），如设备发出的1/0结束中断，表示设备输入/输出处理已经完成。时钟中断，表示一个固定的时间片已到，让处理机处理计时、启动定时运行的任务等。  

异常（Exception）也称内中断，是指来自CPU执行指令内部的事件，如程序的非法操作码、地址越界、运算溢出、虚存系统的缺页及专门的陷入指令等引起的事件。异常不能被屏蔽，一旦出现，就应立即处理。关于内中断和外中断的联系与区别如图1.2所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/493ee587aa4ea7134d5b43927f04c9c39d6157c05d4d8a3e96ba9bbf2dad9e75.jpg)  
图1.2内中断和外中断的联系与区别  

### 中断和异常的分类  

pro：中断和异常的分类（2016）  

外中断可分为可屏蔽中断和不可屏蔽中断。可屏蔽中断是指通过INTR线发出的中断请求，通过改变屏蔽字可以实现多重中断，从而使得中断处理更加灵活。不可屏蔽中断是指通过NMI线发出的中断请求，通常是紧急的硬件敌障，如电源掉电等。此外，异常也是不能被屏蔽的。  

异常可分为故障、自陷和终止。故障（Fault）通常是由指令执行引起的异常，如非法操作码、缺页故障、除数为0、运算溢出等。自陷（Trap，又称陷入）是一种事先安排的“异常”事件，用于在用户态下调用操作系统内核程序，如条件陷阱指令、系统调用指令等。终正（Abort）是指出现了使得CPU无法继续执行的硬件敌障，如控制器出错、存储器校验错等。故障异常和自陷异常属于软件中断（程序性异常），终止异常和外部中断属于硬件中断。  

### 中断和异常的处理过程  

>#### pro：中断和异常的处理过程（2015、2020、2024）  

中断和异常处理过程的大致描述如下：当CPU在执行用户程序的第 $i$ 条指令时检测到一个异常事件，或在执行第i条指令后发现一个中断请求信号，则CPU打断当前的用户程序，然后转到相应的中断或异常处理程序去执行。若中断或异常处理程序能够解决相应的问题，则在中断或异常处理程序的最后，CPU通过执行中断或异常返回指令，回到被打断的用户程序的第条指令或第 $i+1$ 条指令继续执行；若中断或异常处理程序发现是不可恢复的致命错误，则终止用户程序。通常情况下，对中断和异常的具体处理过程面操作系统（和驱动程序）完成。  

>#### pro：中断处理和子程序调用的比较（2012）  

注意区分中断处理和子程序调用： $\textcircled{\scriptsize{1}}$ 中断处理程序与被中断的当前程序是相互独立的，它门之向没有确定的关系：子程序与主程序是同一程序的两部分，它们属于主从关系。 $\textcircled{2}$ 通常中断的产生都是随机的：而子程序调用是通过调用指令（CALL）引起的，是由程序设计者事先安排的。 $\textcircled{3}$ 调用子程序的过程完全属于软件处理过程；而中断处理的过程还需要有专门的硬件电路才能实现。 $\textcircled{4}$ 中断处理程序的入口地址可由硬件向量法产生向量地址，再由向量地址找到入口地址；子程序的入口地址是由CALL指令中的地址码给出的。 $\circledast$ 调用中断处理程序和子程序都需要保护程序计数器（PC）的内容，前者由中断隐指令完成，后者由CALL指令完成（执行CALL指令时，处理器先将当前的PC值压入栈，再将PC设置为被调用子程序的入口地址）。 $\circledcirc$ 响应中断时，需对同时检测到的多个中断请求进行裁决，而调用子程序时没有这种操作。  
## 系统调用  

>#### pro：系统调用的定义及性质（2019、2021）  

系统调用是指用户在程序中调用操作系统所提供的一些子功能，它可被视为特殊的公共子程序。系统中的各种共享资源都由操作系统统一掌管，thus在用户程序中，凡是与资源有关的操作（如存储分配、I/O传输及管理文件等），都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。通常，一个操作系统提供的系统调用命令有几十条乃至上百条之多，每个系统调用都有唯一的系统调用号。这些系统调用按功能大致可分为如下几类。  

>#### pro：系统调用的功能（2021）  

·设备管理。完成设备的请求或释放，以及设备启动等功能。·文件管理。完成文件的读、写、创建及删除等功能。·进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。·进程通信。完成进程之间的消息传递或信号传递等功能。·内存管理。完成内存的分配、回收以及获取作业占用内存区大小和起始地址等功能。  

显然，系统调用相关功能涉及系统资源管理、进程管理之类的操作，对整个系统的影响非常大，thus系统调用的处理需要由操作系统内核程序负责完成，要运行在核心态。  

>#### pro：系统调用的处理过程及CPU状态的变化（2012、2017、2023）  

>#### pro：系统调用处理过程中操作系统负责的任务（2022）  

下面分析系统调用的处理过程：第一步是，用户程序首先将系统调用号和所需的参数压入堆栈；接着，调用实际的调用指令，然后执行一个陷入指令，将CPU状态从用户态转为核心态，再后由硬件和操作系统内核程序保护被中断进程的现场，将程序计数器（PC）、程序状态字（PSW）及通用寄存器内容等压入堆栈。第二步是，分析系统调用类型，转入相应的系统调用处理子程序。在系统中配置了一张系统调用入口表，表中的每个表项都对应一个系统调用，根据系统调用号可以找到该系统调用处理子程序的入口地址。第三步是，在系统调用处理子程序执行结束后，恢复被中断的或设置新进程的CPU现场，然后返回被中断进程或新进程，继续往下执行。  

可以这么理解，用户程序执行“陷入指令”，相当于将CPU的使用权主动交给操作系统内核程序（CPU状态会从用户态进入核心态），之后操作系统内核程序再对系统调用请求做出相应处理。处理完成后，操作系统内核程序又会将CPU的使用权还给用户程序（CPU状态会从核心态回到用户态）。这么设计的目的是：用户程序不能直接执行对系统影响非常大的操作，必须通过系统调用的方式请求操作系统代为执行，以便保证系统的稳定性和安全性。  

这样，操作系统的运行环境就可以理解为：用户通过操作系统运行上层程序（如系统提供的命令解释程序或用户自编程序），而这个上层程序的运行依赖于操作系统的底层管理程序提供服务支持，当需要管理程序服务时，系统则通过硬件中断机制进入核心态，运行管理程序：也可能是程序运行出现异常情况，被动地需要管理程序的服务，这时就通过异常处理来进入核心态。管理程序运行结束时，用户程序需要继续运行，此时通过相应的保存的程序现场退出中断处理程序或异常处理程序，返回断点处继续执行，如图1.3所示。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b1906f3c0ca66238f8d17735d697a2137fc1f07f9548f85837ea5f14001eeb54.jpg)  
图1.3系统调用执行过程  

在操作系统这一层面上，我们关心的是系统核心态和用户态的软件实现与切换，对于硬件层面的具体理解，可以结合“计算机组成原理”课程中有关中断的内容进行学习。  

下面列举一些由用户态转向核心态的例子  

1）用户程序要求操作系统的服务，即系统调用。2）发生一次中断。3）用户程序中产生了一个错误状态。4）用户程序中企图执行一条特权指令。从核心态转向用户态由一条指令实现，这条指令也是特权命令，一般是中断返回指令。  

 
# 结构  

随着操作系统功能的不断增多和代码规模的不断扩大，提供合理的结构，对于降低操作系统复杂度、提升操作系统安全与可靠性来说变得尤为重要。  

## 分层法  

分层法是将操作系统分为若干层，底层（层0）为硬件，顶层（层N）为用户接口，每层只能调用紧邻它的低层的功能和服务（单向依赖）。这种分层结构如图1.4所示。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/81bbbd88798a995473d2b6d27deb4a915fcfcbafc635c31bcc01aff7f13f3a14.jpg)  
图1.4分层的操作系统  

分层法的优点： $\textcircled{\scriptsize{1}}$ 便于系统的调试和验证，简化了系统的设计和实现。第1层可先调试而无须考虑系统的其他部分，因为它只使用了基本硬件。第1层调试完且验证正确之后，就可以调试第2层，如此向上。如果在调试某层时发现错误，那么错误应在这一层上，这是因为它的低层都调试好了。 $\circledcirc$ 易扩充和易维护。在系统中增加、修改或替换一层中的模块或整层时，只要不改变相应层间的接口，就不会影响其他层。  

分层法的问题： $\textcircled{\scriptsize{1}}$ 合理定义各层比较困难。因为依赖关系固定后，往往就显得不够灵活。 $\circledcirc$ 效率较差。操作系统每执行一个功能，通常要自上而下地穿越多层，各层之间都有相应的层间通信机制，这无疑增加了额外的开销，导致系统效率降低。  

## 模块化  

模块化是将操作系统按功能划分为若干具有一定独立性的模块。每个模块具有某方面的管理功能，并规定好各模块间的接口，使各模块之间能够通过接口进行通信。还可以进一步将各模块细分为若干具有一定功能的子模块，同样也规定好各子模块之间的接口。这种设计方法被称为模块-接口法，图1.5所示为由模块、子模块等组成的模块化操作系统结构。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/66329b0f96d29e529b392be4dd0882f9c485466dfcef3858e75c9ac55e961c55.jpg)  
图1.5由模块、子模块等组成的模块化操作系统结构  
在划分模块时，如果将模块划分得太小，虽然能降低模块本身的复杂性，但会使得模块之间的联系过多，造成系统比较混乱：如果模块划分得过大，又会增加模块内部的复杂性，显然应在两者间进行权衡。此外，在划分模块时，要充分考虑模块的独立性问题，因为模块独立性越高，各模块间的交互就越少，系统的结构也就越清晰。衡量模块的独立性主要有两个标准：  

内聚性，模块内部各部分间联系的紧密程度。内聚性越高，模块独立性越好。耦合度，模块间相互联系和相互影响的程度。耦合度越低，模块独立性越好。  

模块化的优点： $\textcircled{\scriptsize{1}}$ 提高了操作系统设计的正确性、可理解性和可维护性； $\circledcirc$ 增强了操作系统的可适应性； $\textcircled{3}$ 加速了操作系统的开发过程。  

模块化的缺点： $\textcircled{\scriptsize{1}}$ 模块间的接口规定很难满足对接口的实际需求。 $\textcircled{2}$ 各模块设计者齐头并进每个决定无法建立在上一个已验证的正确决定的基础上，thus无法找到一个可靠的决定顺序。  

## 宏内核  

从操作系统的内核架构来划分，可分为宏内核和微内核。  

宏内核，也称单内核或大内核，是指将系统的主要功能模块都作为一个紧密联系的整体运行在核心态，从而为用户程序提供高性能的系统服务。因为各管理模块之间共享信息，能有效利用相互之间的有效特性，所以具有无可比拟的性能优势。  

随着体系结构和应用需求的不断发展，需要操作系统提供的服务越来越复杂，操作系统的设计规模急剧增长，操作系统也面临着“软件危机”困境。就像一个人，越胖活动起来就越困难。所以就出现了微内核技术，就是将一些非核心的功能移到用户空间，这种设计带来的好处是方便扩展系统，所有新服务都可以在用户空间增加，内核基本不用去做改动。  

从操作系统的发展来看，宏内核获得了绝对的胜利，目前主流的操作系统，如Windows、Android、iOS、macOS、Linux等，都是基于宏内核的构架。但也应注意到，微内核和宏内核一直是同步发展的，自前主流的操作系统早已不是当年纯粹的宏内核构架了，而是广泛吸取微内核构架的优点而后揉合而成的混合内核。当今宏内核构架遇到了越来越多的困难和挑战，而微内核 的优势似乎越来越明显，尤其是谷歌的Fuchsia和华为的鸿蒙OS，都瞄准了微内核构架。  

## 微内核  

### 基本概念  

微内核构架，是指将内核中最基本的功能保留在内核，而将那些不需要在核心态执行的功能移到用户态执行，从而降低内核的设计复杂性。那些移出内核的操作系统代码根据分层的原则被划分成若干服务程序，它们的执行相互独立，交互则都借助于微内核进行通信。  

微内核结构将操作系统划分为两大部分：微内核和多个服务器。微内核是指精心设计的、能实现操作系统最基本核心功能的小型内核，通常包含： $\textcircled{\scriptsize{1}}$ 与硬件处理紧密相关的部分： $\textcircled{2}$ 一些较基本的功能； $\textcircled{3}$ 客户和服务器之间的通信。这些部分只是为构建通用操作系统提供一个重要基础，这样就可以确保将内核做得很小。操作系统中的绝大部分功能都放在微内核外的一组服务器（进程）中实现，如用于提供对进程（线程）进行管理的进程（线程）服务器、提供虚拟存储器管理功能的虚拟存储器服务器等，它们都是作为进程来实现的，运行在用户态，客户与服务器之间是借助微内核提供的消息传递机制来实现交互的。图1.6展示了单机环境下的客户/服务器模式。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8a2da0b5134ea9c29a2947ba9281d8adcfa2f6cfc1e46a2266262f4d7a0725ec.jpg)  
图1.6单机环境下的客户/服务器模式  

用户方式核心方式  
在微内核结构中，为了实现高可靠性，只有微内核运行在内核态，其余模块都运行在用户态，一个模块中的错误只会使这个模块前溃，而不会使整个系统崩溃。例如，文件服务代码运行时出了问题，宏内核因为文件服务是运行在内核态的，系统直接就崩溃了。而微内核的文件服务是运行在用户态的，只要将文件服务功能强行停止，然后重启，就可以继续使用，系统不会崩溃。  

### 基本功能  

微内核结构通常利用“机制与策略分离”的原理来构造OS结构，将机制部分以及与硬件紧密相关的部分放入微内核。微内核通常具有如下功能：  

$\textcircled{\scriptsize{1}}$ 进程（线程）管理。进程（线程）之间的通信功能是微内核OS最基本的功能，此外还有进程的切换、进程的调度，以及多处理机之间的同步等功能，都应放入微内核。举个例子，为实现进程调度功能，需要在进程管理中设置一个或多个进程优先级队列，这部分属于调度功能的机制部分，应将它放入微内核。而对用户进程如何分类，以及优先级的确认方式，则属于策略问题，可将它们放入微内核外的进程管理服务器中。  

$\textcircled{2}$ 低级存储器管理。在微内核中，只配置最基本的低级存储器管理机制，如用于实现将逻辑地址变换为物理地址等的页表机制和地址变换机制，这一部分是依赖于硬件的，thus放入微内核。而实现虚拟存储器管理的策略，则包含应采取何种页面置换算法，采用何种内存分配与回收的策略，应将这部分放在微内核外的存储器管理服务器中。  

$\textcircled{3}$ 中断和陷入处理。微内核OS将与硬件紧密相关的一小部分放入微内核，此时微内核的主要功能是捕获所发生的中断和陷入事件，并进行中断响应处理，在识别中断或陷入的事件后，再发送给相关的服务器来处理，故中断和陷入处理也应放入微内核。  

微内核操作系统将进程管理、存储器管理以及1/O管理这些功能一分为二，属于机制的很小一部分放入微内核，而绝大部分放入微内核外的各种服务器实现，大多数服务器都要比微内核大。thus，在采用客户/服务器模式时，能将微内核做得很小。  

### 特点  

>#### pro：微内核操作系统的特点（2023）  

微内核结构的主要优点如下所示。  

$\textcircled{\scriptsize{1}}$ 扩展性和灵活性。许多功能从内核中分离出来，当要修改某些功能或增加新功能时，只需在相应的服务器中修改或新增功能，或再增加一个专用的服务器，而无需改动内核代码。  

$\circledcirc$ 可靠性和安全性。前面已举例说明。  

$\textcircled{3}$ 可移植性。与CPU和I/O硬件有关的代码均放在内核中，而其他各种服务器均与硬件平台无关，因而将操作系统移植到另一个平台上所需做的修改是比较小的。  

$\textcircled{4})$ 分布式计算。客户和服务器之间、服务器和服务器之间的通信采用消息传递机制，这就使得微内核系统能很好地支持分布式系统和网络系统。  

微内核结构的主要问题是性能问题，因为需要频紧地在核心态和用户态之间进行切换，操作系统的执行开销偏大。为了改善运行效率，可以将那些频繁使用的系统服务移回内核，从而保证系统性能，但这又会使微内核的容量明显地增大。  

虽然宏内核在桌面操作系统中取得了绝对的胜利，但是微内核在实时、工业、航空及军事应用中特别流行，这些领域都是关键任务，需要有高度的可靠性。  

## 外核  

不同于虚拟机克隆真实机器，另一种策略是对资源进行划分，给每个用户分配整个资源的一个子集。这样，某个虚拟机可能得到磁盘的0至1023盘块，而另一台虚拟机得到磁盘的1024至2047盘块等。在底层，一种称为外核（exokernel）的程序在内核态中运行。它的任务是为虚拟机分配资源，并检查这些资源使用的安全性，以确保没有机器会使用他人的资源。每个用户的虚拟机可以运行自己的操作系统，但限制只能使用已经申请并且获得分配的那部分资源。  
外核机制的优点是减少了资源的“映射层”。在其他设计中，每个虚拟机系统都认为它拥有完整的磁盘（或其他资源），这样虚拟机监控程序就必须维护一张表格以重映像磁盘地址，有了外核，这个重映射处理就不需要了。外核只需要记录已分配给各个虚拟机的有关资源即可。这种方法还有一个优点，它将多道程序（在外核内）与用户操作系统代码（在用户空间内）加以分离，而且相应的负载并不重，因为外核所做的只是保持多个虚拟机彼此不发生冲突。  

# 引导  

操作系统（如Windows、Linux等）是一种程序，程序以数据的形式存放在硬盘中，而硬盘通常分为多个区，一台计算机中又可能有多个或多种外部存储设备。操作系统引导是指计算机利用CPU运行特定程序，通过程序识别硬盘，识别硬盘分区，识别硬盘分区上的操作系统，最后通过程序启动操作系统，一环扣一环地完成上述过程。  

>#### pro：操作系统的引1导过程（2021）  

常见操作系统的引导过程如下：  

$\textcircled{\scriptsize{1}}$ 激活CPU。激活的CPU读取ROM中的boot程序，将指令寄存器置为BIOS（基本输入/输出系统）的第一条指令，即开始执行BIOS的指令。  

>#### pro：操作系统引|导过程中创建的数据结构（2022）  

$\circledcirc$ 硬件自检。BIOS程序在内存最开始的空间构建中断向量表，接下来的POST过程要用到中断功能。然后进行通电自检，检查硬件是否出现故障。如有故障，主板会发出不同含义的蜂鸣，启动中止：如无故障，屏幕会显示CPU、内存、硬盘等信息。  

$\textcircled{3}$ 加载带有操作系统的硬盘。通电自检后，BIOS开始读取BootSequence（通过CMOS里保存的启动顺序，或者通过与用户交互的方式），将控制权交给启动顺序排在第一位的存储设备，然后CPU将该存储设备引导扇区的内容加载到内存中。  

$\textcircled{4}$ 加载主引导记录（MBR）。硬盘以特定的标识符区分引导硬盘和非引导硬盘。如果发现一个存储设备不是可引导盘，就检查下一个存储设备。如无其他启动设备，就会死机。主引导记录MBR的作用是告诉CPU去硬盘的哪个主分区去找操作系统。  

$\circledast$ 扫描硬盘分区表，并加载硬盘活动分区。MBR包含硬盘分区表，硬盘分区表以特定的标识符区分活动分区和非活动分区。主引导记录扫描硬盘分区表，moreover识别含有操作系统的硬盘分区（活动分区）。找到硬盘活动分区后，开始加载硬盘活动分区，将控制权交给活动分区。  

$\circledcirc$ 加载分区引导记录（PBR）。读取活动分区的第一个扇区，这个扇区称为分区引导记录（PBR），其作用是寻找并激活分区根目录下用于引导操作系统的程序（启动管理器）。  

$\textcircled{\scriptsize{2}}$ 加载启动管理器。分区引导记录搜索活动分区中的启动管理器，加载启动管理器。  

>#### pro：操作系统运行的存储器（2013）  

$\textcircled{8}$ 加载操作系统。将操作系统的初始化程序加载到内存中执行。  
# 虚拟机  

## 基本概念  

虚拟机是指利用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器，通过隐藏特定计算平台的实际物理特性，为用户提供抽象的、统一的、模拟的计算环境。有两类虚拟化方法。  

### 第一类虚拟机管理程序  

从技术上讲，第一类虚拟机管理程序就像一个操作系统，因为它是唯一一个运行在最高特权级的程序。它在裸机上运行并且具备多道程序功能。虚拟机管理程序向上层提供若干虚拟机，这些虚拟机是裸机硬件的精确复制品。由于每台虚拟机都与裸机相同，所以在不同的虚拟机上可以运行任何不同的操作系统。图1.7(a中显示了第一类虚拟机管理程序。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f153beca1806b80b27f1db8ca4a28efeb5e9e92f2caa6875b46354245569316d.jpg)  
图1.7两类虚拟机管理程序在系统中的位置  

虚拟机作为用户态的一个进程运行，不充许执行敏感指令。然而，虚拟机上的操作系统认为自己运行在内核态（实际上不是），称为虚拟内核态。虚拟机中的用户进程认为自已运行在用户态（实际上确实是）。当虚拟机操作系统执行了一条CPU处于内核态才允许执行的指令时，会陷入虚拟机管理程序。在支持虚拟化的CPU上，虚拟机管理程序检查这条指令是由虚拟机中的操作系统执行的还是由用户程序执行的。如果是前者，虚拟机管理程序将安排这条指令功能的正确执行。否则，虚拟机管理程序将模拟真实硬件面对用户态执行敏感指令时的行为。  

在过去不支持虚拟化的CPU上，真实硬件不会直接执行虚拟机中的敏感指令，这些敏感指令被转为对虚拟机管理程序的调用，由虚拟机管理程序模拟这些指令的功能。  

### 第二类虚拟机管理程序  

图1.7(b)中显示了第二类虚拟机管理程序。它是一个依赖于Windows、Linux等操作系统分配和调度资源的程序，很像一个普通的进程。第二类虚拟机管理程序仍然伪装成具有CPU和各种设备的完整计算机。VMware Workstation $\mathrm{x86}$ 平台上的第二类虚拟机管理程序。  

运行在两类虚拟机管理程序上的操作系统都称为客户操作系统。对于第二类虚拟机管理程序，运行在底层硬件上的操作系统称为宿主操作系统。  

首次启动时，第二类虚拟机管理程序像一台刚启动的计算机那样运转，期望找到的驱动器可以是虚拟设备。然后将操作系统安装到虚拟磁盘上（其实只是宿主操作系统中的一个文件）。客户操作系统安装完成后，就能启动并运行。  
虚拟化在Web主机领域很流行。没有虚拟化，服务商只能提供共享托管（不能控制服务器的软件）和独占托管（成本较高）。当服务商提供租用虚拟机时，一台物理服务器就可以运行多个虚拟机，每个虚拟机看起来都是一台完整的服务器，客户可以在虚拟机上安装自己想用的操作系统和软件，但是只需支付较低的费用，这就是市面上常见的“云”主机。  

有的教材将第一类虚拟化技术称为裸金属架构，将第二类虚拟化技术称为寄居架构。  


功能分层设计是分层式OS的特点。通常可以从四个方面来描述微内核OS： $\textcircled{\scriptsize{1}}$ 内核足够小； $\textcircled{2}$ 基于客户/服务器模式； $\textcircled{3}$ 应用“机制与策略分离”原理； $\textcircled{4}$ 采用面向对象技术。  

  

# 本章疑难点  

### 并行性与并发性的区别和联系  

并行性和并发性是既相似又有区别的两个概念。并行性是指两个或多个事件在同一时刻发生，并发性是指两个或多个事件在同一时间间隔内发生。  

在多道程序环境下，并发性是指在一段时间内，宏观上有多个程序同时运行，但在单处理器系统中每个时刻却仅能有一道程序执行，thus微观上这些程序只能分时地交替执行。若在计算机系统中有多个处理器，则这些可以并发执行的程序便被分配到多个处理器上，实现并行执行，即利用每个处理器来处理一个可并发执行的程序。  
### 特权指令与非特权指令  

特权指令是指有特殊权限的指令，由于这类指令的权限最大，使用不当将导致整个系统崩溃，如清内存、置时钟、分配系统资源、修改虚存的段表或页表、修改用户的访问权限等。若所有程序都能使用这些指令，则系统一天死机 $n$ 次就不足为奇。为保证系统安全，这类指令不能直接提供给用户使用，thus特权指令必须在核心态执行。实际上，CPU在核心态下可以执行指令系统的全集。形象地说，特权指令是那些儿童不宜的东西，而非特权指令是老少皆宜的东西。  

为了防止用户程序中使用特权指令，用户态下只能使用非特权指令，核心态下可以使用全部指令。在用户态下使用特权指令时，将产生中断以阻正用户使用特权指令。所以将用户程序放在用户态下运行，而操作系统中必须使用特权指令的那部分程序在核心态下运行，从而保证了系统的安全性和可靠性。从用户态转换为核心态的唯一途径是中断或异常。  

### 访管指令与访管中断  

访管指令是一条可以在用户态下执行的指令。在用户程序中，因要求操作系统提供服务而有意识地使用访管指令，从而产生一个中断事件（自愿中断），将操作系统转换为核心态，称为访管中断。访管中断由访管指令产生，程序员使用访管指令向操作系统请求服务。  

为什么要在程序中引入访管指令呢？这是因为用户程序只能在用户态下运行。若用户程序想要完成在用户态下无法完成的工作，该怎么办？解决这个问题要靠访管指令。访管指令本身不是特权指令，其基本功能是让程序拥有“自愿进管”的手段，从而引起访管中断。  

### 定义微内核结构OS的四个方面  

1）足够小的内核。  

2）基于客户/服务器模式。  

3）应用“机制与策略分离”原理。机制是指实现某一功能的具体执行机构。策略则是在机制的基础上借助于某些参数和算法来实现该功能的优化，或达到不同的功能目标。在传统的OS中，将机制放在OS内核的较低层中，将策略放在内核的较高层中。而在微内核OS中，通常将机制放在OS的微内核中。正因如此，才可以将内核做得很小。4）采用面向对象技术。基于面向对象技术中的“抽象”和“隐蔽”原则能控制系统的复杂性，进一步利用“对象”“封装”和“继承”等概念还能确保操作系统的正确性、可靠性、易扩展性等。正因如此，面向对象技术被广泛应用于现代操作系统的设计之中。  